This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
docs/
  integration_guide.md
  usage_guides.md
packages/
  chatkit_core/
    lib/
      src/
        actions/
          client_tools.dart
        api/
          api_client.dart
          sse_client.dart
        events/
          events.dart
        models/
          attachments.dart
          composer_state.dart
          entities.dart
          models.dart
          page.dart
          request.dart
          response.dart
          thread.dart
          widgets.dart
        utils/
          json.dart
          thread_item_mutations.dart
        chatkit_controller.dart
        errors.dart
        options.dart
      chatkit_core.dart
    test/
      fixtures/
        streaming_fixture.dart
      api_client_test.dart
      attachments_upload_test.dart
      client_tool_test.dart
      controller_busy_test.dart
      hosted_resilience_test.dart
      offline_queue_test.dart
      sse_client_test.dart
      streaming_fixture_test.dart
      thread_event_test.dart
      transport_retry_test.dart
    pubspec.yaml
    README.md
  chatkit_flutter/
    lib/
      src/
        gallery/
          chatkit_gallery.dart
        localization/
          localizations.dart
        theme/
          chatkit_theme.dart
          icons.dart
          styles.dart
          tokens.dart
        widgets/
          chatkit_view.dart
          media_player.dart
          widget_renderer.dart
      chatkit_flutter.dart
    test/
      failures/
        chatkit_gallery_dark_isolatedDiff.png
        chatkit_gallery_dark_maskedDiff.png
        chatkit_gallery_dark_masterImage.png
        chatkit_gallery_dark_testImage.png
        chatkit_gallery_light_isolatedDiff.png
        chatkit_gallery_light_maskedDiff.png
        chatkit_gallery_light_masterImage.png
        chatkit_gallery_light_testImage.png
      golden/
        failures/
          dashboard_widget_isolatedDiff.png
          dashboard_widget_maskedDiff.png
          dashboard_widget_masterImage.png
          dashboard_widget_testImage.png
          form_widget_isolatedDiff.png
          form_widget_maskedDiff.png
          form_widget_masterImage.png
          form_widget_testImage.png
          insights_widget_isolatedDiff.png
          insights_widget_maskedDiff.png
          insights_widget_masterImage.png
          insights_widget_testImage.png
        goldens/
          dashboard_widget.png
          form_widget.png
          insights_widget.png
          workflow_widget.png
        widget_dsl_golden_test.dart
      goldens/
        chatkit_gallery_dark.png
        chatkit_gallery_light.png
      chatkit_gallery_golden_test.dart
      chatkit_view_test.dart
      localizations_test.dart
    pubspec.yaml
    README.md
  examples/
    coach_demo/
      lib/
        main.dart
      pubspec.yaml
      README.md
.gitignore
AGENTS.md
analysis_options.yaml
CHANGELOG.md
LICENSE
MIGRATION.md
plan.md
README.md
SECURITY.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.19.0"
          channel: "stable"
      - name: Install dependencies
        run: |
          flutter pub get
          flutter pub get --directory=packages/chatkit_core
          flutter pub get --directory=packages/chatkit_flutter
          flutter pub get --directory=packages/examples/coach_demo
      - name: Format check
        run: dart format --output=none --set-exit-if-changed .
      - name: Analyze
        run: flutter analyze .
      - name: Tests
        run: |
          dart test packages/chatkit_core
          flutter test packages/chatkit_flutter
          flutter test packages/examples/coach_demo
</file>

<file path="docs/integration_guide.md">
# ChatKit Dart Integration Guide

This guide explains how to integrate the ChatKit Dart port in both pure-Dart
and Flutter environments. It covers the two packages shipped in this repo:

- `chatkit_core` — sometimes nicknamed “chatkit_care” — the headless client
  that mirrors the [chatkit-js](https://openai.github.io/chatkit-js/) API.
- `chatkit_flutter` — the native Flutter UI layer that renders the ChatKit
  widget DSL without a WebView.

The API surface intentionally matches the JS SDK so you can reuse existing
backends such as `chatkit-python` with minimal adjustments.

## Prerequisites

- Dart 3.3+ / Flutter 3.19+ (the examples assume Flutter).
- A ChatKit-compatible backend (for example
  [`chatkit-python`](https://github.com/openai/chatkit-python) or your own
  FastAPI/Express implementation) reachable over HTTPS.
- SSE (server-sent events) enabled on the backend for streaming responses.
- If you depend on attachments, ensure the backend supports direct uploads or
  two-phase uploads (pre-signed URLs).

## Installing the packages

Add the packages to your `pubspec.yaml` from source:

```yaml
dependencies:
  chatkit_core:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_core
  chatkit_flutter:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_flutter
```

Fetch dependencies with `dart pub get` (pure Dart) or `flutter pub get`
(Flutter). You can depend on either package independently.

## Selecting an API configuration

`ChatKitOptions.api` accepts one of two configurations that mirror the JS
client:

### `CustomApiConfig`

Use this when you control the ChatKit-compatible endpoint.

```dart
final options = ChatKitOptions(
  api: CustomApiConfig(
    url: 'https://your-domain/chatkit',
    domainKey: 'optional-domain-verification',
    uploadStrategy: const TwoPhaseUploadStrategy(),
    headersBuilder: (request) => {
      'Authorization': 'Bearer ${authTokenProvider()}',
      'x-app-version': buildNumber,
    },
  ),
);
```

- `uploadStrategy` may be `DirectUploadStrategy` (single POST to a fixed URL) or
  `TwoPhaseUploadStrategy` (request server-signed URLs). If omitted, the server
  controls the upload flow.
- `headersBuilder` runs on every HTTP request, allowing you to inject auth
  tokens or correlation IDs. You can also override the transport entirely via
  `fetchOverride` if you need to proxy requests.

### `HostedApiConfig`

Choose this for hosted deployments where ChatKit manages auth tokens.

```dart
final options = ChatKitOptions(
  api: HostedApiConfig(
    clientToken: initialToken,
    getClientSecret: (current) async {
      return await refreshHostedSecret(current);
    },
  ),
  hostedHooks: HostedHooksOption(
    onAuthExpired: () => banners.show('Session expired. Sign in again.'),
    onAuthRestored: banners.clear,
    onStaleClient: () => controller.fetchUpdates(),
  ),
);
```

At least one of `clientToken` or `getClientSecret` must be supplied. The hosted
hooks mirror the JS lifecycle by disabling the composer on expiry and resuming
when the secret refreshes.

### Transport resilience

For fine-tuning SSE behaviour, provide a `TransportOption`:

```dart
final options = ChatKitOptions(
  api: /* ... */,
  transport: const TransportOption(
    keepAliveTimeout: Duration(seconds: 25),
    initialBackoff: Duration(milliseconds: 250),
    maxBackoff: Duration(seconds: 4),
  ),
);
```

- `keepAliveTimeout` controls when the controller treats the stream as stale.
- Backoff values are applied both to streaming retries and the offline queue.
- Server-provided `retry:` hints are respected and surfaced through
  `ChatKitLogEvent(name: 'transport.retry', data: ...)`.

## Building a shared controller

`chatkit_core` centres around `ChatKitController`. You can share a single
instance between Flutter widgets or use it headlessly on the server.

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: CustomApiConfig(url: 'https://example.com/chatkit'),
    locale: 'en-US',
    history: const HistoryOption(enabled: true, showRename: true),
    startScreen: const StartScreenOption(
      greeting: 'Welcome back!',
      prompts: [
        StartScreenPrompt(
          label: 'Summarize my tickets',
          prompt: 'Summarize the open support tickets.',
          icon: 'sparkles',
        ),
      ],
    ),
    threadItemActions: const ThreadItemActionsOption(
      feedback: true,
      retry: true,
      share: true,
      shareActions: ShareActionsOption(
        targets: [
          ShareTargetOption(
            id: 'copy',
            label: 'Copy to clipboard',
            type: ShareTargetType.copy,
          ),
          ShareTargetOption(
            id: 'crm',
            label: 'Send to CRM',
            description: 'Create a follow-up task',
            toast: 'Pushed to CRM.',
          ),
        ],
      ),
    ),
    composer: ComposerOption(
      placeholder: 'Ask me anything…',
      attachments: const ComposerAttachmentOption(
        enabled: true,
        maxCount: 6,
        maxSize: 25 * 1024 * 1024,
        accept: {
          'application/pdf': ['.pdf'],
          'image/*': ['.png', '.jpg', '.jpeg'],
        },
      ),
      tools: const [
        ToolOption(
          id: 'browser',
          label: 'Browser',
          description: 'Search the live web',
          placeholderOverride: 'Search for…',
          pinned: true,
        ),
      ],
      models: const [
        ModelOption(
          id: 'gpt-4o',
          label: 'GPT-4o',
          defaultSelected: true,
        ),
        ModelOption(
          id: 'gpt-4o-mini',
          label: 'GPT-4o mini',
          description: 'Faster, lower cost',
        ),
      ],
    ),
    disclaimer: const DisclaimerOption(
      text: 'Responses may be inaccurate. Verify critical information.',
      highContrast: true,
    ),
    entities: EntitiesOption(
      onTagSearch: searchEntities,
      onClick: (entity) => analytics.track('Entity clicked', entity.data),
      onRequestPreview: loadEntityPreview,
    ),
    widgets: WidgetsOption(
      onAction: (action, context) async {
        if (action.type == 'open_url') {
          await launchUrl(action.payload['href'] as String);
        }
      },
    ),
    localization: LocalizationOption(
      defaultLocale: 'en',
      bundles: {
        'es': {
          'composer_add_tag': 'Añadir etiqueta',
          'history_title': 'Historial',
        },
      },
      loader: fetchRemoteBundle,
      pluralResolver: resolvePluralForm,
    ),
    localizationOverrides: const {
      'composer_placeholder': 'Type here…',
    },
    theme: const ThemeOption(
      colorScheme: ColorSchemeOption.system,
      color: ThemeColorOptions(
        accent: AccentColorOptions(primary: '#2563eb', onPrimary: '#ffffff'),
        surface: SurfaceColorOptions(tertiary: '#f5f5f5'),
      ),
      typography: ThemeTypographyOptions(
        fontFamily: 'Inter',
        monospaceFontFamily: 'JetBrains Mono',
      ),
      shapes: ThemeShapeOptions(radius: 16),
      breakpoints: ThemeBreakpointOptions(
        compact: 520,
        medium: 960,
        expanded: 1280,
      ),
      backgroundGradient: ThemeGradientOptions(
        colors: ['#111827', '#1f2937'],
        angle: 135,
      ),
      elevations: ThemeElevationOptions(
        surface: 1,
        composer: 4,
        history: 0,
        assistantBubble: 2,
        userBubble: 0,
      ),
      components: ThemeComponentOptions(
        composer: ThemeComponentStyle(
          background: '#ffffff',
          radius: 20,
          elevation: 2,
        ),
      ),
    ),
    header: HeaderOption(
      enabled: true,
      title: const HeaderTitleOption(text: 'Coach'),
      leftAction: HeaderActionOption(
        icon: HeaderIcons.menu,
        onClick: () => scaffoldKey.currentState?.openDrawer(),
      ),
      rightAction: HeaderActionOption(
        icon: HeaderIcons.lightMode,
        onClick: toggleTheme,
      ),
    ),
    onClientTool: (invocation) async {
      final data = await resolveClientTool(invocation);
      return ClientToolSuccessResult(data: data);
    },
    onLog: (name, data) => logger.debug('[chatkit] $name $data'),
  ),
);
```

Everything shown above is optional beyond the `api` configuration—you can start
with a minimal set and add features progressively.

## Understanding `ChatKitOptions`

Each option mirrors the JS SDK. The points below call out integration details
and parity expectations:

- **`history`** — toggles the start pane, rename/delete menu, and history fetches.
  Threads are loaded lazily with infinite scroll (Recent, Archived, Shared).
- **`startScreen`** — controls the greeting and suggested prompts used when no
  active thread is selected.
- **`threadItemActions`** — enables feedback (thumbs up/down), retry, share, and
  customised share targets with optional descriptions, icons, and toasts. When
  `share` is `true`, you can also invoke `controller.shareItem(itemId)` to emit
  a `chatkit.message.share` event with the item payload.
- **`shareActions`** — extend the share modal with custom targets. Use
  `ShareActionsOption.onSelectTarget` to perform a side-effect when a target is
  chosen and provide per-target confirmation toasts via `ShareTargetOption.toast`
  or global fallbacks (`copyToast`, `systemToast`, `defaultToast`).
- **`composer`** — configures the input placeholder, attachment caps, MIME
  filters, tool tray ordering, and model picker defaults. Tool `placeholder`
  overrides match the JS behaviour by swapping the composer prompt while the
  tool is active.
- **`disclaimer`** — injects a dismissible banner at the bottom of the thread,
  matching JS styling. Set `highContrast` to ensure accessibility on busy
  backgrounds.
- **`entities`** — wires the inline tag search, click, and preview callbacks.
  Autocomplete suggestions appear as soon as `onTagSearch` returns results.
- **`widgets`** — surfaces widget-level actions (`widgets.onAction`) whenever
  a DSL element triggers an `action`. Return a future to keep the spinner visible
  while performing async work.
- **`localization`** — registers additional bundles and optionally lazy-loads
  locales on demand. `loader` results are cached and re-used by
  `chatkit_flutter`. `localizationOverrides` is a simple key→string map useful
  for one-off changes.
- **`theme`** — accepts either `ThemeOption` for the full token surface or the
  string presets `'light'`, `'dark'`, `'system'`. Colors should be supplied as
  hex strings (`#rrggbb`).
- **`header`** — shows a top app bar with configurable title and icon buttons.
  The icon values align with the JS `HeaderIcons` registry.
- **`initialThread`** — automatically loads a specific thread when the view
  mounts.
- **`onClientTool`** — handles server-initiated client tool invocations. See
  the section on client tools below for result formats.
- **`locale`** — forwarded as `Accept-Language` so the backend can respond with
  matching translations; the controller also uses it to resolve fallback bundles.

## Working with `chatkit_core`

`chatkit_core` exposes the full controller API for headless usage, automated
tests, or custom UIs.

### Key controller methods

| Method | Purpose |
| --- | --- |
| `focusComposer()` | Emits `chatkit.composer.focus` for UI layers to focus the input. |
| `setThreadId(String? id)` | Load a thread, clear the current session, or reset to the start screen when `null`. |
| `sendUserMessage({text, reply, attachments, newThread, metadata, tags})` | Sends a user message. Tags default to the composer state, attachments can be raw maps or `ChatKitAttachment`. |
| `setComposerValue({text, tags, attachments, toolId, modelId})` | Mutate the composer state programmatically. |
| `fetchUpdates()` | Pull fresh deltas when the stream is idle (used after reconnects). |
| `listThreads({limit, cursor, filter})` | Returns a `Page<ThreadMetadata>` for history panes. |
| `deleteThread(threadId)` / `renameThread(threadId, title)` | Manage history entries. |
| `retryAfterItem(threadId, itemId)` | Replays the assistant response after a failure. |
| `submitFeedback(threadId, itemId, value, [metadata])` | Sends thumbs up/down feedback, mirroring JS semantics. |
| `sendCustomAction(action, {itemId})` / `sendAction(...)` | Dispatches widget or assistant actions back to the server. |
| `shareItem(itemId)` | Emits a `ChatKitShareEvent` containing the item content. |
| `registerAttachment(...)` | Handles upload strategy negotiation and returns a `ChatKitAttachment`. |
| `handleAppBackgrounded()` / `handleAppForegrounded({forceRefresh})` | Coordinate with app lifecycle; automatically cancels/retries the stream. |
| `dispose()` | Cancel timers, active streams, and close the event controller. |

All controller methods perform guard checks to ensure no concurrent streaming
request is active. If violated, a `ChatKitBusyException` or
`ChatKitStreamingInProgressException` is thrown—catch these in testing or ensure
the UI disables buttons while streaming.

### Event stream

Listen to `controller.events` to mirror JS `controller.on(...)` callbacks. The
event types shipped match the official SDK:

- `chatkit.thread.change` (`ChatKitThreadChangeEvent`) — active thread updates.
- `chatkit.thread.load.start` / `chatkit.thread.load.end` — history fetching
  progress, useful for showing skeletons.
- `chatkit.response.start` / `chatkit.response.end` — assistant streaming
  lifecycle; payload includes the `ThreadItem`.
- `chatkit.composer.change` — emitted whenever composer state mutates (text,
  tags, attachments, tool/model selection).
- `chatkit.composer.focus` — see `focusComposer`.
- `chatkit.composer.availability` — indicates whether the composer is enabled,
  with optional `retryAfter`.
- `chatkit.auth.expired` — fired when hosted credentials lapse.
- `chatkit.error` — high-level errors surfaced to the UI, with `allowRetry`
  when a retry button should be shown.
- `chatkit.notice` — informational, warning, or error banners.
- `chatkit.message.share` — share payload for an item; `chatkit_flutter` uses
  this to open the share sheet.
- `chatkit.log` — structured diagnostics. Pair with `ChatKitOptions.onLog`
  for centralized logging.
- `chatkit.thread.*` (raw stream events) — wrapped in `ChatKitThreadEvent`.

Because `chatkit_core` maintains an offline queue, user messages sent while the
transport is down are retained and retried with exponential backoff governed by
`transport.initialBackoff`/`maxBackoff`. Heartbeat detection honours server
keep-alive intervals; backgrounding the app cancels the stream and clears timers.

### Client tools

When the backend invokes a client tool, your handler receives a
`ChatKitClientToolInvocation`:

```dart
controller.options.onClientTool = (invocation) async {
  if (invocation.name == 'get_calendar_events') {
    final events = await calendarApi.fetch(
      start: invocation.params['start'] as String,
      end: invocation.params['end'] as String,
    );
    return ClientToolSuccessResult(data: {'events': events});
  }
  return ClientToolErrorResult(message: 'Unknown tool.');
};
```

Handlers may return:

- `ClientToolSuccessResult(data: {...})`
- `ClientToolErrorResult(message: ..., details: {...})`
- A raw `Map<String, Object?>` (interpreted as success)
- `null` (interpreted as success with an empty payload)

Any other return type throws an argument error.

### Attachments

`registerAttachment` negotiates uploads and returns the attachment metadata to
pass into `sendUserMessage`. Progress callbacks run on both direct and two-phase
flows. Cancel uploads by returning `true` from `isCancelled`. All emitted log
events start with `attachments.*` for easier filtering.

### Thread utilities

- Programmatically switch threads with `setThreadId`, optionally supply
  `newThread: true` in `sendUserMessage` to start a fresh thread.
- Use `listThreads` to implement custom history pickers or background archiving.
- Call `fetchUpdates` after app resume or long idle periods to sync server state.

## Rendering with `chatkit_flutter`

`chatkit_flutter` provides a native, themable UI that mirrors the JS layouts.
Embed `ChatKitView` anywhere in your widget tree:

```dart
class CoachScreen extends StatefulWidget {
  const CoachScreen({super.key});

  @override
  State<CoachScreen> createState() => _CoachScreenState();
}

class _CoachScreenState extends State<CoachScreen> {
  late final ChatKitController controller;

  @override
  void initState() {
    super.initState();
    controller = ChatKitController(buildOptions());
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      drawer: const AppDrawer(),
      body: SafeArea(
        child: ChatKitView(controller: controller),
      ),
    );
  }
}
```

### UI features provided out of the box

- **History panel** — Recent, Archived, and Shared sections with search, infinite
  scrolling, rename/delete, and pinned thread indicators. Controlled by
  `HistoryOption`.
- **Start screen** — Greeting, iconified prompt suggestions, and dynamic banner
  drawing from `StartScreenOption` and `DisclaimerOption`.
- **Composer** — Inline tag suggestions (`@`), chip keyboard navigation,
  tool/model selectors, attachment picker with drag-and-drop (desktop/iPad),
  upload progress, cancel/retry affordances, and inline retry bubbles.
- **Entity tagging** — Reusable chips with previews, click handlers, and
  keyboard shortcuts mirroring chatkit-js behaviour.
- **Widgets renderer** — Cards, stacks, tables, forms, transitions, charts,
  wizard flows, metadata, quick replies, status banners, overlays, and share
  cards are all rendered natively. Golden tests ensure parity.
- **Share modal** — Copy to clipboard, system share sheet, or custom targets
  defined in `ThreadItemActionsOption.shareActions`.
- **Hosted-mode resilience** — Automatic composer disabling, auth banners, rate
  limit notices, and stale-client prompts driven by `HostedHooksOption`.
- **Localization** — `LocalizationOption.loader` is invoked on-demand so you can
  fetch remote bundles. `ChatKitView` caches responses and respects
  `localization.defaultLocale`.
- **Dynamic theming** — Accent/gray/surface tokens, typography, shape, gradient,
  elevation, and per-component overrides are applied live. Set
  `ThemeOption.colorScheme` to `ColorSchemeOption.system` to follow platform
  brightness.
- **Accessibility** — Semantic labels from the JS SDK are mirrored; high
  contrast disclaimers and focus management (via `focusComposer`) are built in.
- **Lifecycle integration** — The view implements `WidgetsBindingObserver` and
  forwards foreground/background events to the controller, so hosted banners and
  offline queue work automatically.

### Handling widget actions

Use `WidgetsOption.onAction` to intercept DSL actions:

```dart
WidgetsOption(
  onAction: (action, context) async {
    switch (action.type) {
      case 'open_url':
        await launchUrl(action.payload['href'] as String);
        break;
      case 'handoff':
        await crm.createTicket(context.id, action.payload);
        break;
      default:
        debugPrint('Unhandled widget action: ${action.type}');
    }
  },
),
```

Because the handler may run on the UI thread, keep long-running tasks async.

### Entity previews

When `EntitiesOption.onRequestPreview` returns an `EntityPreview`, the Flutter
layer presents it in the same modal layout as chatkit-js. Return `null` to fall
back to the default preview card.

### Custom headers and layout

If you enable `HeaderOption`, ensure that any referenced icons come from
`HeaderIcons`. For fully bespoke layouts, wrap `ChatKitView` in your own
Scaffold, navigation rail, or responsive shell—the widget has no layout
constraints besides filling the available space.

## Testing and verification

- Run the core suite: `dart test packages/chatkit_core`
- Run Flutter UI tests: `flutter test packages/chatkit_flutter`
- Update widget goldens when UI changes:\
  `flutter test packages/chatkit_flutter/test/golden/widget_dsl_golden_test.dart --update-goldens`
- Static analysis: `dart analyze`

The example app (`packages/examples/coach_demo`) demonstrates a full integration.
Run it with:

```bash
flutter pub get
flutter run
```

Point the demo at your backend by editing `lib/main.dart`.

## Troubleshooting & diagnostics

- **Streaming stalls** — Inspect `chatkit.log` events with the `transport.*`
  prefix; they include retry hints, SSE heartbeat timing, and cancellation
  reasons.
- **Auth failures** — Hosted deployments raise `chatkit.auth.expired` and trigger
  `HostedHooksOption.onAuthExpired`. Refresh your tokens and call
  `handleAppForegrounded(forceRefresh: true)` to resume the stream.
- **Attachment uploads** — Listen for `attachments.upload.*` log events and
  ensure your backend returns the same JSON schema as chatkit-js. When using
  direct uploads, confirm CORS headers allow the browser-style PUT.
- **Entity search** — Debounce your API calls on the server; the controller waits
  for the promise to resolve before showing suggestions.
- **Custom actions** — `chatkit_flutter` will optimistically disable buttons
  while `sendCustomAction` is in flight. Handle rejected promises on the server
  to show `chatkit.notice` messages.

## Resources

- [chatkit-js documentation](https://openai.github.io/chatkit-js/)
- [`docs/parity_matrix.md`](parity_matrix.md) — JS ↔ Dart coverage status.
- [`docs/usage_guides.md`](usage_guides.md) — Theming, localization, hosted mode.
- [`packages/examples/coach_demo`](../packages/examples/coach_demo) — runnable sample.

With the pieces above you can replicate the full chatkit-js experience in Dart
and Flutter, while keeping parity across transport, UI, and extension points.
</file>

<file path="packages/chatkit_core/lib/src/actions/client_tools.dart">
import 'dart:async';

/// Describes an invocation of a client tool originating from the server.
class ChatKitClientToolInvocation {
  const ChatKitClientToolInvocation({
    required this.name,
    required this.params,
    required this.threadId,
    required this.invocationId,
  });

  final String name;
  final Map<String, Object?> params;
  final String threadId;
  final String invocationId;
}

typedef ChatKitClientToolHandler = FutureOr<Map<String, Object?>> Function(
  ChatKitClientToolInvocation invocation,
);

/// A payload returned back to the server indicating the client tool failed.
class ClientToolErrorResult implements Exception {
  ClientToolErrorResult({
    required this.message,
    this.details,
  });

  final String message;
  final Map<String, Object?>? details;

  Map<String, Object?> toJson() => {
        'type': 'error',
        'message': message,
        if (details != null) 'details': details,
      };
}

/// A payload returned back to the server when the client tool succeeds.
class ClientToolSuccessResult {
  ClientToolSuccessResult({
    required this.data,
  });

  final Map<String, Object?> data;

  Map<String, Object?> toJson() => {
        'type': 'success',
        'data': data,
      };
}

/// Converts the handler result into a canonical map for transmission.
Map<String, Object?> normalizeClientToolResult(Object? result) {
  if (result == null) {
    return const {'type': 'success', 'data': {}};
  }
  if (result is ClientToolSuccessResult) {
    return result.toJson();
  }
  if (result is ClientToolErrorResult) {
    return result.toJson();
  }
  if (result is Map<String, Object?>) {
    return {
      'type': 'success',
      'data': result,
    };
  }
  throw ArgumentError(
    'Client tool handlers must return a Map, ClientToolSuccessResult, or '
    'ClientToolErrorResult. Received ${result.runtimeType}.',
  );
}
</file>

<file path="packages/chatkit_core/lib/src/events/events.dart">
import 'package:meta/meta.dart';

import '../models/composer_state.dart';
import '../models/response.dart';
import '../models/thread.dart';

@immutable
sealed class ChatKitEvent {
  const ChatKitEvent(this.type);

  final String type;
}

class ChatKitThreadChangeEvent extends ChatKitEvent {
  ChatKitThreadChangeEvent({
    required this.threadId,
    this.thread,
  }) : super('chatkit.thread.change');

  final String? threadId;
  final Thread? thread;
}

class ChatKitThreadLoadStartEvent extends ChatKitEvent {
  ChatKitThreadLoadStartEvent({
    required this.threadId,
  }) : super('chatkit.thread.load.start');

  final String threadId;
}

class ChatKitThreadLoadEndEvent extends ChatKitEvent {
  ChatKitThreadLoadEndEvent({
    required this.threadId,
  }) : super('chatkit.thread.load.end');

  final String threadId;
}

class ChatKitResponseStartEvent extends ChatKitEvent {
  ChatKitResponseStartEvent({
    required this.threadId,
    required this.item,
  }) : super('chatkit.response.start');

  final String threadId;
  final ThreadItem item;
}

class ChatKitResponseEndEvent extends ChatKitEvent {
  ChatKitResponseEndEvent({
    required this.threadId,
    required this.item,
  }) : super('chatkit.response.end');

  final String threadId;
  final ThreadItem item;
}

class ChatKitErrorEvent extends ChatKitEvent {
  ChatKitErrorEvent({
    required this.error,
    this.code,
    this.allowRetry = false,
  }) : super('chatkit.error');

  final String? code;
  final String? error;
  final bool allowRetry;
}

class ChatKitLogEvent extends ChatKitEvent {
  ChatKitLogEvent({
    required this.name,
    this.data = const {},
  }) : super('chatkit.log');

  final String name;
  final Map<String, Object?> data;
}

class ChatKitThreadEvent extends ChatKitEvent {
  ChatKitThreadEvent({
    required this.streamEvent,
  }) : super(streamEvent.type);

  final ThreadStreamEvent streamEvent;
}

class ChatKitComposerFocusEvent extends ChatKitEvent {
  const ChatKitComposerFocusEvent() : super('chatkit.composer.focus');
}

class ChatKitShareEvent extends ChatKitEvent {
  ChatKitShareEvent({
    required this.threadId,
    required this.itemId,
    required this.content,
  }) : super('chatkit.message.share');

  final String threadId;
  final String itemId;
  final List<Map<String, Object?>> content;
}

class ChatKitAuthExpiredEvent extends ChatKitEvent {
  const ChatKitAuthExpiredEvent() : super('chatkit.auth.expired');
}

class ChatKitComposerUpdatedEvent extends ChatKitEvent {
  ChatKitComposerUpdatedEvent({
    required this.state,
  }) : super('chatkit.composer.change');

  final ChatComposerState state;
}

enum ChatKitNoticeLevel { info, warning, error }

class ChatKitNoticeEvent extends ChatKitEvent {
  ChatKitNoticeEvent({
    required this.message,
    this.title,
    this.code,
    this.level = ChatKitNoticeLevel.info,
    this.retryAfter,
  }) : super('chatkit.notice');

  final String message;
  final String? title;
  final String? code;
  final ChatKitNoticeLevel level;
  final Duration? retryAfter;
}

class ChatKitComposerAvailabilityEvent extends ChatKitEvent {
  const ChatKitComposerAvailabilityEvent({
    required this.available,
    this.reason,
    this.message,
    this.retryAfter,
  }) : super('chatkit.composer.availability');

  final bool available;
  final String? reason;
  final String? message;
  final Duration? retryAfter;
}
</file>

<file path="packages/chatkit_core/lib/src/models/composer_state.dart">
import 'package:meta/meta.dart';

import 'attachments.dart';
import 'entities.dart';

@immutable
class ChatComposerState {
  const ChatComposerState({
    this.text = '',
    this.replyToItemId,
    this.replyPreviewText,
    this.attachments = const [],
    this.tags = const [],
    this.selectedModelId,
    this.selectedToolId,
  });

  final String text;
  final String? replyToItemId;
  final String? replyPreviewText;
  final List<ChatKitAttachment> attachments;
  final List<Entity> tags;
  final String? selectedModelId;
  final String? selectedToolId;

  ChatComposerState copyWith({
    String? text,
    String? replyToItemId,
    String? replyPreviewText,
    List<ChatKitAttachment>? attachments,
    List<Entity>? tags,
    String? selectedModelId,
    String? selectedToolId,
  }) {
    return ChatComposerState(
      text: text ?? this.text,
      replyToItemId: replyToItemId ?? this.replyToItemId,
      replyPreviewText: replyPreviewText ?? this.replyPreviewText,
      attachments: attachments ?? this.attachments,
      tags: tags ?? this.tags,
      selectedModelId: selectedModelId ?? this.selectedModelId,
      selectedToolId: selectedToolId ?? this.selectedToolId,
    );
  }
}
</file>

<file path="packages/chatkit_core/lib/src/models/models.dart">
export 'thread.dart';
export 'request.dart';
export 'response.dart';
export 'widgets.dart';
export 'entities.dart';
export 'attachments.dart';
export 'composer_state.dart';
export 'page.dart';
</file>

<file path="packages/chatkit_core/lib/src/models/request.dart">
import 'package:meta/meta.dart';

import '../utils/json.dart';
import 'attachments.dart';

@immutable
class ChatKitRequest {
  const ChatKitRequest({
    required this.type,
    this.params = const {},
    this.metadata = const {},
  });

  final String type;
  final Map<String, Object?> params;
  final Map<String, Object?> metadata;

  bool get isStreaming => _streamingTypes.contains(type);

  Map<String, Object?> toJson() => {
        'type': type,
        if (params.isNotEmpty) 'params': params,
        if (metadata.isNotEmpty) 'metadata': metadata,
      };

  static const Set<String> _streamingTypes = {
    'threads.create',
    'threads.add_user_message',
    'threads.add_client_tool_output',
    'threads.retry_after_item',
    'threads.custom_action',
  };
}

ChatKitRequest threadsCreate({
  required UserMessageInput input,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.create',
    params: {'input': input.toJson()},
    metadata: metadata,
  );
}

ChatKitRequest threadsAddUserMessage({
  required String threadId,
  required UserMessageInput input,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.add_user_message',
    params: {
      'thread_id': threadId,
      'input': input.toJson(),
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsAddClientToolOutput({
  required String threadId,
  required Map<String, Object?> result,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.add_client_tool_output',
    params: {
      'thread_id': threadId,
      'result': result,
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsRetryAfterItem({
  required String threadId,
  required String itemId,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.retry_after_item',
    params: {
      'thread_id': threadId,
      'item_id': itemId,
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsCustomAction({
  required String threadId,
  required ChatKitAction action,
  String? itemId,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.custom_action',
    params: {
      'thread_id': threadId,
      if (itemId != null) 'item_id': itemId,
      'action': action.toJson(),
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsGetById({
  required String threadId,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.get_by_id',
    params: {
      'thread_id': threadId,
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsList({
  int? limit,
  String? after,
  String? order,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.list',
    params: {
      if (limit != null) 'limit': limit,
      if (after != null) 'after': after,
      if (order != null) 'order': order,
    },
    metadata: metadata,
  );
}

ChatKitRequest itemsList({
  required String threadId,
  int? limit,
  String? after,
  String? order,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'items.list',
    params: {
      'thread_id': threadId,
      if (limit != null) 'limit': limit,
      if (after != null) 'after': after,
      if (order != null) 'order': order,
    },
    metadata: metadata,
  );
}

ChatKitRequest attachmentsCreate({
  required String name,
  required int size,
  required String mimeType,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'attachments.create',
    params: {
      'name': name,
      'size': size,
      'mime_type': mimeType,
    },
    metadata: metadata,
  );
}

ChatKitRequest attachmentsDelete({
  required String attachmentId,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'attachments.delete',
    params: {
      'attachment_id': attachmentId,
    },
    metadata: metadata,
  );
}

ChatKitRequest itemsFeedback({
  required String threadId,
  required List<String> itemIds,
  required String kind,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'items.feedback',
    params: {
      'thread_id': threadId,
      'item_ids': itemIds,
      'kind': kind,
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsUpdate({
  required String threadId,
  required Map<String, Object?> updates,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.update',
    params: {
      'thread_id': threadId,
      ...updates,
    },
    metadata: metadata,
  );
}

ChatKitRequest threadsDelete({
  required String threadId,
  Map<String, Object?> metadata = const {},
}) {
  return ChatKitRequest(
    type: 'threads.delete',
    params: {
      'thread_id': threadId,
    },
    metadata: metadata,
  );
}

@immutable
class UserMessageInput {
  const UserMessageInput({
    required this.content,
    this.attachmentIds = const [],
    this.quotedText,
    this.inferenceOptions,
  });

  final List<UserMessageContent> content;
  final List<String> attachmentIds;
  final String? quotedText;
  final InferenceOptions? inferenceOptions;

  Map<String, Object?> toJson() => {
        'content': content.map((value) => value.toJson()).toList(),
        'attachments': attachmentIds,
        if (quotedText != null) 'quoted_text': quotedText,
        'inference_options': inferenceOptions?.toJson(),
      };
}

@immutable
sealed class UserMessageContent {
  const UserMessageContent();

  String get type;
  Map<String, Object?> toJson();

  factory UserMessageContent.text(String value) = UserMessageTextContent;

  factory UserMessageContent.tag({
    required String id,
    required String text,
    Map<String, Object?> data,
    bool interactive,
  }) = UserMessageTagContent;
}

class UserMessageTextContent extends UserMessageContent {
  const UserMessageTextContent(this.text);

  final String text;

  @override
  String get type => 'input_text';

  @override
  Map<String, Object?> toJson() => {
        'type': type,
        'text': text,
      };
}

class UserMessageTagContent extends UserMessageContent {
  const UserMessageTagContent({
    required this.id,
    required this.text,
    this.data = const {},
    this.interactive = false,
  });

  final String id;
  final String text;
  final Map<String, Object?> data;
  final bool interactive;

  @override
  String get type => 'input_tag';

  @override
  Map<String, Object?> toJson() => {
        'type': type,
        'id': id,
        'text': text,
        if (data.isNotEmpty) 'data': data,
        if (interactive) 'interactive': interactive,
      };
}

@immutable
class InferenceOptions {
  const InferenceOptions({
    this.toolChoice,
    this.model,
  });

  final ToolChoice? toolChoice;
  final String? model;

  Map<String, Object?> toJson() => {
        if (toolChoice != null) 'tool_choice': toolChoice!.toJson(),
        if (model != null) 'model': model,
      };
}

@immutable
class ToolChoice {
  const ToolChoice({
    required this.id,
  });

  final String id;

  Map<String, Object?> toJson() => {
        'id': id,
      };
}

@immutable
class ChatKitAction {
  const ChatKitAction({
    required this.type,
    required this.payload,
    this.handler,
    this.loadingBehavior,
  });

  final String type;
  final Map<String, Object?> payload;
  final String? handler;
  final String? loadingBehavior;

  Map<String, Object?> toJson() => {
        'type': type,
        'payload': payload,
        if (handler != null) 'handler': handler,
        if (loadingBehavior != null) 'loadingBehavior': loadingBehavior,
      };

  factory ChatKitAction.fromJson(Map<String, Object?> json) => ChatKitAction(
        type: json['type'] as String,
        payload: castMap(json['payload']),
        handler: json['handler'] as String?,
        loadingBehavior: json['loadingBehavior'] as String?,
      );
}

List<String> attachmentIdsFrom(
  Iterable<ChatKitAttachment> attachments,
) =>
    attachments.map((attachment) => attachment.id).toList(growable: false);
</file>

<file path="packages/chatkit_core/lib/src/models/response.dart">
import 'package:meta/meta.dart';

import '../utils/json.dart';
import 'thread.dart';

@immutable
sealed class ThreadStreamEvent {
  const ThreadStreamEvent(this.type);

  final String type;

  factory ThreadStreamEvent.fromJson(Map<String, Object?> json) {
    final type = json['type'] as String? ?? '';
    switch (type) {
      case 'thread.created':
        return ThreadCreatedEvent(
          thread: Thread.fromJson(castMap(json['thread'])),
        );
      case 'thread.updated':
        return ThreadUpdatedEvent(
          thread: Thread.fromJson(castMap(json['thread'])),
        );
      case 'thread.item.added':
        return ThreadItemAddedEvent(
          item: ThreadItem.fromJson(castMap(json['item'])),
        );
      case 'thread.item.done':
        return ThreadItemDoneEvent(
          item: ThreadItem.fromJson(castMap(json['item'])),
        );
      case 'thread.item.updated':
        return ThreadItemUpdatedEvent(
          itemId: json['item_id'] as String,
          update: castMap(json['update']),
        );
      case 'thread.item.removed':
        return ThreadItemRemovedEvent(
          itemId: json['item_id'] as String,
        );
      case 'thread.item.replaced':
        return ThreadItemReplacedEvent(
          item: ThreadItem.fromJson(castMap(json['item'])),
        );
      case 'progress_update':
        return ProgressUpdateEvent(
          icon: json['icon'] as String?,
          text: json['text'] as String? ?? '',
        );
      case 'error':
        return ErrorEvent(
          code: json['code'] as String? ?? 'custom',
          message: json['message'] as String?,
          allowRetry: json['allow_retry'] as bool? ?? false,
        );
      case 'notice':
        return NoticeEvent(
          level: json['level'] as String? ?? 'info',
          message: json['message'] as String? ?? '',
          title: json['title'] as String?,
          code: json['code'] as String?,
          data: castMap(json['data']),
        );
      default:
        return UnknownStreamEvent(raw: json);
    }
  }
}

class ThreadCreatedEvent extends ThreadStreamEvent {
  ThreadCreatedEvent({
    required this.thread,
  }) : super('thread.created');

  final Thread thread;
}

class ThreadUpdatedEvent extends ThreadStreamEvent {
  ThreadUpdatedEvent({
    required this.thread,
  }) : super('thread.updated');

  final Thread thread;
}

class ThreadItemAddedEvent extends ThreadStreamEvent {
  ThreadItemAddedEvent({
    required this.item,
  }) : super('thread.item.added');

  final ThreadItem item;
}

class ThreadItemDoneEvent extends ThreadStreamEvent {
  ThreadItemDoneEvent({
    required this.item,
  }) : super('thread.item.done');

  final ThreadItem item;
}

class ThreadItemUpdatedEvent extends ThreadStreamEvent {
  ThreadItemUpdatedEvent({
    required this.itemId,
    required this.update,
  }) : super('thread.item.updated');

  final String itemId;
  final Map<String, Object?> update;
}

class ThreadItemRemovedEvent extends ThreadStreamEvent {
  ThreadItemRemovedEvent({
    required this.itemId,
  }) : super('thread.item.removed');

  final String itemId;
}

class ThreadItemReplacedEvent extends ThreadStreamEvent {
  ThreadItemReplacedEvent({
    required this.item,
  }) : super('thread.item.replaced');

  final ThreadItem item;
}

class ProgressUpdateEvent extends ThreadStreamEvent {
  ProgressUpdateEvent({
    required this.text,
    this.icon,
  }) : super('progress_update');

  final String? icon;
  final String text;
}

class ErrorEvent extends ThreadStreamEvent {
  ErrorEvent({
    required this.code,
    required this.message,
    required this.allowRetry,
  }) : super('error');

  final String code;
  final String? message;
  final bool allowRetry;
}

class NoticeEvent extends ThreadStreamEvent {
  NoticeEvent({
    required this.message,
    required this.level,
    this.title,
    this.code,
    this.data = const {},
  }) : super('notice');

  final String level;
  final String message;
  final String? title;
  final String? code;
  final Map<String, Object?> data;
}

class UnknownStreamEvent extends ThreadStreamEvent {
  UnknownStreamEvent({
    required this.raw,
  }) : super(raw['type'] as String? ?? 'unknown');

  final Map<String, Object?> raw;
}
</file>

<file path="packages/chatkit_core/lib/src/models/thread.dart">
import 'package:meta/meta.dart';

import '../utils/json.dart';
import 'attachments.dart';

@immutable
class ThreadMetadata {
  const ThreadMetadata({
    required this.id,
    this.title,
    required this.createdAt,
    required this.status,
    this.metadata = const {},
  });

  final String id;
  final String? title;
  final DateTime createdAt;
  final ThreadStatus status;
  final Map<String, Object?> metadata;

  factory ThreadMetadata.fromJson(Map<String, Object?> json) {
    return ThreadMetadata(
      id: json['id'] as String,
      title: json['title'] as String?,
      createdAt: parseDateTime(json['created_at']) ?? DateTime.now().toUtc(),
      status: ThreadStatus.fromJson(json['status']),
      metadata: castMap(json['metadata']),
    );
  }

  Map<String, Object?> toJson() => {
        'id': id,
        if (title != null) 'title': title,
        'created_at': createdAt.toIso8601String(),
        'status': status.toJson(),
        if (metadata.isNotEmpty) 'metadata': metadata,
      };
}

@immutable
class ThreadStatus {
  const ThreadStatus._(this.type, {this.reason});

  factory ThreadStatus.fromJson(Object? value) {
    final map = castMap(value);
    final type = map['type'] as String? ?? 'active';
    return ThreadStatus._(type, reason: map['reason'] as String?);
  }

  final String type;
  final String? reason;

  Map<String, Object?> toJson() => {
        'type': type,
        if (reason != null) 'reason': reason,
      };

  bool get isClosed => type == 'closed';
  bool get isLocked => type == 'locked';
  bool get isActive => type == 'active';
}

@immutable
class ThreadItem {
  const ThreadItem({
    required this.id,
    required this.threadId,
    required this.createdAt,
    required this.type,
    this.role,
    this.content = const [],
    this.attachments = const [],
    this.metadata = const {},
    this.raw = const {},
  });

  final String id;
  final String threadId;
  final DateTime createdAt;
  final String type;
  final String? role;
  final List<Map<String, Object?>> content;
  final List<ChatKitAttachment> attachments;
  final Map<String, Object?> metadata;
  final Map<String, Object?> raw;

  factory ThreadItem.fromJson(Map<String, Object?> json) {
    final attachments = <ChatKitAttachment>[];
    final rawAttachments = json['attachments'];
    if (rawAttachments is List) {
      for (final attachment in rawAttachments) {
        attachments.add(ChatKitAttachment.fromJson(castMap(attachment)));
      }
    }

    return ThreadItem(
      id: json['id'] as String,
      threadId: json['thread_id'] as String,
      createdAt: parseDateTime(json['created_at']) ?? DateTime.now().toUtc(),
      type: json['type'] as String? ?? 'unknown',
      role: json['role'] as String?,
      content: castListOfMaps(json['content']),
      attachments: attachments,
      metadata: castMap(json['metadata']),
      raw: Map<String, Object?>.from(json),
    );
  }

  Map<String, Object?> toJson() => {
        'id': id,
        'thread_id': threadId,
        'created_at': createdAt.toIso8601String(),
        'type': type,
        if (role != null) 'role': role,
        if (content.isNotEmpty) 'content': content,
        if (attachments.isNotEmpty)
          'attachments':
              attachments.map((attachment) => attachment.toJson()).toList(),
        if (metadata.isNotEmpty) 'metadata': metadata,
      };

  ThreadItem copyWith({
    String? id,
    String? threadId,
    DateTime? createdAt,
    String? type,
    String? role,
    List<Map<String, Object?>>? content,
    List<ChatKitAttachment>? attachments,
    Map<String, Object?>? metadata,
    Map<String, Object?>? raw,
  }) {
    final updatedContent = content ?? this.content;
    final updatedRaw = raw != null
        ? Map<String, Object?>.from(raw)
        : {
            ...this.raw,
            if (content != null) 'content': updatedContent,
            if (attachments != null)
              'attachments': attachments.map((a) => a.toJson()).toList(),
            if (metadata != null) 'metadata': metadata,
          };

    return ThreadItem(
      id: id ?? this.id,
      threadId: threadId ?? this.threadId,
      createdAt: createdAt ?? this.createdAt,
      type: type ?? this.type,
      role: role ?? this.role,
      content: updatedContent,
      attachments: attachments ?? this.attachments,
      metadata: metadata ?? this.metadata,
      raw: updatedRaw,
    );
  }
}

@immutable
class Thread {
  const Thread({
    required this.metadata,
    this.items = const [],
    this.after,
    this.hasMore = false,
  });

  final ThreadMetadata metadata;
  final List<ThreadItem> items;
  final String? after;
  final bool hasMore;

  factory Thread.fromJson(Map<String, Object?> json) {
    return Thread(
      metadata: ThreadMetadata.fromJson(json),
      items: (castMap(json['items'])['data'] as List?)
              ?.map((item) => ThreadItem.fromJson(castMap(item)))
              .toList(growable: false) ??
          const [],
      after: castMap(json['items'])['after'] as String?,
      hasMore: castMap(json['items'])['has_more'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() => {
        ...metadata.toJson(),
        'items': {
          'data': items.map((item) => item.toJson()).toList(),
          'after': after,
          'has_more': hasMore,
        },
      };
}
</file>

<file path="packages/chatkit_core/lib/src/utils/thread_item_mutations.dart">
import '../models/thread.dart';
import 'json.dart';

ThreadItem applyThreadItemUpdate(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final type = update['type'] as String? ?? '';
  switch (type) {
    case 'assistant_message.content_part.added':
      return _applyAssistantContentAdded(item, update);
    case 'assistant_message.content_part.text_delta':
      return _applyAssistantTextDelta(item, update);
    case 'assistant_message.content_part.annotation_added':
      return _applyAssistantAnnotationAdded(item, update);
    case 'assistant_message.content_part.done':
      return _applyAssistantContentDone(item, update);
    case 'widget.streaming_text.value_delta':
      return _applyWidgetStreamingDelta(item, update);
    case 'widget.component.updated':
      return _applyWidgetComponentUpdated(item, update);
    case 'widget.root.updated':
      return _applyWidgetRootUpdated(item, update);
    case 'workflow.task.added':
      return _applyWorkflowTaskAdded(item, update);
    case 'workflow.task.updated':
      return _applyWorkflowTaskUpdated(item, update);
    default:
      return item;
  }
}

ThreadItem _applyAssistantContentAdded(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final contentIndex = update['content_index'] as int? ?? item.content.length;
  final content = castMap(update['content']);
  final newContent = List<Map<String, Object?>>.from(item.content);
  if (contentIndex >= newContent.length) {
    newContent.add(content);
  } else {
    newContent.insert(contentIndex, content);
  }
  return item.copyWith(content: newContent);
}

ThreadItem _applyAssistantTextDelta(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final contentIndex = update['content_index'] as int? ?? 0;
  final delta = update['delta'] as String? ?? '';
  final newContent = List<Map<String, Object?>>.from(item.content);
  if (contentIndex < 0 || contentIndex >= newContent.length) {
    return item;
  }
  final entry = Map<String, Object?>.from(newContent[contentIndex]);
  final text = (entry['text'] as String? ?? '') + delta;
  entry['text'] = text;
  newContent[contentIndex] = entry;
  return item.copyWith(content: newContent);
}

ThreadItem _applyAssistantAnnotationAdded(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final contentIndex = update['content_index'] as int? ?? 0;
  final annotation = castMap(update['annotation']);
  final newContent = List<Map<String, Object?>>.from(item.content);
  if (contentIndex < 0 || contentIndex >= newContent.length) {
    return item;
  }
  final entry = Map<String, Object?>.from(newContent[contentIndex]);
  final annotations = List<Map<String, Object?>>.from(
    (entry['annotations'] as List?)?.map(castMap) ?? const [],
  );
  annotations.add(annotation);
  entry['annotations'] = annotations;
  newContent[contentIndex] = entry;
  return item.copyWith(content: newContent);
}

ThreadItem _applyAssistantContentDone(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final contentIndex = update['content_index'] as int? ?? 0;
  final content = castMap(update['content']);
  final newContent = List<Map<String, Object?>>.from(item.content);
  if (contentIndex < 0 || contentIndex >= newContent.length) {
    if (contentIndex == newContent.length) {
      newContent.add(content);
    } else {
      return item;
    }
  } else {
    newContent[contentIndex] = content;
  }
  return item.copyWith(content: newContent);
}

ThreadItem _applyWidgetStreamingDelta(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final componentId = update['component_id'] as String?;
  final delta = update['delta'] as String? ?? '';
  if (componentId == null) {
    return item;
  }
  final widget = castMap(item.raw['widget']);
  final updatedWidget =
      _updateWidgetComponent(widget, componentId, (component) {
    final newComponent = Map<String, Object?>.from(component);
    final value = (newComponent['value'] as String? ?? '') + delta;
    newComponent['value'] = value;
    if (update['done'] is bool) {
      newComponent['streaming'] = !(update['done'] as bool);
    }
    return newComponent;
  });
  return item.copyWith(raw: {
    ...item.raw,
    'widget': updatedWidget,
  });
}

ThreadItem _applyWidgetComponentUpdated(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final componentId = update['component_id'] as String?;
  if (componentId == null) {
    return item;
  }
  final component = castMap(update['component']);
  final widget = castMap(item.raw['widget']);
  final updatedWidget =
      _updateWidgetComponent(widget, componentId, (_) => component);
  return item.copyWith(raw: {
    ...item.raw,
    'widget': updatedWidget,
  });
}

ThreadItem _applyWidgetRootUpdated(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final widget = castMap(update['widget']);
  return item.copyWith(raw: {
    ...item.raw,
    'widget': widget,
  });
}

ThreadItem _applyWorkflowTaskAdded(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final taskIndex = update['task_index'] as int? ?? 0;
  final task = castMap(update['task']);
  final workflow = castMap(item.raw['workflow']);
  final tasks = List<Map<String, Object?>>.from(
    (workflow['tasks'] as List?)?.map(castMap) ?? const [],
  );
  if (taskIndex >= tasks.length) {
    tasks.add(task);
  } else {
    tasks.insert(taskIndex, task);
  }
  final newWorkflow = {
    ...workflow,
    'tasks': tasks,
  };
  return item.copyWith(raw: {
    ...item.raw,
    'workflow': newWorkflow,
  });
}

ThreadItem _applyWorkflowTaskUpdated(
  ThreadItem item,
  Map<String, Object?> update,
) {
  final taskIndex = update['task_index'] as int? ?? 0;
  final task = castMap(update['task']);
  final workflow = castMap(item.raw['workflow']);
  final tasks = List<Map<String, Object?>>.from(
    (workflow['tasks'] as List?)?.map(castMap) ?? const [],
  );
  if (taskIndex < 0 || taskIndex >= tasks.length) {
    return item;
  }
  tasks[taskIndex] = task;
  final newWorkflow = {
    ...workflow,
    'tasks': tasks,
  };
  return item.copyWith(raw: {
    ...item.raw,
    'workflow': newWorkflow,
  });
}

Map<String, Object?> _updateWidgetComponent(
  Map<String, Object?> widget,
  String componentId,
  Map<String, Object?> Function(Map<String, Object?> component) transform,
) {
  Map<String, Object?> visit(Map<String, Object?> node) {
    if (node['id'] == componentId) {
      return transform(node);
    }
    final children = node['children'];
    if (children is List) {
      final updatedChildren = <Map<String, Object?>>[];
      for (final child in children) {
        final childMap = castMap(child);
        updatedChildren.add(visit(childMap));
      }
      return {
        ...node,
        'children': updatedChildren,
      };
    }
    return node;
  }

  return visit(widget);
}
</file>

<file path="packages/chatkit_core/test/fixtures/streaming_fixture.dart">
import 'dart:convert';

/// JSON fixture that mirrors a streamed assistant response with mixed content
/// (text deltas, annotations, widget streaming updates, and a final completion).
const String streamingFixtureJson = '''
[
  {
    "type": "thread.item.added",
    "item": {
      "id": "msg_assistant",
      "thread_id": "thread_weekly",
      "created_at": "2024-06-12T17:00:00Z",
      "type": "assistant_message",
      "role": "assistant",
      "content": [],
      "attachments": [],
      "metadata": {
        "stage": "streaming"
      },
      "widget": {
        "id": "root_card",
        "type": "card",
        "size": "md",
        "padding": "lg",
        "background": "#F8FAFC",
        "children": [
          {
            "id": "header_row",
            "type": "row",
            "gap": "md",
            "align": "center",
            "justify": "space_between",
            "children": [
              {
                "id": "title_text",
                "type": "text",
                "value": "Coach recap",
                "size": "lg",
                "weight": "semibold"
              },
              {
                "id": "status_badge",
                "type": "badge",
                "label": "Live",
                "variant": "success"
              }
            ]
          },
          {
            "id": "stream_text",
            "type": "text",
            "value": "",
            "streaming": true,
            "size": "sm"
          },
          {
            "id": "cta_group",
            "type": "button.group",
            "gap": "sm",
            "children": [
              {
                "id": "primary_cta",
                "type": "button",
                "label": "Open report",
                "variant": "solid",
                "action": {
                  "type": "open_report"
                }
              },
              {
                "id": "secondary_cta",
                "type": "button",
                "label": "Dismiss",
                "variant": "ghost",
                "action": {
                  "type": "dismiss"
                }
              }
            ]
          }
        ]
      }
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "assistant_message.content_part.added",
      "content_index": 0,
      "content": {
        "type": "output_text",
        "text": "",
        "annotations": []
      }
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "assistant_message.content_part.text_delta",
      "content_index": 0,
      "delta": "Hello athlete! "
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "assistant_message.content_part.annotation_added",
      "content_index": 0,
      "annotation": {
        "type": "file_reference",
        "file_id": "file_weekly_plan",
        "text": "Weekly Plan.pdf"
      }
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "assistant_message.content_part.text_delta",
      "content_index": 0,
      "delta": "Here is your summary."
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "widget.streaming_text.value_delta",
      "component_id": "stream_text",
      "delta": "Focus: Recovery mobility\\n",
      "done": false
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "widget.streaming_text.value_delta",
      "component_id": "stream_text",
      "delta": "Next: Long run Saturday",
      "done": true
    }
  },
  {
    "type": "thread.item.updated",
    "item_id": "msg_assistant",
    "update": {
      "type": "widget.component.updated",
      "component_id": "secondary_cta",
      "component": {
        "id": "secondary_cta",
        "type": "button",
        "label": "View history",
        "variant": "outline",
        "action": {
          "type": "view_history"
        }
      }
    }
  },
  {
    "type": "progress_update",
    "icon": "check",
    "text": "Summaries compiled"
  },
  {
    "type": "thread.item.done",
    "item": {
      "id": "msg_assistant",
      "thread_id": "thread_weekly",
      "created_at": "2024-06-12T17:00:00Z",
      "type": "assistant_message",
      "role": "assistant",
      "attachments": [],
      "metadata": {
        "stage": "complete"
      },
      "content": [
        {
          "type": "output_text",
          "text": "Hello athlete! Here is your summary.",
          "annotations": [
            {
              "type": "file_reference",
              "file_id": "file_weekly_plan",
              "text": "Weekly Plan.pdf"
            }
          ]
        }
      ],
      "widget": {
        "id": "root_card",
        "type": "card",
        "size": "md",
        "padding": "lg",
        "background": "#F8FAFC",
        "children": [
          {
            "id": "header_row",
            "type": "row",
            "gap": "md",
            "align": "center",
            "justify": "space_between",
            "children": [
              {
                "id": "title_text",
                "type": "text",
                "value": "Coach recap",
                "size": "lg",
                "weight": "semibold"
              },
              {
                "id": "status_badge",
                "type": "badge",
                "label": "Live",
                "variant": "success"
              }
            ]
          },
          {
            "id": "stream_text",
            "type": "text",
            "value": "Focus: Recovery mobility\\nNext: Long run Saturday",
            "streaming": false,
            "size": "sm"
          },
          {
            "id": "cta_group",
            "type": "button.group",
            "gap": "sm",
            "children": [
              {
                "id": "primary_cta",
                "type": "button",
                "label": "Open report",
                "variant": "solid",
                "action": {
                  "type": "open_report"
                }
              },
              {
                "id": "secondary_cta",
                "type": "button",
                "label": "View history",
                "variant": "outline",
                "action": {
                  "type": "view_history"
                }
              }
            ]
          }
        ]
      }
    }
  }
]
''';

/// Returns a parsed, mutable copy of the streaming fixture events.
List<Map<String, Object?>> streamingFixtureEvents() {
  final decoded = jsonDecode(streamingFixtureJson) as List;
  return decoded
      .map(
        (entry) => Map<String, Object?>.from(
          (entry as Map).cast<String, Object?>(),
        ),
      )
      .toList(growable: false);
}

/// Produces a raw SSE payload string that includes retry hints and heartbeat
/// messages used to exercise the transport client.
String streamingFixtureAsSse() {
  final buffer = StringBuffer();
  var id = 0;
  for (final event in streamingFixtureEvents()) {
    id += 1;
    buffer.writeln('id: $id');
    buffer.writeln('event: ${event['type']}');
    buffer.writeln('data: ${jsonEncode(event)}');
    if (id == 1) {
      buffer.writeln('retry: 2500');
    }
    buffer.writeln();
  }
  buffer.writeln('event: heartbeat');
  buffer.writeln('data: ping');
  buffer.writeln();
  buffer.writeln('retry: 1500');
  buffer.writeln();
  return buffer.toString();
}

const Map<String, Object?> clientToolCallItemJson = {
  'id': 'tool_call_weather',
  'thread_id': 'thread_tool',
  'created_at': '2024-06-12T17:05:00Z',
  'type': 'client_tool_call',
  'role': 'assistant',
  'content': <Map<String, Object?>>[],
  'attachments': <Map<String, Object?>>[],
  'metadata': <String, Object?>{},
  'name': 'browser',
  'call_id': 'call_weather',
  'arguments': {
    'location': 'Valencia',
    'units': 'metric',
  },
};

List<Map<String, Object?>> clientToolFixtureEvents() {
  final added = Map<String, Object?>.from(clientToolCallItemJson);
  final done = Map<String, Object?>.from(clientToolCallItemJson)
    ..['status'] = {'type': 'completed'};
  return [
    {
      'type': 'thread.item.added',
      'item': added,
    },
    {
      'type': 'thread.item.done',
      'item': done,
    },
  ];
}

const Map<String, Object?> workflowItemJson = {
  'id': 'workflow_item',
  'thread_id': 'thread_workflow',
  'created_at': '2024-06-12T17:10:00Z',
  'type': 'assistant_message',
  'role': 'assistant',
  'content': [
    {
      'type': 'output_text',
      'text': 'Building weekly plan…',
    },
  ],
  'attachments': <Map<String, Object?>>[],
  'metadata': <String, Object?>{},
  'workflow': {
    'tasks': <Map<String, Object?>>[],
  },
};

List<Map<String, Object?>> workflowFixtureEvents() {
  return [
    {
      'type': 'thread.item.added',
      'item': Map<String, Object?>.from(workflowItemJson),
    },
    {
      'type': 'thread.item.updated',
      'item_id': 'workflow_item',
      'update': {
        'type': 'workflow.task.added',
        'task_index': 0,
        'task': {
          'id': 'task_collect_inputs',
          'title': 'Collect athlete inputs',
          'status': 'pending',
        },
      },
    },
    {
      'type': 'thread.item.updated',
      'item_id': 'workflow_item',
      'update': {
        'type': 'workflow.task.updated',
        'task_index': 0,
        'task': {
          'id': 'task_collect_inputs',
          'title': 'Collect athlete inputs',
          'status': 'complete',
          'notes': 'All questionnaires answered.',
        },
      },
    },
  ];
}
</file>

<file path="packages/chatkit_core/test/api_client_test.dart">
import 'dart:async';
import 'dart:convert';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:chatkit_core/src/api/sse_client.dart';
import 'package:http/http.dart' as http;
import 'package:http/testing.dart';
import 'package:test/test.dart';

void main() {
  group('ChatKitApiClient', () {
    test('refreshes hosted client secret once on 401 and retries request',
        () async {
      var attempts = 0;
      final observedAuthHeaders = <String>[];
      final client = MockClient((request) async {
        attempts += 1;
        observedAuthHeaders.add(request.headers['authorization'] ?? '');
        if (attempts == 1) {
          return http.Response(
            jsonEncode({
              'error': {'code': 'auth_expired'}
            }),
            401,
            headers: {'content-type': 'application/json'},
          );
        }
        return http.Response(
          jsonEncode({'ok': true}),
          200,
          headers: {'content-type': 'application/json'},
        );
      });

      var secretCalls = 0;
      final apiClient = ChatKitApiClient(
        apiConfig: HostedApiConfig(
          clientToken: 'secret-initial',
          getClientSecret: (current) async {
            secretCalls += 1;
            return 'secret-$secretCalls';
          },
        ),
        httpClient: client,
      );

      final response =
          await apiClient.send(const ChatKitRequest(type: 'noop_test'));

      expect(response, equals({'ok': true}));
      expect(attempts, 2);
      expect(secretCalls, 1);
      expect(
        observedAuthHeaders,
        equals(['Bearer secret-initial', 'Bearer secret-1']),
      );
    });

    test('attaches accept-language header when configured', () async {
      String? seenLanguage;
      final client = MockClient((request) async {
        seenLanguage = request.headers['accept-language'];
        return http.Response('{}', 200);
      });

      final apiClient = ChatKitApiClient(
        apiConfig: const CustomApiConfig(url: 'https://example.com/chat'),
        httpClient: client,
      );
      apiClient.acceptLanguage = 'fr-FR';

      await apiClient.send(const ChatKitRequest(type: 'noop_test'));

      expect(seenLanguage, 'fr-FR');
    });

    test('deduplicates streaming events by SSE id', () async {
      final received = <ProgressUpdateEvent>[];
      final sseClient = _FakeSseClient(({
        required Map<String, Object?> body,
        required SseMessageHandler onMessage,
        void Function(Object error, StackTrace stackTrace)? onError,
        void Function()? onDone,
        Duration? keepAliveTimeout,
        void Function()? onKeepAliveTimeout,
        void Function(Duration duration)? onRetrySuggested,
        Future<http.StreamedResponse> Function(http.Request request)?
            sendOverride,
      }) async {
        await onMessage(
          SseMessage(
            id: 'evt_1',
            data: jsonEncode({'type': 'progress_update', 'text': 'first'}),
          ),
        );
        await onMessage(
          SseMessage(
            id: 'evt_1',
            data: jsonEncode({'type': 'progress_update', 'text': 'ignored'}),
          ),
        );
        await onMessage(
          SseMessage(
            id: 'evt_2',
            data: jsonEncode({'type': 'progress_update', 'text': 'second'}),
          ),
        );
        onDone?.call();
      });

      final apiClient = ChatKitApiClient(
        apiConfig: const CustomApiConfig(url: 'https://example.com/chat'),
        sseClient: sseClient,
      );

      await apiClient.sendStreaming(
        const ChatKitRequest(type: 'threads.create'),
        onEvent: (event) {
          if (event is ProgressUpdateEvent) {
            received.add(event);
          }
        },
      );

      expect(received.length, 2);
      expect(received.first.text, 'first');
      expect(received.last.text, 'second');
    });
  });
}

class _FakeSseClient extends SseClient {
  _FakeSseClient(
    this.handler,
  ) : super(httpClient: http.Client());

  final Future<void> Function({
    required Map<String, Object?> body,
    required SseMessageHandler onMessage,
    void Function(Object error, StackTrace stackTrace)? onError,
    void Function()? onDone,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Future<http.StreamedResponse> Function(http.Request request)? sendOverride,
  }) handler;

  @override
  Future<void> post(
    Uri uri, {
    required Map<String, Object?> body,
    Map<String, String>? headers,
    required SseMessageHandler onMessage,
    void Function(Object error, StackTrace stackTrace)? onError,
    void Function()? onDone,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Future<http.StreamedResponse> Function(http.Request request)? sendOverride,
  }) {
    return handler(
      body: body,
      onMessage: onMessage,
      onError: onError,
      onDone: onDone,
      keepAliveTimeout: keepAliveTimeout,
      onKeepAliveTimeout: onKeepAliveTimeout,
      onRetrySuggested: onRetrySuggested,
      sendOverride: sendOverride,
    );
  }
}
</file>

<file path="packages/chatkit_core/test/attachments_upload_test.dart">
import 'dart:collection';
import 'dart:convert';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:chatkit_core/src/models/request.dart';
import 'package:chatkit_core/src/options.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

class _StubApiClient extends ChatKitApiClient {
  _StubApiClient(Queue<Map<String, Object?>> responses)
      : _responses = responses,
        super(apiConfig: const CustomApiConfig(url: 'https://chatkit.test'));

  final Queue<Map<String, Object?>> _responses;
  ChatKitRequest? lastRequest;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    lastRequest = request;
    if (_responses.isNotEmpty) {
      return _responses.removeFirst();
    }
    return const {};
  }
}

class _RecordingUploadClient extends http.BaseClient {
  _RecordingUploadClient({required this.response, this.statusCode = 200});

  final Map<String, Object?> response;
  final int statusCode;
  http.BaseRequest? lastRequest;
  Map<String, String>? recordedFields;
  Map<String, String>? recordedHeaders;
  List<int> recordedBytes = const [];

  @override
  Future<http.StreamedResponse> send(http.BaseRequest request) async {
    lastRequest = request;
    recordedHeaders = Map<String, String>.from(request.headers);
    if (request is http.MultipartRequest) {
      recordedFields = Map<String, String>.from(request.fields);
    }
    final bodyBytes = <int>[];
    await for (final chunk in request.finalize()) {
      bodyBytes.addAll(chunk);
    }
    recordedBytes = bodyBytes;
    final encoded = utf8.encode(jsonEncode(response));
    return http.StreamedResponse(
      Stream<List<int>>.fromIterable([encoded]),
      statusCode,
      headers: {'content-type': 'application/json'},
    );
  }
}

void main() {
  group('registerAttachment', () {
    test('performs two-phase upload with multipart fields', () async {
      final responses = Queue<Map<String, Object?>>.from([
        {
          'type': 'image',
          'id': 'att_123',
          'name': 'example.png',
          'mime_type': 'image/png',
          'upload_url': 'https://uploads.example.com/form',
          'upload_method': 'POST',
          'upload_fields': {'key': 'value1', 'policy': 'value2'},
          'upload_headers': {'x-extra': 'true'},
        },
      ]);
      final apiClient = _StubApiClient(responses);
      final uploadClient = _RecordingUploadClient(
        response: {
          'type': 'image',
          'id': 'att_123',
          'name': 'example.png',
          'mime_type': 'image/png',
          'upload_url': null,
        },
        statusCode: 201,
      );

      final controller = ChatKitController(
        ChatKitOptions(
          api: const CustomApiConfig(
            url: 'https://chatkit.test',
            uploadStrategy: TwoPhaseUploadStrategy(),
          ),
        ),
        apiClient: apiClient,
        uploadClient: uploadClient,
      );

      final progressTicks = <int>[];
      final attachment = await controller.registerAttachment(
        name: 'example.png',
        bytes: utf8.encode('image-bytes'),
        mimeType: 'image/png',
        onProgress: (sent, _) => progressTicks.add(sent),
      );

      expect(apiClient.lastRequest?.type, 'attachments.create');
      expect(uploadClient.lastRequest, isA<http.MultipartRequest>());
      final multipart = uploadClient.lastRequest as http.MultipartRequest;
      expect(multipart.method, 'POST');
      expect(multipart.url.toString(), 'https://uploads.example.com/form');
      expect(multipart.fields['key'], 'value1');
      expect(multipart.fields['policy'], 'value2');
      expect(multipart.headers['x-extra'], 'true');
      expect(attachment.uploadUrl, isNull);
      expect(attachment.id, 'att_123');
      expect(progressTicks, isNotEmpty);

      await controller.dispose();
    });
  });
}
</file>

<file path="packages/chatkit_core/test/sse_client_test.dart">
import 'dart:convert';
import 'dart:io';

import 'package:chatkit_core/src/api/sse_client.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

import 'fixtures/streaming_fixture.dart';

void main() {
  test('SseClient forwards retry hints and yields decoded messages', () async {
    final client = SseClient();
    final received = <SseMessage>[];
    final retryHints = <Duration>[];
    final errors = <Object>[];

    await client.post(
      Uri.parse('https://example.com/chatkit'),
      body: const <String, Object?>{},
      onMessage: (message) async {
        received.add(message);
      },
      onRetrySuggested: (duration) => retryHints.add(duration),
      onError: (error, stackTrace) {
        errors.add(error);
      },
      sendOverride: (request) async {
        final raw = streamingFixtureAsSse();
        final chunks = raw
            .split('\n')
            .map((line) => utf8.encode('$line\n'))
            .toList(growable: false);
        return http.StreamedResponse(
          Stream<List<int>>.fromIterable(chunks),
          200,
          request: request,
          headers: {
            HttpHeaders.contentTypeHeader: 'text/event-stream',
          },
        );
      },
    );

    expect(errors, isEmpty);
    expect(retryHints, isNotEmpty);
    expect(retryHints.first, const Duration(milliseconds: 2500));

    final messagesWithPayload = received
        .where((message) => message.data != null && message.data!.isNotEmpty)
        .toList();
    final fixture = streamingFixtureEvents();
    expect(messagesWithPayload.length, fixture.length);

    for (var i = 0; i < fixture.length; i++) {
      final decoded = jsonDecode(messagesWithPayload[i].data!) as Map;
      expect(decoded['type'], fixture[i]['type']);
    }
  });
}
</file>

<file path="packages/chatkit_core/pubspec.yaml">
name: chatkit_core
description: Dart port of ChatKit JS core client providing transport, models, and controller APIs.
version: 0.1.0
homepage: https://github.com/openai/chatkit-js
repository: https://github.com/diwakarmoturu/chatkit-dart
publish_to: none

environment:
  sdk: ">=3.3.0 <4.0.0"

dependencies:
  http: ^1.2.1
  meta: ^1.11.0
  collection: ^1.18.0
  json_annotation: ^4.9.0
  async: ^2.11.0

dev_dependencies:
  build_runner: ^2.4.8
  json_serializable: ^6.8.0
  test: ^1.25.2
</file>

<file path="packages/chatkit_core/README.md">
# ChatKit Core (Dart)

`chatkit_core` is a pure-Dart client that mirrors the [ChatKit JS](https://github.com/openai/chatkit-js) API surface so Flutter, Dart, and server-side apps can integrate with ChatKit-compatible backends such as `chatkit-python`.

## Features

- Streaming transport (SSE) + JSON fallbacks
- Streaming transport (SSE) + JSON fallbacks with automatic retry/backoff
- Offline queue for user messages with optimistic placeholders
- Thread lifecycle helpers (create, list, rename, delete, retry)
- Attachment registration with direct or two-phase upload flows
- Client tool dispatch and result submission
- Entity tagging, history, model/tool selection, and user composer state events
- Rich event stream carrying the same payloads as the JS SDK

## Install

Add the package to your `pubspec.yaml`:

```yaml
dependencies:
  chatkit_core:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_core
```

Run `dart pub get`.

## Quick start

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: const CustomApiConfig(
      url: 'https://your-backend/chatkit',
      domainKey: 'your-domain-key',
      uploadStrategy: const TwoPhaseUploadStrategy(),
    ),
    history: const HistoryOption(enabled: true),
    threadItemActions: const ThreadItemActionsOption(feedback: true),
    entities: EntitiesOption(
      onTagSearch: (query) async => fetchEntities(query),
    ),
  ),
);

controller.events.listen((event) {
  if (event is ChatKitResponseStartEvent) {
    // Update UI or metrics when the assistant starts streaming.
  }
});

await controller.sendUserMessage(text: 'Hello world');
```

See the [Coach Demo](../../examples/coach_demo) for a full Flutter integration.

### Localization

To register additional translation bundles or change the default fallback locale, provide the optional `localization` option:

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: const CustomApiConfig(url: 'https://your-backend/chatkit'),
    localization: const LocalizationOption(
      defaultLocale: 'en',
      bundles: {
        'es': {
          'history_title': 'Historial',
          'history_load_more': 'Cargar más',
        },
      },
    ),
  ),
);
```

You can still override individual strings at runtime via `localizationOverrides`.

## API parity

- Methods: `focusComposer`, `setThreadId`, `setComposerValue`, `sendUserMessage`, `sendCustomAction`, `fetchUpdates`, `retryAfterItem`, `submitFeedback`, `deleteThread`, `listThreads`, `renameThread`, `shareItem`, `registerAttachment`.
- Events: `chatkit.thread.change`, `chatkit.response.start`, `chatkit.response.end`, `chatkit.error`, `chatkit.log`, `chatkit.composer.change`, `chatkit.composer.focus`, `chatkit.message.share`, and raw thread stream events identical to ChatKit JS.

## Testing

```
dart test packages/chatkit_core
```

This command exercises:

- `fixtures/streaming_fixture.dart` via `streaming_fixture_test.dart` (mixed widget/text deltas).
- Transport retry/backoff semantics via `transport_retry_test.dart`.
- SSE parsing, heartbeat filtering, and retry hints via `sse_client_test.dart`.

## Documentation

- [Parity matrix](../../docs/parity_matrix.md) – JS ↔ Dart feature coverage.
- [Usage guides](../../docs/usage_guides.md) – hosted mode, localization, theming, history/entities, and attachments.
- [Widget property coverage](../../docs/widget_property_coverage.md) – per-widget property support and notes.

## License

Apache-2.0 © Diwakar Moturu
</file>

<file path="packages/chatkit_flutter/lib/src/gallery/chatkit_gallery.dart">
import 'package:chatkit_core/chatkit_core.dart';
import 'package:flutter/material.dart';

import '../theme/chatkit_theme.dart';
import '../widgets/widget_renderer.dart';

class ChatKitGallery extends StatefulWidget {
  const ChatKitGallery({
    super.key,
    this.brightness = Brightness.light,
  });

  final Brightness brightness;

  @override
  State<ChatKitGallery> createState() => _ChatKitGalleryState();
}

class _ChatKitGalleryState extends State<ChatKitGallery> {
  late final ChatKitController _controller;

  @override
  void initState() {
    super.initState();
    _controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(
          url: 'https://preview.chatkit.invalid',
        ),
        widgets: const WidgetsOption(),
        theme: ThemeOption(
          colorScheme: widget.brightness == Brightness.dark
              ? ColorSchemeOption.dark
              : ColorSchemeOption.light,
        ),
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  ThreadItem _mockItem(String id) {
    return ThreadItem(
      id: 'gallery_item_$id',
      threadId: 'gallery',
      createdAt: DateTime.utc(2024, 01, 01),
      type: 'widget',
      raw: {'id': id, 'type': 'widget'},
    );
  }

  Widget _renderer(String id, Map<String, Object?> json) {
    return ChatKitWidgetRenderer(
      key: ValueKey('gallery_$id'),
      widgetJson: json,
      controller: _controller,
      item: _mockItem(id),
    );
  }

  List<_GallerySection> _buildSections() {
    return [
      _GallerySection(
        title: 'Buttons',
        description: 'Solid, soft, outline, and ghost variants.',
        child: _renderer('buttons', {
          'type': 'button.group',
          'gap': 'sm',
          'children': [
            {'type': 'button', 'label': 'Primary', 'variant': 'solid'},
            {'type': 'button', 'label': 'Soft', 'variant': 'soft'},
            {'type': 'button', 'label': 'Outline', 'variant': 'outline'},
            {'type': 'button', 'label': 'Ghost', 'variant': 'ghost'},
            {
              'type': 'button',
              'label': 'Danger',
              'variant': 'solid',
              'tone': 'danger',
            },
          ],
        }),
      ),
      _GallerySection(
        title: 'Form Controls',
        description: 'Text fields, selects, and helper text states.',
        child: _renderer('forms', {
          'type': 'form',
          'children': [
            {
              'type': 'input',
              'name': 'project_name',
              'label': 'Project name',
              'placeholder': 'Atlas redesign',
              'iconStart': 'sparkle',
            },
            {
              'type': 'textarea',
              'name': 'notes',
              'label': 'Notes',
              'placeholder': 'Add context for collaborators…',
              'helperText': 'Visible to your workspace',
            },
            {
              'type': 'select',
              'name': 'assignee',
              'label': 'Assign to',
              'defaultValue': 'ada',
              'options': [
                {'value': 'ada', 'label': 'Ada Lovelace', 'icon': 'profile'},
                {'value': 'niko', 'label': 'Nikola Tesla', 'icon': 'agent'},
                {'value': 'grace', 'label': 'Grace Hopper', 'icon': 'write'},
              ],
            },
            {
              'type': 'select.multi',
              'name': 'tags',
              'label': 'Tags',
              'defaultValue': ['backend', 'ml'],
              'options': [
                {'value': 'backend', 'label': 'Backend'},
                {'value': 'ml', 'label': 'Machine Learning'},
                {'value': 'docs', 'label': 'Docs'},
              ],
            },
          ],
        }),
      ),
      _GallerySection(
        title: 'Card',
        description: 'Card with status, progress, and actions.',
        child: _renderer('card', {
          'type': 'card',
          'status': {'level': 'success', 'message': 'On track'},
          'children': [
            {
              'type': 'text',
              'value': 'Training plan',
              'size': 'lg',
              'weight': 'semibold',
            },
            {
              'type': 'text',
              'value': 'Week 4 check-in · Intermediate',
              'size': 'sm',
              'tone': 'subtle',
            },
            {
              'type': 'progress',
              'value': 0.72,
              'label': 'Goal completion',
            },
            {
              'type': 'button.group',
              'align': 'end',
              'children': [
                {
                  'type': 'button',
                  'label': 'Share',
                  'variant': 'outline',
                  'icon': 'share',
                },
                {
                  'type': 'button',
                  'label': 'Continue',
                  'variant': 'solid',
                  'icon': 'sparkle',
                },
              ],
            },
          ],
        }),
      ),
      _GallerySection(
        title: 'Timeline',
        description: 'Milestones with badges and meta data.',
        child: _renderer('timeline', {
          'type': 'timeline',
          'alignment': 'start',
          'items': [
            {
              'title': 'Kickoff',
              'subtitle': 'Mon · 9:00 AM',
              'badge': 'Done',
              'color': 'success',
              'children': [
                {
                  'type': 'text',
                  'value': 'Aligned on scope and success metrics.',
                  'size': 'sm',
                },
              ],
            },
            {
              'title': 'Prototype review',
              'subtitle': 'Wed · 1:30 PM',
              'badge': 'Today',
              'color': 'info',
              'children': [
                {
                  'type': 'text',
                  'value': 'Gather feedback from the design council.',
                  'size': 'sm',
                },
              ],
            },
            {
              'title': 'Launch',
              'subtitle': 'Fri · 4:00 PM',
              'badge': 'Upcoming',
              'color': 'warning',
              'children': [
                {
                  'type': 'text',
                  'value': 'Finalize release notes and roll-out plan.',
                  'size': 'sm',
                },
              ],
            },
          ],
        }),
      ),
      _GallerySection(
        title: 'Table',
        description: 'Striped table with numeric column and caption.',
        child: _renderer('table', {
          'type': 'table',
          'striped': true,
          'columns': [
            {'label': 'Plan', 'dataKey': 'plan'},
            {'label': 'Focus', 'dataKey': 'focus'},
            {'label': 'Hours', 'dataKey': 'hours', 'align': 'end'},
          ],
          'rows': [
            {
              'values': {
                'plan': 'Base phase',
                'focus': 'Aerobic foundation',
                'hours': 4.5,
              },
            },
            {
              'values': {
                'plan': 'Build',
                'focus': 'Strength & tempo',
                'hours': 6.0,
              },
            },
            {
              'values': {
                'plan': 'Peak',
                'focus': 'Race pace',
                'hours': 7.2,
              },
            },
          ],
          'caption': 'Training load by macrocycle.',
        }),
      ),
      _GallerySection(
        title: 'Activity Chart',
        description: 'Bar + line chart illustrating weekly volume.',
        child: _renderer('chart', {
          'type': 'chart',
          'height': 220,
          'datasets': [
            {
              'label': 'Completed',
              'type': 'bar',
              'data': [
                {'x': 'Mon', 'y': 3},
                {'x': 'Tue', 'y': 4},
                {'x': 'Wed', 'y': 5},
                {'x': 'Thu', 'y': 4.5},
                {'x': 'Fri', 'y': 3.5},
                {'x': 'Sat', 'y': 6},
                {'x': 'Sun', 'y': 4},
              ],
            },
            {
              'label': 'Target',
              'type': 'line',
              'data': [
                {'x': 'Mon', 'y': 4},
                {'x': 'Tue', 'y': 4},
                {'x': 'Wed', 'y': 4},
                {'x': 'Thu', 'y': 4},
                {'x': 'Fri', 'y': 4},
                {'x': 'Sat', 'y': 6},
                {'x': 'Sun', 'y': 4},
              ],
            },
          ],
        }),
      ),
      _GallerySection(
        title: 'Status & Badges',
        description: 'Inline messaging for asynchronous updates.',
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _renderer('status', {
              'type': 'status',
              'level': 'warning',
              'message': 'Model update pending approval.',
            }),
            const SizedBox(height: 12),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _renderer('badge-primary', {
                  'type': 'badge',
                  'label': 'Live',
                  'variant': 'solid',
                }),
                _renderer('badge-soft', {
                  'type': 'badge',
                  'label': 'Beta',
                  'variant': 'soft',
                }),
                _renderer('badge-outline', {
                  'type': 'badge',
                  'label': 'Feedback',
                  'variant': 'outline',
                }),
              ],
            ),
          ],
        ),
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final baseTheme = widget.brightness == Brightness.dark
        ? ThemeData(
            brightness: Brightness.dark,
            useMaterial3: false,
          )
        : ThemeData(
            brightness: Brightness.light,
            useMaterial3: false,
          );
    final themeData = ChatKitThemeData.fromOptions(
      base: baseTheme,
      option: _controller.options.resolvedTheme,
      platformBrightness: widget.brightness,
    );
    final sections = _buildSections();

    return ChatKitTheme(
      data: themeData,
      child: Theme(
        data: themeData.materialTheme,
        child: Material(
          color: themeData.palette.background,
          child: ListView.separated(
            padding: EdgeInsets.all(themeData.spacing.xl),
            itemBuilder: (context, index) => sections[index],
            separatorBuilder: (context, index) =>
                SizedBox(height: themeData.spacing.xl),
            itemCount: sections.length,
          ),
        ),
      ),
    );
  }
}

class _GallerySection extends StatelessWidget {
  const _GallerySection({
    required this.title,
    required this.child,
    this.description,
  });

  final String title;
  final String? description;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final chatTheme = ChatKitTheme.of(context);
    final spacing = chatTheme.spacing;
    final palette = chatTheme.palette;
    final radii = chatTheme.radii;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.w600,
          ),
        ),
        if (description != null && description!.isNotEmpty)
          Padding(
            padding: EdgeInsets.only(top: spacing.xs),
            child: Text(
              description!,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: palette.onSurfaceMuted,
              ),
            ),
          ),
        SizedBox(height: spacing.md),
        Material(
          color: palette.surface,
          elevation: 0,
          borderRadius: BorderRadius.circular(radii.card),
          child: Padding(
            padding: EdgeInsets.all(spacing.lg),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 520),
              child: child,
            ),
          ),
        ),
      ],
    );
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/localization/localizations.dart">
class ChatKitLocalizations {
  ChatKitLocalizations({
    required this.locale,
    required this.overrides,
    Map<String, Map<String, String>>? bundles,
    this.defaultLocale,
    this.pluralResolver,
  }) : extraBundles = Map<String, Map<String, String>>.unmodifiable({
          for (final entry in (bundles ?? {}).entries)
            _canonicalizeLocale(entry.key):
                Map<String, String>.unmodifiable(entry.value),
        });

  final String? locale;
  final Map<String, String>? overrides;
  final Map<String, Map<String, String>> extraBundles;
  final String? defaultLocale;
  final String Function(String key, num count, {Map<String, Object?> params})?
      pluralResolver;

  static const Map<String, Map<String, String>> _builtInTranslations = {
    'es': {
      'history_title': 'Historial',
      'history_search_hint': 'Buscar conversaciones',
      'history_section_recent': 'Recientes',
      'history_section_archived': 'Archivados',
      'history_section_shared': 'Compartidos',
      'history_pinned_section': 'Fijados',
      'history_empty': 'No hay conversaciones todavía.',
      'history_empty_search':
          'No hay conversaciones que coincidan con tu búsqueda.',
      'history_new_chat': 'Nuevo chat',
      'history_load_more': 'Cargar más',
      'history_refresh': 'Actualizar',
      'history_clear_search': 'Limpiar búsqueda',
      'history_retry': 'Reintentar',
      'history_thread_untitled': 'Conversación sin título',
      'history_status_archived': 'Archivado',
      'history_status_locked': 'Bloqueado',
      'history_status_shared': 'Compartido',
      'composer_add_tag': 'Añadir etiqueta',
      'composer_model_label': 'Modelo',
      'composer_tool_label': 'Herramienta',
      'composer_tool_auto': 'Automático',
      'composer_input_placeholder': 'Escribe al asistente',
      'attachment_limit_reached': 'Límite de adjuntos alcanzado.',
      'attachment_pick_failed': 'No se pudieron cargar los archivos.',
      'attachment_rejected_type': 'Tipo de archivo no compatible.',
      'attachment_rejected_size': 'El archivo supera el límite de tamaño.',
      'attachment_rejected_multiple': 'Algunos archivos fueron omitidos.',
      'attachment_drop_prompt': 'Suelta archivos para adjuntar',
      'attachment_upload_failed': 'Error al subir el adjunto.',
      'attachment_retry_upload': 'Reintentar carga',
      'attachment_remove': 'Eliminar',
      'attachment_uploading': 'Subiendo',
      'attachment_cancel_upload': 'Cancelar carga',
      'entity_picker_title': 'Insertar entidad',
      'entity_picker_search_hint': 'Buscar entidades',
      'entity_picker_no_results': 'Sin resultados',
      'entity_picker_preview': 'Vista previa',
      'entity_picker_close': 'Cerrar',
      'entity_picker_search_button': 'Buscar',
      'auth_expired': 'Sesión expirada',
      'auth_expired_description': 'Renueva tus credenciales para continuar.',
      'auth_expired_dismiss': 'Descartar',
      'feedback_positive': 'Pulgar arriba',
      'feedback_negative': 'Pulgar abajo',
      'retry_response': 'Reintentar respuesta',
      'share_message': 'Compartir mensaje',
      'feedback_sent': 'Comentarios enviados',
      'history_rename': 'Renombrar',
      'history_delete': 'Eliminar',
      'tag_suggestions_loading': 'Buscando entidades...',
      'tag_suggestions_empty': 'Sin coincidencias',
      'share_sheet_title': 'Compartir mensaje',
      'share_option_copy': 'Copiar al portapapeles',
      'share_option_system': 'Compartir...',
      'share_option_cancel': 'Cancelar',
      'share_toast_copied': 'Mensaje copiado al portapapeles.',
      'share_toast_shared': 'Cuadro de compartir abierto.',
      'notice_generic_title': 'Aviso',
      'notice_generic_message': 'Hay una actualización para esta conversación.',
      'notice_rate_limit_title': 'Límite de uso alcanzado',
      'notice_rate_limit_message':
          'Has alcanzado el límite. Espera un momento y vuelve a intentarlo.',
      'composer_disabled_rate_limit':
          'Límite alcanzado. Inténtalo de nuevo pronto.',
      'composer_disabled_auth': 'Sesión expirada. Actualiza para continuar.',
      'rate_limit_retry_in': 'Reintentar en {seconds}s.',
      'banner_dismiss': 'Cerrar',
    },
    'fr': {
      'history_title': 'Historique',
      'history_search_hint': 'Rechercher des conversations',
      'history_section_recent': 'Récentes',
      'history_section_archived': 'Archivées',
      'history_section_shared': 'Partagées',
      'history_pinned_section': 'Épinglées',
      'history_empty': 'Aucune conversation pour le moment.',
      'history_empty_search':
          'Aucune conversation ne correspond à votre recherche.',
      'history_new_chat': 'Nouvelle discussion',
      'history_load_more': 'Charger plus',
      'history_refresh': 'Actualiser',
      'history_clear_search': 'Effacer la recherche',
      'history_retry': 'Réessayer',
      'history_thread_untitled': 'Conversation sans titre',
      'history_status_archived': 'Archivée',
      'history_status_locked': 'Verrouillée',
      'history_status_shared': 'Partagée',
      'composer_add_tag': 'Ajouter une étiquette',
      'composer_model_label': 'Modèle',
      'composer_tool_label': 'Outil',
      'composer_tool_auto': 'Auto',
      'composer_input_placeholder': "Message à l'assistant",
      'attachment_limit_reached': 'Limite de pièces jointes atteinte.',
      'attachment_pick_failed': 'Impossible de charger les fichiers.',
      'attachment_rejected_type': 'Type de fichier non pris en charge.',
      'attachment_rejected_size': 'Le fichier dépasse la taille autorisée.',
      'attachment_rejected_multiple': 'Certains fichiers ont été ignorés.',
      'attachment_drop_prompt': 'Déposez les fichiers à joindre',
      'attachment_upload_failed': 'Échec du téléversement de la pièce jointe.',
      'attachment_retry_upload': 'Réessayer le téléversement',
      'attachment_remove': 'Supprimer',
      'attachment_uploading': 'Téléversement',
      'attachment_cancel_upload': 'Annuler le téléversement',
      'entity_picker_title': 'Insérer une entité',
      'entity_picker_search_hint': 'Rechercher des entités',
      'entity_picker_no_results': 'Aucun résultat',
      'entity_picker_preview': 'Aperçu',
      'entity_picker_close': 'Fermer',
      'entity_picker_search_button': 'Rechercher',
      'auth_expired': 'Session expirée',
      'auth_expired_description':
          'Veuillez renouveler vos identifiants pour continuer.',
      'auth_expired_dismiss': 'Fermer',
      'feedback_positive': 'Pouce en l’air',
      'feedback_negative': 'Pouce en bas',
      'retry_response': 'Relancer la réponse',
      'share_message': 'Partager le message',
      'feedback_sent': 'Retour envoyé',
      'history_rename': 'Renommer',
      'history_delete': 'Supprimer',
      'tag_suggestions_loading': 'Recherche d’entités...',
      'tag_suggestions_empty': 'Aucune correspondance',
      'share_sheet_title': 'Partager le message',
      'share_option_copy': 'Copier dans le presse-papiers',
      'share_option_system': 'Partager...',
      'share_option_cancel': 'Annuler',
      'share_toast_copied': 'Message copié dans le presse-papiers.',
      'share_toast_shared': 'Fenêtre de partage ouverte.',
      'notice_generic_title': 'Avis',
      'notice_generic_message':
          'Une mise à jour est disponible pour cette conversation.',
      'notice_rate_limit_title': 'Limite atteinte',
      'notice_rate_limit_message':
          'Vous avez atteint la limite. Patientez puis réessayez.',
      'composer_disabled_rate_limit': 'Limite atteinte. Réessayez bientôt.',
      'composer_disabled_auth':
          'Authentification expirée. Actualisez pour continuer.',
      'rate_limit_retry_in': 'Nouvel essai dans {seconds}s.',
      'banner_dismiss': 'Fermer',
    },
  };

  static const Map<String, String> _baseStrings = {
    'history_title': 'History',
    'history_search_hint': 'Search conversations',
    'history_section_recent': 'Recent',
    'history_section_archived': 'Archived',
    'history_section_shared': 'Shared',
    'history_pinned_section': 'Pinned',
    'history_empty': 'No conversations yet.',
    'history_empty_search': 'No conversations match your search.',
    'history_new_chat': 'New chat',
    'history_load_more': 'Load more',
    'history_refresh': 'Refresh',
    'history_clear_search': 'Clear search',
    'history_retry': 'Retry',
    'history_thread_untitled': 'Untitled conversation',
    'history_status_archived': 'Archived',
    'history_status_locked': 'Locked',
    'history_status_shared': 'Shared',
    'composer_add_tag': 'Add tag',
    'composer_model_label': 'Model',
    'composer_tool_label': 'Tool',
    'composer_tool_auto': 'Auto',
    'composer_input_placeholder': 'Message the AI',
    'attachment_limit_reached': 'Attachment limit reached.',
    'attachment_pick_failed': 'Unable to add attachment.',
    'attachment_rejected_type': 'Unsupported file type.',
    'attachment_rejected_size': 'File exceeds the size limit.',
    'attachment_rejected_multiple': 'Some files were skipped.',
    'attachment_drop_prompt': 'Drop files to attach',
    'attachment_upload_failed': 'Attachment upload failed.',
    'attachment_retry_upload': 'Retry upload',
    'attachment_remove': 'Remove',
    'attachment_uploading': 'Uploading',
    'attachment_cancel_upload': 'Cancel upload',
    'entity_picker_title': 'Insert entity',
    'entity_picker_search_hint': 'Search entities',
    'entity_picker_no_results': 'No results',
    'entity_picker_preview': 'Preview',
    'entity_picker_close': 'Close',
    'entity_picker_search_button': 'Search',
    'auth_expired': 'Session expired',
    'auth_expired_description':
        'Refresh your credentials to continue using ChatKit.',
    'auth_expired_dismiss': 'Dismiss',
    'feedback_positive': 'Thumbs up',
    'feedback_negative': 'Thumbs down',
    'retry_response': 'Retry response',
    'share_message': 'Share message',
    'feedback_sent': 'Feedback sent',
    'history_rename': 'Rename',
    'history_delete': 'Delete',
    'tag_suggestions_loading': 'Searching entities...',
    'tag_suggestions_empty': 'No matches',
    'share_sheet_title': 'Share message',
    'share_option_copy': 'Copy to clipboard',
    'share_option_system': 'Share...',
    'share_option_cancel': 'Cancel',
    'share_toast_copied': 'Message copied to clipboard.',
    'share_toast_shared': 'Share dialog opened.',
    'notice_generic_title': 'Notice',
    'notice_generic_message': 'There is an update for this conversation.',
    'notice_rate_limit_title': 'Rate limit reached',
    'notice_rate_limit_message':
        'You have reached the rate limit. Please wait and try again.',
    'composer_disabled_rate_limit': 'Rate limit reached. Try again soon.',
    'composer_disabled_auth': 'Authentication expired. Refresh to continue.',
    'rate_limit_retry_in': 'Retry in {seconds}s.',
    'banner_dismiss': 'Dismiss',
  };

  static const Set<String> supportedLocales = {
    'am',
    'ar',
    'bg',
    'bg-BG',
    'bn',
    'bn-BD',
    'bs',
    'bs-BA',
    'ca',
    'ca-ES',
    'cs',
    'cs-CZ',
    'da',
    'da-DK',
    'de',
    'de-DE',
    'el',
    'el-GR',
    'en',
    'es',
    'es-419',
    'es-ES',
    'et',
    'et-EE',
    'fi',
    'fi-FI',
    'fr',
    'fr-CA',
    'fr-FR',
    'gu',
    'gu-IN',
    'hi',
    'hi-IN',
    'hr',
    'hr-HR',
    'hu',
    'hu-HU',
    'hy',
    'hy-AM',
    'id',
    'id-ID',
    'is',
    'is-IS',
    'it',
    'it-IT',
    'ja',
    'ja-JP',
    'ka',
    'ka-GE',
    'kk',
    'kn',
    'kn-IN',
    'ko',
    'ko-KR',
    'lt',
    'lv',
    'lv-LV',
    'mk',
    'mk-MK',
    'ml',
    'mn',
    'mr',
    'mr-IN',
    'ms',
    'ms-MY',
    'my',
    'my-MM',
    'nb',
    'nb-NO',
    'nl',
    'nl-NL',
    'pa',
    'pl',
    'pl-PL',
    'pt',
    'pt-BR',
    'pt-PT',
    'ro',
    'ro-RO',
    'ru',
    'ru-RU',
    'sk',
    'sk-SK',
    'sl',
    'sl-SI',
    'so',
    'so-SO',
    'sq',
    'sq-AL',
    'sr',
    'sr-RS',
    'sv',
    'sv-SE',
    'sw',
    'sw-TZ',
    'ta',
    'ta-IN',
    'te',
    'te-IN',
    'th',
    'th-TH',
    'tl',
    'tr',
    'tr-TR',
    'uk',
    'uk-UA',
    'ur',
    'vi',
    'vi-VN',
    'zh',
    'zh-CN',
    'zh-HK',
    'zh-Hant',
    'zh-TW',
  };

  String t(String key) {
    if (overrides != null && overrides!.containsKey(key)) {
      return overrides![key]!;
    }

    final resolved = _resolveLocale(locale);
    final canonicalDefault =
        defaultLocale != null ? _canonicalizeLocale(defaultLocale!) : null;

    String? lookup(String localeCode) {
      final extra = extraBundles[localeCode];
      if (extra != null && extra.containsKey(key)) {
        return extra[key];
      }
      final builtIn = _builtInTranslations[localeCode];
      if (builtIn != null && builtIn.containsKey(key)) {
        return builtIn[key];
      }
      if (localeCode == 'en' && _baseStrings.containsKey(key)) {
        return _baseStrings[key];
      }
      return null;
    }

    final candidates = <String?>[
      resolved,
      canonicalDefault,
      'en',
    ];

    for (final candidate in candidates.whereType<String>()) {
      final value = lookup(candidate);
      if (value != null) {
        return value;
      }
      final languageCode = candidate.split('-').first;
      if (languageCode != candidate) {
        final languageValue = lookup(languageCode);
        if (languageValue != null) {
          return languageValue;
        }
      }
    }

    return _baseStrings[key] ?? key;
  }

  String format(String key, Map<String, Object?> params) {
    var value = t(key);
    params.forEach((placeholder, rawValue) {
      value = value.replaceAll('{$placeholder}', '${rawValue ?? ''}');
    });
    return value;
  }

  String plural(
    String key,
    num count, {
    Map<String, Object?> params = const {},
  }) {
    if (pluralResolver != null) {
      return pluralResolver!(key, count, params: params);
    }
    final merged = Map<String, Object?>.from(params)..['count'] = count;
    return format(key, merged);
  }

  static String canonicalize(String locale) => _canonicalizeLocale(locale);

  String? _resolveLocale(String? rawLocale) {
    if (rawLocale == null || rawLocale.isEmpty) {
      return null;
    }
    final canonical = _canonicalizeLocale(rawLocale);

    if (extraBundles.containsKey(canonical) ||
        _builtInTranslations.containsKey(canonical)) {
      return canonical;
    }

    final language = canonical.split('-').first;
    if (extraBundles.containsKey(language) ||
        _builtInTranslations.containsKey(language)) {
      return language;
    }

    if (supportedLocales.contains(canonical) ||
        supportedLocales.contains(language)) {
      return canonical;
    }

    return canonical.isEmpty ? null : canonical;
  }

  static String _canonicalizeLocale(String locale) {
    if (locale.isEmpty) {
      return locale;
    }
    final segments = locale.replaceAll('_', '-').split('-');
    if (segments.isEmpty) {
      return locale.toLowerCase();
    }
    final language = segments.first.toLowerCase();
    final rest = segments.skip(1).map((segment) {
      if (segment.length == 2) {
        return segment.toUpperCase();
      }
      return segment.toLowerCase();
    });
    return ([language, ...rest]..removeWhere((part) => part.isEmpty)).join('-');
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/theme/icons.dart">
import 'package:flutter/widgets.dart';
import 'package:phosphor_flutter/phosphor_flutter.dart';

/// Central registry mapping ChatKit icon identifiers to Flutter icon data.
///
/// ChatKit-JS uses a lightweight icon pack with consistent stroke widths.
/// We mirror those metaphors by mapping the same identifiers to the closest
/// matches in the Phosphor icon set (regular weight).
class ChatKitIcons {
  ChatKitIcons._();

  static final Map<String, IconData> _icons = <String, IconData>{
    'agent': PhosphorIconsRegular.robot,
    'analytics': PhosphorIconsRegular.chartLineUp,
    'archive': PhosphorIconsRegular.archive,
    'at': PhosphorIconsRegular.at,
    'atom': PhosphorIconsRegular.atom,
    'attachment': PhosphorIconsRegular.paperclip,
    'audio': PhosphorIconsRegular.musicNotesSimple,
    'batch': PhosphorIconsRegular.stackSimple,
    'bolt': PhosphorIconsRegular.lightning,
    'book-clock': PhosphorIconsRegular.bookBookmark,
    'book-closed': PhosphorIconsRegular.bookBookmark,
    'book-open': PhosphorIconsRegular.bookOpen,
    'browser': PhosphorIconsRegular.globeHemisphereWest,
    'bug': PhosphorIconsRegular.bug,
    'calculator': PhosphorIconsRegular.calculator,
    'calendar': PhosphorIconsRegular.calendarBlank,
    'chart': PhosphorIconsRegular.chartPie,
    'check': PhosphorIconsRegular.check,
    'check-circle': PhosphorIconsRegular.checkCircle,
    'check-circle-filled': PhosphorIconsRegular.checkCircle,
    'chevron-left': PhosphorIconsRegular.caretLeft,
    'chevron-right': PhosphorIconsRegular.caretRight,
    'circle-question': PhosphorIconsRegular.question,
    'compass': PhosphorIconsRegular.compass,
    'confetti': PhosphorIconsRegular.confetti,
    'cube': PhosphorIconsRegular.cube,
    'document': PhosphorIconsRegular.fileText,
    'dots-horizontal': PhosphorIconsRegular.dotsThreeOutline,
    'email': PhosphorIconsRegular.envelope,
    'empty-circle': PhosphorIconsRegular.circle,
    'error': PhosphorIconsRegular.xCircle,
    'file': PhosphorIconsRegular.file,
    'globe': PhosphorIconsRegular.globeHemisphereWest,
    'images': PhosphorIconsRegular.imagesSquare,
    'info': PhosphorIconsRegular.info,
    'keys': PhosphorIconsRegular.key,
    'lab': PhosphorIconsRegular.testTube,
    'lifesaver': PhosphorIconsRegular.lifebuoy,
    'lightbulb': PhosphorIconsRegular.lightbulb,
    'lock': PhosphorIconsRegular.lock,
    'mail': PhosphorIconsRegular.envelope,
    'map-pin': PhosphorIconsRegular.mapPin,
    'maps': PhosphorIconsRegular.mapTrifold,
    'mention': PhosphorIconsRegular.at,
    'name': PhosphorIconsRegular.identificationBadge,
    'notebook': PhosphorIconsRegular.notebook,
    'notebook-pencil': PhosphorIconsRegular.notePencil,
    'page-blank': PhosphorIconsRegular.fileText,
    'paper-plane': PhosphorIconsRegular.paperPlaneRight,
    'paperclip': PhosphorIconsRegular.paperclip,
    'phone': PhosphorIconsRegular.phone,
    'plus': PhosphorIconsRegular.plus,
    'profile': PhosphorIconsRegular.userCircle,
    'profile-card': PhosphorIconsRegular.identificationCard,
    'search': PhosphorIconsRegular.magnifyingGlass,
    'send': PhosphorIconsRegular.paperPlaneRight,
    'settings-slider': PhosphorIconsRegular.slidersHorizontal,
    'sound': PhosphorIconsRegular.musicNotesSimple,
    'sparkle': PhosphorIconsRegular.sparkle,
    'sparkle-double': PhosphorIconsRegular.sparkle,
    'square-code': PhosphorIconsRegular.code,
    'square-image': PhosphorIconsRegular.imageSquare,
    'square-text': PhosphorIconsRegular.textbox,
    'star': PhosphorIconsRegular.star,
    'star-filled': PhosphorIconsRegular.starFour,
    'suitcase': PhosphorIconsRegular.briefcase,
    'user': PhosphorIconsRegular.user,
    'video': PhosphorIconsRegular.videoCamera,
    'warning': PhosphorIconsRegular.warning,
    'wreath': PhosphorIconsRegular.crownSimple,
    'write': PhosphorIconsRegular.penNib,
    'write-alt': PhosphorIconsRegular.pencil,
    'write-alt2': PhosphorIconsRegular.pencilLine,
  };

  static final Map<String, IconData> _headerIcons = <String, IconData>{
    'sidebar-left': PhosphorIconsRegular.sidebar,
    'sidebar-open-left': PhosphorIconsRegular.arrowSquareLeft,
    'sidebar-open-left-alt': PhosphorIconsRegular.arrowCircleLeft,
    'sidebar-collapse-right': PhosphorIconsRegular.arrowFatLineRight,
    'sidebar-right': PhosphorIconsRegular.sidebarSimple,
    'sidebar-open-right': PhosphorIconsRegular.arrowSquareRight,
    'sidebar-open-right-alt': PhosphorIconsRegular.arrowCircleRight,
    'sidebar-collapse-left': PhosphorIconsRegular.arrowFatLineLeft,
    'sidebar-floating-left': PhosphorIconsRegular.sidebar,
    'sidebar-floating-open-left': PhosphorIconsRegular.arrowLineLeft,
    'sidebar-floating-right': PhosphorIconsRegular.sidebarSimple,
    'sidebar-floating-open-right': PhosphorIconsRegular.arrowLineRight,
    'collapse-left': PhosphorIconsRegular.caretCircleLeft,
    'collapse-right': PhosphorIconsRegular.caretCircleRight,
    'open-left': PhosphorIconsRegular.caretCircleLeft,
    'open-right': PhosphorIconsRegular.caretCircleRight,
    'double-chevron-left': PhosphorIconsRegular.caretDoubleLeft,
    'double-chevron-right': PhosphorIconsRegular.caretDoubleRight,
    'back-small': PhosphorIconsRegular.arrowLeft,
    'back-large': PhosphorIconsRegular.arrowCircleLeft,
    'expand-large': PhosphorIconsRegular.arrowsOut,
    'expand-small': PhosphorIconsRegular.arrowsOutSimple,
    'collapse-large': PhosphorIconsRegular.arrowsIn,
    'collapse-small': PhosphorIconsRegular.arrowsInSimple,
    'star': PhosphorIconsRegular.star,
    'star-filled': PhosphorIconsRegular.starFour,
    'chat-temporary': PhosphorIconsRegular.sparkle,
    'settings-cog': PhosphorIconsRegular.gearSix,
    'grid': PhosphorIconsRegular.gridNine,
    'dots-horizontal': PhosphorIconsRegular.dotsThreeOutline,
    'dots-vertical': PhosphorIconsRegular.dotsThreeOutlineVertical,
    'dots-horizontal-circle': PhosphorIconsRegular.dotsThreeCircle,
    'dots-vertical-circle': PhosphorIconsRegular.dotsThreeCircleVertical,
    'menu': PhosphorIconsRegular.list,
    'menu-inverted': PhosphorIconsRegular.list,
    'hamburger': PhosphorIconsRegular.list,
    'compose': PhosphorIconsRegular.penNib,
    'light-mode': PhosphorIconsRegular.sun,
    'dark-mode': PhosphorIconsRegular.moonStars,
    'close': PhosphorIconsRegular.x,
    'home': PhosphorIconsRegular.house,
    'home-alt': PhosphorIconsRegular.houseLine,
    'open-left-alt': PhosphorIconsRegular.caretCircleLeft,
    'open-right-alt': PhosphorIconsRegular.caretCircleRight,
  };

  static IconData? forWidget(String? name) {
    if (name == null || name.isEmpty) {
      return null;
    }
    return _icons[name];
  }

  static IconData? forHeader(String? name) {
    if (name == null || name.isEmpty) {
      return null;
    }
    return _headerIcons[name] ?? _icons[name];
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/theme/styles.dart">
import 'package:flutter/material.dart';

import 'chatkit_theme.dart';

enum ChatKitButtonVariant { solid, soft, outline, ghost }

enum ChatKitButtonSize { sm, md, lg }

enum ChatKitIconButtonVariant { solid, subtle, ghost }

/// Convenience helpers that translate [ChatKitThemeData] tokens into
/// consumable Flutter styles for inputs, buttons, charts, and feedback.
class ChatKitStyles {
  const ChatKitStyles._();

  static InputDecoration inputDecoration(
    BuildContext context, {
    String? label,
    String? hint,
    Widget? prefixIcon,
    Widget? suffixIcon,
    String? helper,
    String? error,
    bool withBorder = false,
    bool dense = true,
    EdgeInsetsGeometry? contentPadding,
  }) {
    final material = Theme.of(context);
    final theme = ChatKitTheme.of(context);
    final palette = theme.palette;
    final spacing = theme.spacing;
    final radii = theme.radii;

    final resolvedPadding = contentPadding ??
        EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: dense ? spacing.sm : spacing.md,
        );

    final baseBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(radii.field),
      borderSide: BorderSide(
        color: withBorder ? palette.borderMuted : palette.transparent,
        width: withBorder ? 1 : 0,
      ),
    );

    final focusedBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(radii.field),
      borderSide: BorderSide(
        color: withBorder ? palette.primary : palette.borderStrong,
        width: withBorder ? 1.5 : 1,
      ),
    );

    return InputDecoration(
      labelText: label,
      hintText: hint,
      helperText: helper,
      errorText: error,
      prefixIcon: prefixIcon,
      suffixIcon: suffixIcon,
      isDense: dense,
      filled: true,
      fillColor: palette.surfaceContainerHigh,
      contentPadding: resolvedPadding,
      border: baseBorder,
      enabledBorder: baseBorder,
      disabledBorder: baseBorder,
      focusedBorder: focusedBorder,
      errorBorder: baseBorder.copyWith(
        borderSide: BorderSide(color: palette.danger, width: 1.5),
      ),
      focusedErrorBorder: focusedBorder.copyWith(
        borderSide: BorderSide(color: palette.danger, width: 1.5),
      ),
      hintStyle: material.textTheme.bodyMedium?.copyWith(
        color: palette.onSurfaceSubtle,
      ),
    );
  }

  static ButtonStyle buttonStyle(
    BuildContext context, {
    ChatKitButtonVariant variant = ChatKitButtonVariant.solid,
    ChatKitButtonSize size = ChatKitButtonSize.md,
    bool danger = false,
  }) {
    final material = Theme.of(context);
    final theme = ChatKitTheme.of(context);
    final palette = theme.palette;
    final spacing = theme.spacing;
    final radii = theme.radii;

    final padding = switch (size) {
      ChatKitButtonSize.sm => EdgeInsets.symmetric(
          horizontal: spacing.sm,
          vertical: spacing.xs,
        ),
      ChatKitButtonSize.lg => EdgeInsets.symmetric(
          horizontal: spacing.xl,
          vertical: spacing.md,
        ),
      ChatKitButtonSize.md => EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
    };

    final minimumSize = switch (size) {
      ChatKitButtonSize.sm => Size(spacing.xxl, spacing.xl),
      ChatKitButtonSize.lg => Size(spacing.xxxl, spacing.xxl),
      ChatKitButtonSize.md => Size(spacing.xxxl, spacing.xxl),
    };

    final background = danger ? palette.danger : palette.primary;
    final foreground = danger ? palette.onSurface : palette.onPrimary;
    final dangerSoft = palette.danger.withValues(alpha: 0.12);
    final primarySoft = palette.primary.withValues(alpha: 0.12);

    final baseStyle = ButtonStyle(
      minimumSize: WidgetStateProperty.all(minimumSize),
      padding: WidgetStateProperty.all(padding),
      shape: WidgetStateProperty.all(
        RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.button),
        ),
      ),
      textStyle: WidgetStatePropertyAll(
        material.textTheme.labelLarge?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
    );

    return switch (variant) {
      ChatKitButtonVariant.solid => baseStyle.merge(
          ButtonStyle(
            backgroundColor: WidgetStateProperty.all(background),
            foregroundColor: WidgetStateProperty.all(foreground),
            overlayColor: WidgetStateProperty.all(
              foreground.withValues(alpha: 0.08),
            ),
          ),
        ),
      ChatKitButtonVariant.soft => baseStyle.merge(
          ButtonStyle(
            backgroundColor: WidgetStateProperty.all(
              danger ? dangerSoft : primarySoft,
            ),
            foregroundColor: WidgetStateProperty.all(
              danger ? palette.danger : palette.primary,
            ),
            overlayColor: WidgetStateProperty.all(
              (danger ? palette.danger : palette.primary)
                  .withValues(alpha: 0.1),
            ),
          ),
        ),
      ChatKitButtonVariant.outline => baseStyle.merge(
          ButtonStyle(
            backgroundColor: WidgetStateProperty.all(palette.transparent),
            foregroundColor: WidgetStateProperty.all(
              danger ? palette.danger : palette.onSurface,
            ),
            overlayColor: WidgetStateProperty.all(
              (danger ? palette.danger : palette.onSurface)
                  .withValues(alpha: 0.08),
            ),
            side: WidgetStateProperty.all(
              BorderSide(
                color: danger ? palette.danger : palette.borderMuted,
              ),
            ),
          ),
        ),
      ChatKitButtonVariant.ghost => baseStyle.merge(
          ButtonStyle(
            backgroundColor: WidgetStateProperty.all(palette.transparent),
            foregroundColor: WidgetStateProperty.all(
              danger ? palette.danger : palette.onSurface,
            ),
            overlayColor: WidgetStateProperty.all(
              (danger ? palette.danger : palette.onSurface)
                  .withValues(alpha: 0.08),
            ),
          ),
        ),
    };
  }

  static ButtonStyle iconButton(
    BuildContext context, {
    ChatKitIconButtonVariant variant = ChatKitIconButtonVariant.subtle,
    bool danger = false,
  }) {
    final theme = ChatKitTheme.of(context);
    final palette = theme.palette;
    final base = Theme.of(context).iconButtonTheme.style ??
        IconButton.styleFrom(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(theme.radii.icon),
          ),
          minimumSize: const Size.square(40),
        );

    final background = () {
      switch (variant) {
        case ChatKitIconButtonVariant.solid:
          return danger ? palette.danger : palette.onSurface;
        case ChatKitIconButtonVariant.subtle:
          return danger
              ? palette.danger.withValues(alpha: 0.12)
              : palette.onSurface.withValues(alpha: 0.08);
        case ChatKitIconButtonVariant.ghost:
          return palette.transparent;
      }
    }();

    final foreground = switch (variant) {
      ChatKitIconButtonVariant.solid =>
        danger ? palette.onSurface : palette.surface,
      ChatKitIconButtonVariant.subtle =>
        danger ? palette.danger : palette.onSurface,
      ChatKitIconButtonVariant.ghost =>
        danger ? palette.danger : palette.onSurface,
    };

    final overlay = foreground.withValues(alpha: 0.12);

    return base.merge(
      ButtonStyle(
        backgroundColor: WidgetStateProperty.all(background),
        foregroundColor: WidgetStateProperty.all(foreground),
        overlayColor: WidgetStateProperty.all(overlay),
      ),
    );
  }

  static Color statusColor(BuildContext context, String status) {
    final palette = ChatKitTheme.of(context).palette;
    switch (status) {
      case 'success':
        return palette.success;
      case 'warning':
        return palette.warning;
      case 'danger':
      case 'error':
        return palette.danger;
      case 'info':
      default:
        return palette.info;
    }
  }

  static List<Color> chartPalette(BuildContext context) {
    final palette = ChatKitTheme.of(context).palette;
    final primary = palette.primary;
    final hsl = HSLColor.fromColor(primary);
    return <Color>[
      primary,
      hsl.withHue((hsl.hue + 32) % 360).toColor(),
      hsl.withHue((hsl.hue + 64) % 360).toColor(),
      palette.info,
      palette.success,
      palette.warning,
      palette.danger,
    ];
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/theme/tokens.dart">
import 'package:flutter/material.dart';

class ComponentStyleToken {
  const ComponentStyleToken({
    this.backgroundColor,
    this.textColor,
    this.borderColor,
    this.elevation,
    this.radius,
  });

  final Color? backgroundColor;
  final Color? textColor;
  final Color? borderColor;
  final double? elevation;
  final double? radius;

  ComponentStyleToken copyWith({
    Color? backgroundColor,
    Color? textColor,
    Color? borderColor,
    double? elevation,
    double? radius,
  }) {
    return ComponentStyleToken(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      textColor: textColor ?? this.textColor,
      borderColor: borderColor ?? this.borderColor,
      elevation: elevation ?? this.elevation,
      radius: radius ?? this.radius,
    );
  }

  static ComponentStyleToken? lerp(
    ComponentStyleToken? a,
    ComponentStyleToken? b,
    double t,
  ) {
    if (a == null && b == null) {
      return null;
    }
    return ComponentStyleToken(
      backgroundColor: Color.lerp(a?.backgroundColor, b?.backgroundColor, t),
      textColor: Color.lerp(a?.textColor, b?.textColor, t),
      borderColor: Color.lerp(a?.borderColor, b?.borderColor, t),
      elevation: _lerpDouble(a?.elevation, b?.elevation, t),
      radius: _lerpDouble(a?.radius, b?.radius, t),
    );
  }

  static double? _lerpDouble(double? a, double? b, double t) {
    if (a == null && b == null) {
      return null;
    }
    return (a ?? 0) + ((b ?? 0) - (a ?? 0)) * t;
  }
}

class ChatKitThemeTokens extends ThemeExtension<ChatKitThemeTokens> {
  const ChatKitThemeTokens({
    this.backgroundGradient,
    this.surfaceElevation,
    this.historyElevation,
    this.historyStyle,
    this.composerStyle,
    this.assistantBubbleStyle,
    this.userBubbleStyle,
  });

  final Gradient? backgroundGradient;
  final double? surfaceElevation;
  final double? historyElevation;
  final ComponentStyleToken? historyStyle;
  final ComponentStyleToken? composerStyle;
  final ComponentStyleToken? assistantBubbleStyle;
  final ComponentStyleToken? userBubbleStyle;

  @override
  ChatKitThemeTokens copyWith({
    Gradient? backgroundGradient,
    double? surfaceElevation,
    double? historyElevation,
    ComponentStyleToken? historyStyle,
    ComponentStyleToken? composerStyle,
    ComponentStyleToken? assistantBubbleStyle,
    ComponentStyleToken? userBubbleStyle,
  }) {
    return ChatKitThemeTokens(
      backgroundGradient: backgroundGradient ?? this.backgroundGradient,
      surfaceElevation: surfaceElevation ?? this.surfaceElevation,
      historyElevation: historyElevation ?? this.historyElevation,
      historyStyle: historyStyle ?? this.historyStyle,
      composerStyle: composerStyle ?? this.composerStyle,
      assistantBubbleStyle: assistantBubbleStyle ?? this.assistantBubbleStyle,
      userBubbleStyle: userBubbleStyle ?? this.userBubbleStyle,
    );
  }

  @override
  ChatKitThemeTokens lerp(
    ThemeExtension<ChatKitThemeTokens>? other,
    double t,
  ) {
    if (other is! ChatKitThemeTokens) {
      return this;
    }
    return ChatKitThemeTokens(
      backgroundGradient: Gradient.lerp(
        backgroundGradient,
        other.backgroundGradient,
        t,
      ),
      surfaceElevation: ComponentStyleToken._lerpDouble(
        surfaceElevation,
        other.surfaceElevation,
        t,
      ),
      historyElevation: ComponentStyleToken._lerpDouble(
        historyElevation,
        other.historyElevation,
        t,
      ),
      historyStyle: ComponentStyleToken.lerp(
        historyStyle,
        other.historyStyle,
        t,
      ),
      composerStyle: ComponentStyleToken.lerp(
        composerStyle,
        other.composerStyle,
        t,
      ),
      assistantBubbleStyle: ComponentStyleToken.lerp(
        assistantBubbleStyle,
        other.assistantBubbleStyle,
        t,
      ),
      userBubbleStyle: ComponentStyleToken.lerp(
        userBubbleStyle,
        other.userBubbleStyle,
        t,
      ),
    );
  }
}
</file>

<file path="packages/chatkit_flutter/test/chatkit_gallery_golden_test.dart">
import 'package:chatkit_flutter/chatkit_flutter.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  Future<void> pumpGallery(
    WidgetTester tester,
    Brightness brightness,
  ) async {
    tester.view.devicePixelRatio = 1.0;
    tester.view.physicalSize = const Size(944, 1600);
    addTearDown(() {
      tester.view.resetDevicePixelRatio();
      tester.view.resetPhysicalSize();
    });

    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: ChatKitGallery(brightness: brightness),
        ),
      ),
    );
    await tester.pumpAndSettle();
  }

  testWidgets('ChatKit gallery light theme', (tester) async {
    await pumpGallery(tester, Brightness.light);
    await expectLater(
      find.byType(ChatKitGallery),
      matchesGoldenFile('goldens/chatkit_gallery_light.png'),
    );
  });

  testWidgets('ChatKit gallery dark theme', (tester) async {
    await pumpGallery(tester, Brightness.dark);
    await expectLater(
      find.byType(ChatKitGallery),
      matchesGoldenFile('goldens/chatkit_gallery_dark.png'),
    );
  });
}
</file>

<file path="packages/chatkit_flutter/test/localizations_test.dart">
import 'package:chatkit_flutter/src/localization/localizations.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('ChatKitLocalizations.format', () {
    test('replaces placeholders with provided values', () {
      final l10n = ChatKitLocalizations(locale: 'en', overrides: null);
      final formatted = l10n.format('rate_limit_retry_in', {'seconds': '42'});
      expect(formatted, equals('Retry in 42s.'));
    });

    test('uses override strings when supplied', () {
      final l10n = ChatKitLocalizations(
        locale: 'en',
        overrides: {
          'rate_limit_retry_in': 'Again in {seconds} seconds.',
        },
      );
      final formatted = l10n.format('rate_limit_retry_in', {'seconds': '5'});
      expect(formatted, equals('Again in 5 seconds.'));
    });
  });
}
</file>

<file path="packages/chatkit_flutter/README.md">
# ChatKit Flutter

`chatkit_flutter` provides native Flutter widgets built on top of `chatkit_core`, rendering the ChatKit widget DSL without a WebView. It targets feature parity with ChatKit JS so existing backend integrations (e.g. `chatkit-python`) work out of the box.

## Highlights

- Drop-in `ChatKitView` with history, start screen, composer, attachments, and thread actions
- Full widget renderer for cards, stacks, buttons, forms, metadata, tables, streaming text, etc.
- Entity tagging experiences (search, chips, previews) with customizable callbacks
- Model and tool selectors, retry/feedback/share controls, share-to-clipboard helper
- Hooks for widget actions (`widgets.onAction`) and client tools
- Rich theming surface (accent/grayscale/surface tokens, typography, shape radius)
- Localization bundles + default locale fallbacks matching the JS SDK
- Hosted-mode resilience with SSE keepalive handling, rate limit banners, and composer disable/enable on auth changes

## Install

```yaml
dependencies:
  chatkit_flutter:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_flutter
```

Install dependencies with `flutter pub get`.

## Usage

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: const CustomApiConfig(url: 'https://your-backend/chatkit'),
    history: const HistoryOption(enabled: true, showRename: true),
    threadItemActions: const ThreadItemActionsOption(
      feedback: true,
      retry: true,
      share: true,
    ),
    composer: ComposerOption(
      attachments: const ComposerAttachmentOption(enabled: true),
      tools: const [
        ToolOption(
          id: 'browser',
          label: 'Browser',
          description: 'Search the web',
          placeholderOverride: 'Search the web for…',
        ),
      ],
      models: const [
        ModelOption(id: 'gpt-4o', label: 'GPT-4o', defaultSelected: true),
        ModelOption(id: 'gpt-4o-mini', label: 'GPT-4o mini'),
      ],
    ),
    theme: const ThemeOption(
      color: ThemeColorOptions(
        accent: AccentColorOptions(primary: '#2563eb'),
        surface: SurfaceColorOptions(tertiary: '#f5f5f5'),
      ),
      shapes: ThemeShapeOptions(radius: 16),
    ),
    localization: const LocalizationOption(
      defaultLocale: 'en',
      bundles: {
        'es': {
          'history_title': 'Historial',
          'composer_add_tag': 'Añadir etiqueta',
        },
      },
    ),
    entities: EntitiesOption(
      onTagSearch: (query) async => fetchEntities(query),
      onClick: (entity) => debugPrint('Tapped ${entity.title}'),
    ),
    widgets: WidgetsOption(
      onAction: (action, context) async {
        debugPrint('Widget action: ${action.type}');
      },
    ),
  ),
);

class ChatScreen extends StatelessWidget {
  const ChatScreen({super.key, required this.controller});
  final ChatKitController controller;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: ChatKitView(controller: controller),
    );
  }
}
```

See [`packages/examples/coach_demo`](../examples/coach_demo) for a runnable app that demonstrates history, entity tagging, model/tool selectors, and widget previews.

## Testing

```
flutter test packages/chatkit_flutter
```

Golden baselines live under `test/golden/goldens`. Regenerate them with:

```
flutter test test/golden/widget_dsl_golden_test.dart --update-goldens
```

Key suites:

- `chatkit_view_test.dart` – history, entities, share, attachment, and composer flows.
- `golden/widget_dsl_golden_test.dart` – visual parity for complex widget layouts.
- `localizations_test.dart` – interpolation and overrides.

## Documentation

- [Parity matrix](../../docs/parity_matrix.md)
- [Usage guides](../../docs/usage_guides.md)
- [Widget property coverage](../../docs/widget_property_coverage.md)

## License

Apache-2.0 © Diwakar Moturu
</file>

<file path="packages/examples/coach_demo/pubspec.yaml">
name: chatkit_coach_demo
description: Example Flutter app demonstrating the ChatKit Dart client.
version: 0.1.0
publish_to: none

environment:
  sdk: ">=3.3.0 <4.0.0"
  flutter: ">=3.19.0"

dependencies:
  flutter:
    sdk: flutter
  chatkit_flutter:
    path: ../../chatkit_flutter
  chatkit_core:
    path: ../../chatkit_core

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.2

flutter:
  uses-material-design: true
</file>

<file path="packages/examples/coach_demo/README.md">
# Coach Demo (Flutter)

This example application wires `chatkit_core` + `chatkit_flutter` into a simple "Coach" experience that talks to a ChatKit-compatible backend (for example [`chatkit-python`](https://github.com/openai/chatkit-python)). It showcases:

- History panel with rename/delete/new chat
- Entity tagging with autocomplete, preview, and click handlers
- Model and tool selectors with composer state syncing
- Assistant feedback/retry/share controls
- Widget renderer previews (via entity preview dialog)

## Prerequisites

- Flutter 3.19 or later
- A ChatKit-compatible backend (e.g. FastAPI sample from `chatkit-python`) running at `http://localhost:8000/chatkit`

## Running

```bash
flutter pub get
flutter run
```

Update the endpoint or upload options in `lib/main.dart` to match your backend configuration.

## Highlights

- `ChatKitController` created with rich options (history, composer tools/models, entities, widgets, thread actions)
- `ChatKitView` renders the full native UI (no WebView)
- Demo entity search/preview data is stubbed locally so you can explore the UI even without a backend connection

## Customising

- Replace the `CustomApiConfig.url` with your own endpoint.
- Enable attachments by providing an upload strategy and returning upload URLs from your backend.
- Hook widget actions (`widgets.onAction`) or client tools (`onClientTool`) to drive bespoke app logic.
</file>

<file path=".gitignore">
# Dart & Flutter
.dart_tool/
.packages
pubspec.lock
build/
coverage/
.flutter-plugins
.flutter-plugins-dependencies
references/
analysis/

# IDEs
.idea/
.vscode/

# macOS
.DS_Store
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- `packages/chatkit_core`: Pure Dart client, protocol models, transport, and helpers. Unit tests live under `packages/chatkit_core/test`.
- `packages/chatkit_flutter`: Flutter widgets, theming, and golden baselines in `packages/chatkit_flutter/test/golden`. Update goldens only when the rendered output is intentionally changed.
- `packages/examples/coach_demo`: End-to-end sample app for manual QA against a ChatKit-compatible backend.
- `docs/`: Parity matrix, usage guides, and widget coverage that must be refreshed when surface areas change.
- `analysis_options.yaml`: Shared analyzer and lint configuration; keep package-level overrides in sync with it.

## Build, Test, and Development Commands
- Install dependencies: `dart pub get packages/chatkit_core` and `flutter pub get packages/chatkit_flutter packages/examples/coach_demo`.
- Static analysis: `dart analyze` (run from the repo root to cover all packages).
- Unit tests: `dart test packages/chatkit_core` and `flutter test packages/chatkit_flutter`.
- Golden updates: `flutter test packages/chatkit_flutter/test/golden/widget_dsl_golden_test.dart --update-goldens` after reviewing visual diffs.

## Coding Style & Naming Conventions
- Use `dart format .` before committing; 2-space indentation and trailing commas keep diffs tidy.
- Follow the shared lints (`prefer_const_constructors`, `prefer_final_locals`, `avoid_escaping_inner_quotes`, `avoid_unused_constructor_parameters`); resolve analyzer warnings instead of suppressing them.
- Classes and enums use PascalCase; methods, fields, and variables use lowerCamelCase. File names stay in snake_case (`chatkit_controller.dart`).
- Keep widget build methods small; extract private helpers for complex layouts or side effects.

## Testing Guidelines
- Name test files `*_test.dart` and group cases with `group` blocks mirroring the API surface (`ChatKitController`, `MessageComposer`).
- Aim for parity with JS coverage; add new unit or widget tests whenever behavior or contracts change.
- For UI changes, update the relevant golden and include regenerated artifacts with rationale in the PR description.
- Use the coach demo for exploratory testing; document manual steps when verifying regressions.

## Commit & Pull Request Guidelines
- Write imperative, sentence-case commit subjects (~60 chars) similar to `Refactor scrolling behavior: Optimize scroll-to-bottom logic`.
- Squash noisy fixups locally; every commit should pass `dart analyze` plus the relevant test suites.
- PRs need a concise summary, linked issues (if any), screenshots for UI shifts, and explicit callouts for golden updates or new configuration requirements.
- Include reproduction steps for bug fixes and mention any follow-up work in `plan.md` when applicable.

## Security & Configuration Tips
- Report vulnerabilities via the process in `SECURITY.md`; never publish backend credentials in code or docs.
- Keep example configs generic—use environment variables or placeholders in sample code within `packages/examples/coach_demo`.
</file>

<file path="analysis_options.yaml">
analyzer:
  exclude:
    - build/**
    - "**/*.g.dart"
  errors:
    missing_required_param: error
    missing_return: error
    dead_code: error

linter:
  rules:
    - prefer_const_constructors
    - prefer_final_locals
    - avoid_escaping_inner_quotes
    - avoid_unused_constructor_parameters
</file>

<file path="CHANGELOG.md">
# Changelog

## 0.1.0 – Phase 7 (Testing & Documentation)

- Added streaming fixtures in `packages/chatkit_core/test/fixtures` and new test
  coverage for SSE permutations, transport retry, and hosted-mode hooks.
- Expanded coverage for client tool invocations and workflow task updates with
  dedicated fixtures/tests.
- Introduced widget/golden regression suites for the DSL renderer and updated
  `chatkit_view_test.dart` to cover default share workflows.
- Added additional goldens (insights/workflow) and carousel keyboard navigation
  assertions.
- Documented parity status and advanced usage via
  [`docs/parity_matrix.md`](docs/parity_matrix.md) and
  [`docs/usage_guides.md`](docs/usage_guides.md).
- Published [`docs/widget_property_coverage.md`](docs/widget_property_coverage.md)
  and updated package docs with testing guidance plus golden regeneration notes.
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
      do not modify the License. You may add Your own attribution notices
      within Derivative Works that You distribute, alongside or as an
      addendum to the NOTICE text from the Work, provided that such
      additional attribution notices cannot be construed as modifying
      the License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2024 Diwakar Moturu

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="MIGRATION.md">
# Migrating from ChatKit JS to ChatKit Dart

The Dart/Flutter port mirrors the surface area of the official ChatKit JS client. Use this guide to translate existing integrations.

## Installation

| JS package | Dart equivalent |
| --- | --- |
| `@openai/chatkit` | `chatkit_core` (Dart) |
| `@openai/chatkit-react` | `chatkit_flutter` (Flutter) |

## Controller / Element

| ChatKit JS (`chatKit` element) | ChatKit Dart (`ChatKitController`) |
| --- | --- |
| `chatKit.focusComposer()` | `controller.focusComposer()` |
| `chatKit.setThreadId(id)` | `controller.setThreadId(id)` |
| `chatKit.setComposerValue({ text, reply, attachments })` | `controller.setComposerValue(text: ..., reply: ..., attachments: ...)` |
| `chatKit.sendUserMessage({ text, newThread, attachments })` | `controller.sendUserMessage(text: ..., newThread: ..., attachments: ...)` |
| `chatKit.fetchUpdates()` | `controller.fetchUpdates()` |
| `chatKit.sendCustomAction(action, itemId?)` | `controller.sendCustomAction(action, itemId: ...)` |
| `chatKit.retryAfterItem({ threadId, itemId })` | `controller.retryAfterItem(threadId: ..., itemId: ...)` |
| `chatKit.listThreads()` | `controller.listThreads()` |
| `chatKit.deleteThread(threadId)` | `controller.deleteThread(threadId)` |
| `chatKit.renameThread(threadId, title)` | `controller.renameThread(threadId, title)` |
| `chatKit.submitFeedback({ threadId, itemIds, kind })` | `controller.submitFeedback(threadId: ..., itemIds: ..., kind: ...)` |
| `chatKit.shareItem(itemId)` (UI) | `controller.shareItem(itemId)` (copy to clipboard in Flutter) |

## Options

All JS options map 1:1 to Dart classes with camelCase -> lowerCamelCase conversion:

| JS | Dart |
| --- | --- |
| `api.url` | `CustomApiConfig.url` |
| `api.domainKey` | `CustomApiConfig.domainKey` |
| `api.uploadStrategy` (`{ type: 'direct' | 'two_phase', uploadUrl? }`) | `DirectUploadStrategy(uploadUrl)` / `TwoPhaseUploadStrategy()` |
| `history.showDelete` | `HistoryOption(showDelete: true)` |
| `composer.attachments.enabled` | `ComposerAttachmentOption(enabled: true)` |
| `composer.tools` | `List<ToolOption>` |
| `composer.models` | `List<ModelOption>` |
| `threadItemActions.feedback/retry/share` | `ThreadItemActionsOption(feedback: true, retry: true, share: true)` |
| `entities.onTagSearch` | `EntitiesOption(onTagSearch: ...)` |
| `widgets.onAction` | `WidgetsOption(onAction: ...)` |

Events are emitted through `controller.events` using the same names as JS (e.g. `chatkit.response.start`). Additional convenience events: `chatkit.composer.change`, `chatkit.composer.focus`, and `chatkit.message.share`.

## UI component

| ChatKit JS | ChatKit Flutter |
| --- | --- |
| `<oai-chatkit options={...} />` | `ChatKitView(controller: controller)` |
| CSS theming | Flutter theming (`ThemeData`) + `ChatKitOptions.theme` |
| React hooks (`useChatKit`) | Pure Dart controller + Flutter widget tree |

## Attachments

- JS two-phase upload: `uploadStrategy: { type: 'two_phase' }` -> Dart `CustomApiConfig(uploadStrategy: const TwoPhaseUploadStrategy())`.
- JS direct upload: `uploadStrategy: { type: 'direct', uploadUrl }` -> Dart `CustomApiConfig(uploadStrategy: DirectUploadStrategy(uploadUrl: ...))`.
- `controller.registerAttachment` wraps the strategy exactly like JS `chatkit.attachments`.

## Widgets DSL

The renderer accepts the same JSON schema generated by `chatkit-python`. Unknown widget types are logged and skipped so apps can tolerate incremental backend updates.

## Client tools & entity previews

- JS `onClientTool` -> Dart `ChatKitOptions(onClientTool: ...)`
- JS `entities.onRequestPreview` -> Dart `EntitiesOption(onRequestPreview: ...)` (rendered via Flutter dialog)

## Share behaviour

In JS the host handles share events. In Flutter `controller.shareItem` emits `chatkit.message.share` and copies the assistant text to the clipboard by default. Override this behaviour by listening to the event stream.

## Migration tips

1. **Start from shared options.** Re-use your JS configuration; convert the object literal to `ChatKitOptions`.
2. **Keep backend unchanged.** The Dart controller speaks the same protocol; no backend work required beyond CORS.
3. **Uncomment features incrementally.** Start with history + composer; add entities, attachments, and widgets once the basics work.
4. **Validate streaming flows.** Use `dart test` / `flutter test` with SSE fixtures or run against the `chatkit-python` sample server.

For additional configuration details, see the package READMEs and `plan.md`.
</file>

<file path="plan.md">
Awesome, Diwakar. Below is a **concrete, end‑to‑end implementation plan** you can hand to Codex (or your engs) to produce a **publishable Dart/Flutter port of ChatKit** that mirrors the JS API, integrates with your **chatkit‑python** backend, and renders the full **widgets** DSL natively—no WebView.

Where I reference specifics of ChatKit’s behavior (methods, events, options, widgets, server SSE), I cite the official docs so the code can follow them precisely.

---

## 0) Objectives & non‑goals

**Objectives**

* Port the ChatKit client to **Dart** with two packages:

  * `chatkit_core` (pure Dart): protocol, models, SSE transport, controller.
  * `chatkit_flutter` (Flutter UI): native chat UI + full **widgets** renderer.
* **API parity** with ChatKit JS **methods** and **events** so app code stays consistent:
  Methods: `focusComposer()`, `setThreadId(threadId)`, `sendUserMessage({ text, reply, attachments, newThread })`, `setComposerValue({...})`, `fetchUpdates()`, `sendCustomAction(action, itemId?)`. ([OpenAI GitHub Pages][1])
  Events: `chatkit.thread.change`, `chatkit.response.start/end`, `chatkit.error`, `chatkit.log`, plus thread load events. ([OpenAI GitHub Pages][2])
* **Transport parity** with the Python SDK server: one **POST** endpoint, returning JSON for non‑streaming or **SSE** for streaming updates. ([OpenAI GitHub Pages][3])
* **Widgets DSL parity** (render all components listed in the Python widgets reference—Card, Text, Markdown, Button, Form, DatePicker, Chart, etc.). ([OpenAI GitHub Pages][4])
* Support **attachments** with **direct** and **two‑phase** strategies, and optional **domain allow‑list key**—same config surface as JS `api.fetch`, `uploadStrategy`, `domainKey`. ([OpenAI GitHub Pages][5])
* Support **Client Tools** (browser/client callbacks) with the same lifecycle as JS (`onClientTool`). ([OpenAI GitHub Pages][6])
* Support **entity tagging** and preview hooks in custom backend mode. ([OpenAI GitHub Pages][7])
* License the Dart port under **Apache‑2.0** to match upstream. ([GitHub][8])

**Non‑goals**

* Hosting the backend; you already run `chatkit-python`.
* Re‑implementing Agents SDK; only consume its streamed events through `chatkit-python`. ([OpenAI GitHub Pages][3])

---

## 1) Repository layout (monorepo)

```
/packages
  /chatkit_core/          # pure Dart library
  /chatkit_flutter/       # Flutter UI + widgets renderer
  /examples/coach_demo/   # minimal app using your FastAPI endpoint
/.github/workflows/ci.yml
/CONTRIBUTING.md
/LICENSE (Apache-2.0)
/README.md
```

**Acceptance**

* Build passes on stable Flutter/Dart (pin exact versions in `pubspec.yaml`).
* `dart format` and `dart analyze` clean.
* CI runs unit, widget, and integration tests on pull requests.

---

## 2) Packages & dependencies

**chatkit_core (Dart)**

* `http` (streaming SSE)
* `meta`, `collection`, `json_annotation`/`build_runner` (optional for codegen)
* `uuid` (optional for client‑side ids)
* No Flutter imports.

**chatkit_flutter (Flutter)**

* `chatkit_core`
* `flutter_markdown`
* `intl` (localization)
* `file_picker`, `image_picker` (attachments)
* `cached_network_image` (image widget previews)

---

## 3) Public API spec (match JS surface)

Create `ChatKitController` + `ChatKitOptions` mirroring JS options and methods:

```dart
// chatkit_core
class ChatKitController {
  ChatKitController(ChatKitOptions options);

  // --- METHODS (parity with JS) ---
  Future<void> focusComposer();                         // no-op in core; UI hooks it
  Future<void> setThreadId(String? threadId);
  Future<void> sendUserMessage({
    required String text,
    Map<String, dynamic>? reply,
    List<Map<String, dynamic>>? attachments,
    bool newThread = false,
  });
  Future<void> setComposerValue({
    String? text,
    Map<String, dynamic>? reply,
    List<Map<String, dynamic>>? attachments,
  });
  Future<void> fetchUpdates();
  Future<void> sendCustomAction(Map<String, dynamic> action, {String? itemId});

  // --- EVENTS (same names as JS docs) ---
  Stream<ChatKitEvent> get events; // emits:
  // ThreadChangeEvent (chatkit.thread.change)
  // ResponseStartEvent / ResponseEndEvent (chatkit.response.start/end)
  // ErrorEvent (chatkit.error)
  // LogEvent (chatkit.log)
}
```

* Provide options to configure **hosted** tokens (`getClientSecret`), **custom backend** (`api.url`, `fetch` to inject headers), **uploadStrategy** (`direct`, `twoPhase`), and **domainKey**. This mirrors JS `CustomApiConfig`. ([OpenAI GitHub Pages][5])

**Definition of Done:** All method names, parameter names, and event semantics align with the JS **Methods** and **Events** docs; attempts to call methods while a response is streaming should be rejected similarly to JS guidance. ([OpenAI GitHub Pages][1])

---

## 4) Transport & protocol

**4.1** Implement SSE client:

* POST to `/chatkit` (your endpoint), send JSON body.
* If response is `text/event-stream`, parse SSE frames; each `data:` line is JSON → decode into `ThreadStreamEvent`.
* If response is `application/json`, decode as a one‑shot result (used for non‑streaming operations e.g., `items.list`).
* Reconnect or error out cleanly on non‑200.

**Why:** Matches Python SDK: **single POST** endpoint, JSON or **SSE** streaming of the `ThreadStreamEvent` union. ([OpenAI GitHub Pages][3])

**4.2** Request payloads (to interop with chatkit‑python)

* Use the server guide’s contract (Python’s `ChatKitServer.process`): you POST the client request; server decides streaming vs JSON. ([OpenAI GitHub Pages][3])
* Provide helper builders for common flows:

  * `threads.create` when no thread id yet, otherwise `threads.add_user_message`.
  * `items.list` to fetch history.
  * `threads.custom_action` for widget actions.
* (These names reflect the typical commands referenced in ChatKit/Agents SDK examples; your backend already handles them via `ChatKitServer` → `respond`/`action`.) ([OpenAI GitHub Pages][3])

**Definition of Done:** SSE parser handles partial lines, multiple `data:` segments per event, and blank-line dispatch; robust to HTTP chunk boundaries.

---

## 5) Data model mapping (Dart)

Create a **strongly typed mirror** of the Python SDK types you’ll receive:

* `ThreadStreamEvent` (discriminator `type`) → subclasses:

  * `ThreadCreatedEvent`, `ThreadUpdatedEvent`
  * `ThreadItemAddedEvent`, `ThreadItemUpdatedEvent`, `ThreadItemDoneEvent`, `ThreadItemRemovedEvent`, `ThreadItemReplacedEvent`
  * `ProgressUpdateEvent`, `ErrorThreadEvent`, `NoticeEvent`
* `ThreadItem` union:

  * `UserMessageItem`, `AssistantMessageItem`, `ClientToolCallItem`, `WidgetItem`, `TaskItem`, `WorkflowItem`, `EndOfTurnItem`, `HiddenContextItem`
* `AssistantMessageItem.parts`: include **text deltas** (streaming) and other content parts (images, references).
* `WidgetItem.root`: root JSON node for the widgets DSL.

This follows the Python SDK’s event & item unions used by the server. ([OpenAI GitHub Pages][3])

**Definition of Done:** Round‑trip test fixtures from the Python docs examples decode into Dart classes without loss; unknown fields preserved for forward compatibility.

---

## 6) Attachments (client)

Implement all three strategies supported in JS options:

* **Direct upload**: POST `multipart/form-data` with field `file` to `uploadUrl` supplied in options; server returns `FileAttachment | ImageAttachment` JSON to include in `sendUserMessage`. ([OpenAI GitHub Pages][5])
* **Two‑phase**: call `attachments.create` (your backend persists metadata + returns `upload_url`), then upload bytes, then send the message referencing the created attachment. ([OpenAI GitHub Pages][3])
* **Hosted** (optional for future): use token flow (`getClientSecret`) if you adopt hosted mode later. ([OpenAI GitHub Pages][9])

Composer config should enforce `maxCount`, `maxSize`, and mime **accept** lists; errors surface via `chatkit.error`. ([OpenAI GitHub Pages][2])

---

## 7) Client Tools (browser/device callbacks)

Expose `onClientTool: Future<Map<String, dynamic>> Function({name, params})` in options. When a **client tool call** arrives from the server (Agents SDK sets it; ChatKit pauses streaming), invoke the callback; forward returned JSON back to the server; resume. Semantics mirror JS **Client tools**. ([OpenAI GitHub Pages][6])

**Definition of Done:** If callback throws, emit `chatkit.error` and send error back to server; ensure only one tool call is processed at a time as per server notes. ([OpenAI GitHub Pages][3])

---

## 8) Widgets DSL → Flutter widgets

Implement a **renderer** that converts widget JSON into native Flutter. Use the Python **Widgets** reference to ensure prop names and behaviors match (Badge, Box/Row/Col, Card, Text, Title, Markdown, Button, Checkbox, RadioGroup, Select, Input, Textarea, DatePicker, Divider, Spacer, Icon, Image, ListView/ListViewItem, Form, Chart, Transition, Caption, Label). ([OpenAI GitHub Pages][4])

**Actions:** Bind `ActionConfig` props (`onClickAction`, `onChangeAction`, `onSubmitAction`) to call `sendCustomAction`. Also allow **client‑side action handlers** when `handler="client"` is present (forward to a widgets onAction hook), following Python “Actions” guide. ([OpenAI GitHub Pages][10])

**Definition of Done**

* Every listed widget renders with documented props.
* Forms collect named inputs into action payloads (including `Card(asForm=True)` behavior). ([OpenAI GitHub Pages][10])
* Charts render basic bar/line/area (pick a simple pure‑Flutter chart or custom painter).
* Markdown uses `flutter_markdown`.

---

## 9) Theming, Localization, Entities

* **Theming**: Provide `ThemeOptions` akin to JS (`colorScheme`, accent, surface colors); map to `ThemeData`. ([OpenAI GitHub Pages][11])
* **Localization**: Support the `localization` hooks similar to JS, wiring through to `MaterialApp` locale; expose strings for all system UI messages. ([OpenAI GitHub Pages][12])
* **Entities**: Expose `entities.onTagSearch`, `onClick`, `onRequestPreview` with widget preview payloads for @‑mentions and source citations. ([OpenAI GitHub Pages][7])

---

## 10) Error handling & logs

Emit structured events:

* `chatkit.error` with rich error object (network, decode, SSE) and context (request id, thread id).
* `chatkit.log` for verbose diagnostics (SSE lifecycle, widget apply, action routing).
  Mirror the **Events** guide semantics. ([OpenAI GitHub Pages][2])

---

## 11) Testing strategy

**Unit (core)**

* SSE parser: fragmented frames, multiple `data:` lines per event, unicode.
* JSON decoding: all `ThreadStreamEvent` and `ThreadItem` unions (golden fixtures).
* Attachment strategies: happy / error paths.

**Widget tests (flutter)**

* Golden tests for each widget type using sample JSON from docs (Card, Form, Select, DatePicker, Chart, Transition). ([OpenAI GitHub Pages][4])
* Action dispatch: clicking Button triggers `sendCustomAction` with correct payload; `Form` aggregates named fields. ([OpenAI GitHub Pages][10])

**Integration**

* Connect to a local FastAPI stub that returns scripted SSE streams (recordings from your staging) as per **Server Integration** page. Validate events → rendered UI. ([OpenAI GitHub Pages][3])

---

## 12) CI/CD

* GitHub Actions: matrix for Dart/Flutter versions; run `flutter test` and `dart test`.
* Lints: `pedantic`/`flutter_lints`.
* Publish workflow (manual) to `pub.dev` for both packages; semantic versioning.

---

## 13) Security & performance

* **Security**: never persist secrets client‑side; only inject headers via `api.fetch` callback; if you use hosted mode later, implement short‑lived token refresh (`getClientSecret`). ([OpenAI GitHub Pages][9])
* **Attachments**: enforce accept lists & size; never expose raw signed URLs beyond immediate use; follow AttachmentStore guidance for access control. ([OpenAI GitHub Pages][3])
* **Perf**: incremental list rendering (message virtualization), image caching, coalesce text deltas, debounce widget updates.

---

## 14) Example app (`examples/coach_demo`)

* Minimal Flutter app with one page hosting `<ChatKitView>`.
* Config points to your `/chatkit` FastAPI endpoint (custom backend mode with `api.url` + `fetch` adding JWT). ([OpenAI GitHub Pages][5])
* Buttons to switch `threadId`, attach files, and trigger a demo widget action.

---

## 15) Work breakdown structure (WBS)

> Create issues/milestones in the repo with these acceptance tests. Codex can implement in order.

### M1 — Scaffolding

* [ ] Create monorepo structure, CI, lints, license (Apache‑2.0). ([GitHub][8])

### M2 — Transport & controller (core)

* [ ] Implement `ChatKitOptions` with `ApiOptions { url | fetch | getClientSecret | uploadStrategy | domainKey }`. ([OpenAI GitHub Pages][5])
* [ ] SSE client (`text/event-stream`) + JSON POST.
* [ ] `ChatKitController` with **all methods** and state guards (reject during response, as per Events guide). ([OpenAI GitHub Pages][2])
* [ ] Event stream types (`ChatKitEvent`): thread.change, response.start/end, error, log. ([OpenAI GitHub Pages][2])
* **Acceptance:** Demo prints deltas to console from a mocked SSE stream.

### M3 — Models (core)

* [ ] Implement `ThreadStreamEvent` union + `ThreadItem` union and deltas.
* [ ] JSON decoding with discriminator `type`.
* **Acceptance:** Golden fixtures decode/encode round‑trip.

### M4 — Attachments (core)

* [ ] Direct upload helper with `multipart/form-data` to `uploadUrl`.
* [ ] Two‑phase helper: `attachments.create` → upload → reference.
* **Acceptance:** Local test server echoes attachment JSON; errors raise `chatkit.error`. ([OpenAI GitHub Pages][3])

### M5 — Client tools (core)

* [ ] `onClientTool` hook; serialize return value to server; single‑call concurrency.
* **Acceptance:** Simulated tool call pauses stream; resumes on client return. ([OpenAI GitHub Pages][6])

### M6 — Flutter UI shell

* [ ] `ChatKitView(controller)` with header, message list, composer.
* [ ] Bind `focusComposer` via `FocusNode`.
* **Acceptance:** Sends messages; shows streaming text.

### M7 — Widgets renderer (phase 1)

* [ ] Implement primitives: **Text, Title, Markdown, Button, Divider, Spacer, Icon, Image, Row/Col/Box, Card, ListView/ListViewItem**. ([OpenAI GitHub Pages][4])
* [ ] Wire actions to `sendCustomAction`.
* **Acceptance:** Render sample widget trees from docs.

### M8 — Widgets renderer (phase 2)

* [ ] Inputs: **Input, Textarea, Checkbox, RadioGroup, Select, DatePicker, Form**. ([OpenAI GitHub Pages][4])
* [ ] Form value collection & validation semantics; `Card(asForm=True)` confirm/cancel behavior. ([OpenAI GitHub Pages][10])
* **Acceptance:** Form submit builds payload per docs (namespaced keys).

### M9 — Widgets renderer (phase 3)

* [ ] **Chart** + **Transition** + **Caption/Label/Badge**. ([OpenAI GitHub Pages][4])
* **Acceptance:** Chart renders provided series; Transition shows loading/placeholder states.

### M10 — Theming, Localization, Entities

* [ ] Theming options mapping (light/dark, accent). ([OpenAI GitHub Pages][11])
* [ ] Localization hooks & string tables. ([OpenAI GitHub Pages][12])
* [ ] Entities: `onTagSearch`, `onClick`, `onRequestPreview` (preview uses widgets). ([OpenAI GitHub Pages][7])
* **Acceptance:** @‑mentions show suggestions; hover/tap preview renders a Card.

### M11 — Integration demo & docs

* [ ] Example app wired to `/chatkit` FastAPI server (custom backend). ([OpenAI GitHub Pages][3])
* [ ] README with setup, code samples, and migration notes (JS → Dart map).

---

## 16) File‑level skeleton (key files Codex should create)

**`packages/chatkit_core/lib/chatkit_core.dart`**

```dart
library chatkit_core;
export 'src/options.dart';
export 'src/controller.dart';
export 'src/events.dart';
export 'src/models/models.dart';
export 'src/net/sse_client.dart';
export 'src/net/api_client.dart';
```

**`src/options.dart`**

* `ApiOptions` with `url`, `fetch(url, method, headers, body)`, `getClientSecret(existing)`, `uploadStrategy`, `domainKey`. (Parity with JS Custom Backends + Authentication.) ([OpenAI GitHub Pages][5])

**`src/events.dart`**

* `ChatKitEvent` base + `ThreadChangeEvent`, `ResponseStartEvent`, `ResponseEndEvent`, `ErrorEvent`, `LogEvent`. (Parity with JS Events.) ([OpenAI GitHub Pages][2])

**`src/models/models.dart`**

* All `ThreadStreamEvent` and `ThreadItem` unions per Python SDK usage. ([OpenAI GitHub Pages][3])

**`src/net/sse_client.dart`**

* Streaming POST with SSE parsing.

**`src/net/api_client.dart`**

* `sendStreaming(payload)` and `sendJson(payload)`; uses `ApiOptions.fetch` when provided; injects `domainKey`.

**`src/controller.dart`**

* Implement all methods (with guards during response / thread load as in Events guide). ([OpenAI GitHub Pages][2])

**`packages/chatkit_flutter/lib/chatkit_view.dart`**

* Shell: header, message list, composer; focus wiring.

**`packages/chatkit_flutter/lib/widgets/renderer.dart`**

* `Widget render(Map<String, dynamic> node)` switch for all components listed in widgets reference. ([OpenAI GitHub Pages][4])

**`packages/chatkit_flutter/lib/widgets/composer.dart`**

* Text field, attachments, pinned tools; honors `placeholder`, `accept`, `maxSize`, `maxCount`.

**`examples/coach_demo/lib/main.dart`**

* Shows `ChatKitView` with options pointing to your FastAPI endpoint.

---

## 17) Compatibility & migration table (JS → Dart)

| JS                                                                                                                 | Dart/Flutter                                                                           |
| ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- |
| `useChatKit({...})`                                                                                                | `ChatKitController(ChatKitOptions(...))`                                               |
| `api: { url, fetch, uploadStrategy, domainKey }`                                                                   | `ApiOptions(url, fetch, uploadStrategy, domainKey)`                                    |
| `api: { getClientSecret(existing) }`                                                                               | `ApiOptions.getClientSecret(existing)`                                                 |
| Methods: `focusComposer`, `setThreadId`, `sendUserMessage`, `setComposerValue`, `fetchUpdates`, `sendCustomAction` | Identical methods on controller. ([OpenAI GitHub Pages][1])                            |
| Events: `chatkit.thread.change`, `chatkit.response.*`, `chatkit.error`, `chatkit.log`                              | `ChatKitEvent` stream emits equivalent types. ([OpenAI GitHub Pages][2])               |
| Widgets JSON                                                                                                       | `WidgetsRenderer.render(node)` produces Flutter UI. ([OpenAI GitHub Pages][4])         |
| Client tools (`onClientTool`)                                                                                      | `onClientTool` option invoked; results forwarded to server. ([OpenAI GitHub Pages][6]) |
| Entity tagging (`onTagSearch`, `onRequestPreview`, `onClick`)                                                      | Same‑named options in Dart; previews rendered via widgets. ([OpenAI GitHub Pages][7])  |

---

## 18) Example configuration in your app (Coach tab)

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: ApiOptions(
      url: Uri.parse('https://api.26weeks.ai/chatkit'),
      fetch: (url, method, headers, body) async {
        // inject session JWT; return a small adapter result
        // (Codex: implement an adapter class to normalize to http.Response)
        throw UnimplementedError();
      },
      uploadStrategy: const TwoPhaseUploadStrategy(),
      domainKey: 'your-domain-key', // if you use allow-list
    ),
    composer: ComposerOptions(
      placeholder: "Ask your coach anything…",
      attachments: ComposerAttachments(
        uploadStrategy: const TwoPhaseUploadStrategy(),
        maxCount: 3,
        maxSize: 20 * 1024 * 1024,
        accept: ComposerAttachmentAccept({
          'image/*': ['.png', '.jpg', '.jpeg'], 'application/pdf': ['.pdf']
        }),
      ),
    ),
    entities: EntitiesOptions(
      onTagSearch: (q) async => [],
      onRequestPreview: (e) async => {/* widget JSON */},
    ),
  ),
);
return ChatKitView(controller: controller);
```

**Why this shape:** Mirrors the **Custom Backends** guide so the client injects auth and upload strategy without exposing secrets. ([OpenAI GitHub Pages][5])

---

## 19) Sample fixtures for tests

* **SSE stream** with interleaved text deltas and a widget add/update; ensure `ResponseStart/End` emitted at correct times. (Model after the Python server streaming contract.) ([OpenAI GitHub Pages][3])
* **Widget JSON** for each component in the widgets list (Card with Form & Button; Select with `onChangeAction`; DatePicker; Chart). ([OpenAI GitHub Pages][4])
* **Action routing**: `handler="client"` vs server‑handled action as documented. ([OpenAI GitHub Pages][10])

---

## 20) Documentation deliverables

* **README.md** for each package with:

  * Quickstart (custom backend mode) with code snippets (based on **Custom Backends**/**Methods** docs). ([OpenAI GitHub Pages][5])
  * Widgets usage & supported props (link to Python Widgets ref). ([OpenAI GitHub Pages][4])
  * Client Tools & Entities sections. ([OpenAI GitHub Pages][6])
* **MIGRATION.md**: JS → Dart mapping table (above).
* **SECURITY.md**: token refresh (hosted), domain allow‑listing, attachment access control. ([OpenAI GitHub Pages][9])

---

## 21) Risks & mitigations

* **Spec drift** (JS evolves): keep models tolerant to unknown fields; log but ignore unknown widget types.
* **SSE edge cases**: build robust line parser; backoff/retry on transient network errors.
* **Access control on attachments**: follow AttachmentStore guidance (verify requester owns the resource). ([OpenAI GitHub Pages][3])

---

## 22) “Definition of Done” (project)

* `chatkit_core` and `chatkit_flutter` published to `pub.dev`.
* Parity with JS **methods**, **events**, **custom backend options**, **client tools**, **entities**. ([OpenAI GitHub Pages][1])
* Widgets renderer supports all components listed in Python **Widgets** reference. ([OpenAI GitHub Pages][4])
* Example app compiles and streams from your FastAPI `/chatkit`. ([OpenAI GitHub Pages][3])
* Test coverage on SSE, models, renderer, actions, attachments.

---

## 23) Issue templates for Codex

1. **Core transport**
   *Implement SSE POST client and `ApiClient` with `fetch` override.*
   **Refs:** Server Integration (single POST, JSON/SSE). ([OpenAI GitHub Pages][3])

2. **Controller methods & events**
   *Implement all methods and event emission rules.*
   **Refs:** Methods; Events. ([OpenAI GitHub Pages][1])

3. **Models & decoding**
   *Define `ThreadStreamEvent` / `ThreadItem` unions; robust JSON decode.*
   **Refs:** Python server guide & type modules. ([OpenAI GitHub Pages][3])

4. **Attachments strategies**
   *Direct & two‑phase flows; composer limits & accept; error propagation.*
   **Refs:** Custom Backends; Attachment store. ([OpenAI GitHub Pages][5])

5. **Client tools**
   *Add `onClientTool` option; pause/resume stream; error semantics.*
   **Refs:** Client tools. ([OpenAI GitHub Pages][6])

6. **Widgets renderer P1/P2/P3**
   *Render all components; wire actions; form semantics; charts.*
   **Refs:** Widgets; Actions (forms & loading behavior). ([OpenAI GitHub Pages][4])

7. **Theming & localization & entities**
   *Theme options; i18n plumbing; entity hooks & previews.*
   **Refs:** Theming; Localization; Entities. ([OpenAI GitHub Pages][11])

8. **Example app & docs**
   *End‑to‑end demo; README; migration guide.*

---

### Quick links used in this plan

* **ChatKit JS: Methods / Events / Client Tools / Custom Backends / Authentication / Theming / Entities / Localization**: ([OpenAI GitHub Pages][1])
* **ChatKit Python: Server Integration / Actions / Widgets reference**: ([OpenAI GitHub Pages][3])
* **License (Apache‑2.0) for JS repo**: ([GitHub][8])

---

## Coach note (optional)

This gives you a clean sprint path. If energy dips, ship M2–M7 first (streaming + core widgets + actions). That already unlocks a killer **Coach** experience. Then layer in P2/P3 widgets, theming, entities. Momentum > perfection.

[1]: https://openai.github.io/chatkit-js/guides/methods "Methods | OpenAI Agent Embeds"
[2]: https://openai.github.io/chatkit-js/guides/events "Events | OpenAI Agent Embeds"
[3]: https://openai.github.io/chatkit-python/server/ "Server Integration - Chatkit Python SDK"
[4]: https://openai.github.io/chatkit-python/widgets/ "Widgets - Chatkit Python SDK"
[5]: https://openai.github.io/chatkit-js/guides/custom-backends "Custom backends | OpenAI Agent Embeds"
[6]: https://openai.github.io/chatkit-js/guides/client-tools "Client tools | OpenAI Agent Embeds"
[7]: https://openai.github.io/chatkit-js/guides/entities "Entity tagging | OpenAI Agent Embeds"
[8]: https://github.com/openai/chatkit-js "GitHub - openai/chatkit-js"
[9]: https://openai.github.io/chatkit-js/guides/authentication "Authentication | OpenAI Agent Embeds"
[10]: https://openai.github.io/chatkit-python/actions/ "Actions - Chatkit Python SDK"
[11]: https://openai.github.io/chatkit-js/guides/theming-customization "Theming and customization | OpenAI Agent Embeds"
[12]: https://openai.github.io/chatkit-js/guides/localization "Localization | OpenAI Agent Embeds"
</file>

<file path="README.md">
# ChatKit Dart

ChatKit Dart is a full port of the [ChatKit JS client](https://github.com/openai/chatkit-js) designed for Flutter and pure Dart environments. It mirrors the JS API surface, integrates with the `chatkit-python` backend, and ships native Flutter UI widgets that render the ChatKit widgets DSL—no WebView required.

## Packages

- [`chatkit_core`](packages/chatkit_core): Protocol models, controller, streaming transport, attachments, client tools, entities, history helpers.
- [`chatkit_flutter`](packages/chatkit_flutter): Native Flutter UI (composer, history, widgets DSL, entity tagging, thread actions).
- [`packages/examples/coach_demo`](packages/examples/coach_demo): Runnable Flutter app demonstrating the full surface against a ChatKit-compatible backend.

## Getting started

### Install from source

Add the packages to your `pubspec.yaml`:

```yaml
dependencies:
  chatkit_core:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_core
  chatkit_flutter:
    git:
      url: https://github.com/diwakarmoturu/chatkit-dart
      path: packages/chatkit_flutter
```

Fetch dependencies with `flutter pub get` or `dart pub get` depending on the target.

### Quick usage

See the package READMEs for detailed instructions. A minimal Flutter integration looks like:

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: const CustomApiConfig(url: 'https://your-backend/chatkit'),
    history: const HistoryOption(enabled: true),
    threadItemActions: const ThreadItemActionsOption(feedback: true, retry: true, share: true),
  ),
);

class ChatScreen extends StatelessWidget {
  const ChatScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return Scaffold(body: ChatKitView(controller: controller));
  }
}
```

For a complete app explore the [Coach Demo](packages/examples/coach_demo).

### Migration

Refer to [MIGRATION.md](MIGRATION.md) for a JS -> Dart mapping table covering options, methods, and events.

## Documentation

- [Parity matrix](docs/parity_matrix.md) – current JS ↔ Dart feature coverage.
- [Usage guides](docs/usage_guides.md) – theming, localization, history, entities, attachments, and hosted-mode tips.
- [Widget property coverage](docs/widget_property_coverage.md) – DSL property support mapped to Flutter implementations.

## Development

- Run `dart test packages/chatkit_core`
- Run `flutter test packages/chatkit_flutter`
- Run `dart analyze`

Golden baselines live under `packages/chatkit_flutter/test/golden/goldens`. Update them with:

```sh
flutter test packages/chatkit_flutter/test/golden/widget_dsl_golden_test.dart --update-goldens
```

Additional tasks and roadmap are tracked in [`plan.md`](plan.md).

## License

Apache-2.0. See [LICENSE](LICENSE).
</file>

<file path="docs/usage_guides.md">
# Usage Guides

This document collects the most commonly requested configuration patterns for
the Dart/Flutter port of ChatKit. Each section mirrors behaviour documented for
the JS SDK and highlights the equivalent Dart surface.

## Localization & Theming

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: const CustomApiConfig(url: 'https://example.com/chatkit'),
    localization: const LocalizationOption(
      defaultLocale: 'en',
      bundles: {
        'es': {
          'history_title': 'Historial',
          'share_option_copy': 'Copiar al portapapeles',
        },
      },
      loader: loadLocaleBundle, // async loader for additional locales
      pluralResolver: resolvePlural, // optional plural rules
    ),
    theme: const ThemeOption(
      color: ThemeColorOptions(
        accent: AccentColorOptions(primary: '#2563eb'),
        surface: SurfaceColorOptions(tertiary: '#f8fafc'),
      ),
      typography: ThemeTypographyOptions(
        fontFamily: 'Inter',
        codeFontFamily: 'JetBrains Mono',
      ),
      components: ThemeComponentOptions(
        composer: ComponentThemeOptions(
          radius: 16,
          elevation: 2,
        ),
      ),
      breakpoints: ThemeBreakpointOptions(
        compactMaxWidth: 520,
        mediumMaxWidth: 960,
      ),
      colorScheme: ColorSchemeOption.system,
    ),
  ),
);
```

- `LocalizationOption.loader` lets you lazy-load bundles; decoded strings flow
  through `ChatKitLocalizations` and support interpolation (`{placeholder}`).
- `ChatKitOptions.locale` is forwarded as the `Accept-Language` header on API
  requests so server-side rendering and strings stay in sync with the active
  Flutter locale.
- When `colorScheme` is `ColorSchemeOption.system`, the view automatically
  tracks the platform brightness and rebinds colors in real time.
- Component tokens (`ComponentThemeOptions`) provide a single place to override
  radius, elevation, and palettes for individual surfaces (composer, cards,
  banners, etc.).

## History, Entities & Composer

```dart
final controller = ChatKitController(
  ChatKitOptions(
    history: const HistoryOption(
      enabled: true,
      showDelete: true,
      showRename: true,
      sections: [
        HistorySection.pinned,
        HistorySection.recent,
        HistorySection.shared,
      ],
    ),
    entities: EntitiesOption(
      onTagSearch: fetchEntities,
      onClick: (entity) => debugPrint('Tapped ${entity.title}'),
      onRequestPreview: (entity) async => EntityPreview(
        preview: buildEntityPreview(entity),
      ),
      keyboardShortcuts: const EntityKeyboardShortcuts(
        focusComposer: 'meta+k',
        openPicker: 'meta+e',
      ),
    ),
    composer: ComposerOption(
      attachments: const ComposerAttachmentOption(
        enabled: true,
        accept: ['application/pdf', 'image/*'],
        maxFiles: 6,
      ),
      models: const [
        ModelOption(id: 'gpt-4o', label: 'GPT-4o', defaultSelected: true),
        ModelOption(id: 'gpt-4o-mini', label: 'GPT-4o mini'),
      ],
      tools: const [
        ToolOption(
          id: 'browser',
          label: 'Browser',
          description: 'Search the web for updated info',
          placeholderOverride: 'Search for…',
        ),
      ],
    ),
  ),
);
```

- History sections (Pinned/Recent/Shared) mirror JS behaviour, including search,
  infinite scroll skeletons, and pinned threads.
- Entity picker supports keyboard navigation (`↑/↓/Enter`), tooltip previews,
  streaming suggestions, and keyboard reorder/remove events by default.
- Composer chips inherit keyboard shortcuts and pin front-of-row tool trays like
  the JS client. Inline tag suggestions appear as you type `@`.

## Attachments & Share Targets

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: CustomApiConfig(
      url: 'https://example.com/chatkit',
      uploadStrategy: const TwoPhaseUploadStrategy(),
      headersBuilder: (request) => {'x-team': 'coach'},
    ),
    threadItemActions: ThreadItemActionsOption(
      share: true,
      shareActions: ShareActionsOption(
        targets: const [
          ShareTargetOption(
            id: 'copy',
            label: 'Copy to clipboard',
            type: ShareTargetType.copy,
          ),
          ShareTargetOption(
            id: 'handoff',
            label: 'Send to CRM',
            description: 'Create a follow-up task',
            type: ShareTargetType.custom,
            toast: 'Sent to CRM.',
          ),
        ],
        onSelectTarget: handleCustomShare,
      ),
    ),
  ),
);
```

- Drag-and-drop, type validation, progress indicators, retry, and cancel state
  match JS parity. The default copy/share flows surface SnackBars consistent
  with `share_toast_*` localization entries.
- For drag/drop heavy canvases (desktop/iPad) set
  `ComposerAttachmentOption(dropTarget: true)` to tighten the overlay radius.
- Share targets fall back to the default copy/system targets when no custom
  list is supplied. Use `onSelectTarget` to dispatch to your own integrations.

## Hosted Mode Resilience

```dart
final controller = ChatKitController(
  ChatKitOptions(
    api: HostedApiConfig(
      clientToken: initialClientToken,
      getClientSecret: fetchClientSecret,
    ),
    hostedHooks: HostedHooksOption(
      onAuthExpired: () => showBanner('Session expired. Sign in again.'),
      onAuthRestored: () => hideBanner(),
      onStaleClient: refreshState,
    ),
    transport: const TransportOption(
      keepAliveTimeout: Duration(seconds: 20),
      initialBackoff: Duration(milliseconds: 200),
      maxBackoff: Duration(seconds: 2),
    ),
  ),
);
```

- `onAuthExpired` and `onAuthRestored` mirror JS hosted-mode hooks and automatically
  disable/enable the composer. The controller also emits `ChatKitAuthExpiredEvent`.
- Server-issued `retry` hints (SSE `retry:` lines) are honoured and surfaced via
  `ChatKitLogEvent(name: 'transport.retry', data: {'server_hint_ms': ...})`.
- The hosted mode banner queue renders rate-limit notices, stale client handshakes,
  and unauthorized states using the same strings as JS.
- You can observe the structured `chatkit.log` channel via the new
  `ChatKitOptions.onLog` callback in addition to listening to `ChatKitLogEvent`
  on the controller `events` stream.

## Testing Recipes

- Golden/widget coverage lives in
  `packages/chatkit_flutter/test/golden/widget_dsl_golden_test.dart` with baselines
  under `test/golden/goldens/`.
- SSE fixture permutations are defined in
  `packages/chatkit_core/test/fixtures/streaming_fixture.dart` and exercised by
  `streaming_fixture_test.dart` and `sse_client_test.dart`.
- Transport retry, offline queue, and share workflows are verified end-to-end in
  `transport_retry_test.dart`, `offline_queue_test.dart`, and
  `chatkit_view_test.dart`.
</file>

<file path="packages/chatkit_core/lib/src/api/sse_client.dart">
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;

import '../errors.dart';
import '../utils/json.dart';

class SseMessage {
  SseMessage({
    this.event,
    this.id,
    this.data,
    this.retry,
  });

  final String? event;
  final String? id;
  final String? data;
  final Duration? retry;
}

typedef SseMessageHandler = FutureOr<void> Function(SseMessage message);

class SseClient {
  SseClient({http.Client? httpClient})
      : _httpClient = httpClient ?? http.Client();

  final http.Client _httpClient;
  StreamSubscription<String>? _activeResponseSubscription;
  StreamSubscription<SseMessage>? _activeMessageSubscription;
  StreamController<SseMessage>? _activeController;

  Future<void> post(
    Uri uri, {
    required Map<String, Object?> body,
    Map<String, String>? headers,
    required SseMessageHandler onMessage,
    void Function(Object error, StackTrace stackTrace)? onError,
    void Function()? onDone,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Future<http.StreamedResponse> Function(http.Request request)? sendOverride,
  }) async {
    final request = http.Request('POST', uri)
      ..headers.addAll({
        HttpHeaders.contentTypeHeader: 'application/json',
        if (headers != null) ...headers,
      })
      ..body = jsonEncode(body);

    http.StreamedResponse? response;
    _activeController?.close();
    _activeController = null;
    try {
      if (sendOverride != null) {
        response = await sendOverride(request);
      } else {
        response = await _httpClient.send(request);
      }
    } catch (error, stackTrace) {
      onError?.call(error, stackTrace);
      rethrow;
    }

    if (response.statusCode < 200 || response.statusCode >= 300) {
      final bytes = await response.stream.toBytes();
      final text = bytes.isEmpty ? '' : utf8.decode(bytes);
      Map<String, Object?>? errorPayload;
      if (text.isNotEmpty) {
        try {
          final decoded = jsonDecode(text);
          if (decoded is Map<String, Object?>) {
            errorPayload = castMap(decoded);
          }
        } catch (_) {
          // Ignore decoding errors; fall back to null payload.
        }
      }
      onError?.call(
        ChatKitServerException(
          'Request failed with status ${response.statusCode}',
          statusCode: response.statusCode,
          error: errorPayload,
        ),
        StackTrace.current,
      );
      return;
    }

    final contentType = response.headers[HttpHeaders.contentTypeHeader];
    if (contentType == null || !contentType.contains('text/event-stream')) {
      final bytes = await response.stream.toBytes();
      final text = utf8.decode(bytes);
      onError?.call(
        HttpException(
          'Expected text/event-stream response, got $contentType with body: $text',
          uri: uri,
        ),
        StackTrace.current,
      );
      return;
    }

    final controller = StreamController<SseMessage>();
    _activeController = controller;
    Timer? keepAliveTimer;
    bool streamClosed = false;

    void cancelTimer() {
      keepAliveTimer?.cancel();
      keepAliveTimer = null;
    }

    late final StreamSubscription<String> responseSubscription;
    _activeResponseSubscription = null;

    void resetTimer() {
      if (keepAliveTimeout == null) {
        return;
      }
      cancelTimer();
      keepAliveTimer = Timer(keepAliveTimeout, () {
        final timeout = TimeoutException(
          'SSE keepalive timed out after ${keepAliveTimeout.inSeconds}s',
          keepAliveTimeout,
        );
        onKeepAliveTimeout?.call();
        if (!controller.isClosed) {
          controller.addError(timeout, StackTrace.current);
          _builder = _SseMessageBuilder();
          controller.close();
        }
        unawaited(responseSubscription.cancel());
      });
    }

    responseSubscription = response.stream
        .transform(utf8.decoder)
        .transform(const LineSplitter())
        .listen(
      (line) {
        resetTimer();
        _handleLine(line, controller);
      },
      onError: (Object error, StackTrace stackTrace) {
        cancelTimer();
        onError?.call(error, stackTrace);
        if (!controller.isClosed) {
          controller.addError(error, stackTrace);
          controller.close();
        }
        unawaited(responseSubscription.cancel());
      },
      onDone: () {
        cancelTimer();
        final message = _builder.build();
        if (message != null) {
          controller.add(message);
        }
        _builder = _SseMessageBuilder();
        streamClosed = true;
        controller.close();
        onDone?.call();
      },
      cancelOnError: true,
    );
    _activeResponseSubscription = responseSubscription;

    resetTimer();

    final messageSubscription = controller.stream.listen(
      (message) async {
        if (message.retry != null) {
          onRetrySuggested?.call(message.retry!);
        }
        final eventName = message.event?.toLowerCase();
        final data = message.data?.trim().toLowerCase();
        if (eventName == 'ping' ||
            eventName == 'heartbeat' ||
            data == 'ping' ||
            data == 'pong' ||
            data == 'heartbeat') {
          return;
        }
        await Future<void>.value(onMessage(message));
      },
      onError: (error, stackTrace) {
        cancelTimer();
        onError?.call(error, stackTrace);
      },
      onDone: () {
        cancelTimer();
        if (!streamClosed) {
          controller.close();
        }
      },
      cancelOnError: true,
    );
    _activeMessageSubscription = messageSubscription;
    try {
      await messageSubscription.asFuture<void>();
    } finally {
      _activeMessageSubscription = null;
    }

    await responseSubscription.cancel();
    _activeResponseSubscription = null;
    cancelTimer();
    _activeController = null;
  }

  void cancelActive() {
    _activeResponseSubscription?.cancel();
    _activeResponseSubscription = null;
    _activeMessageSubscription?.cancel();
    _activeMessageSubscription = null;
    final controller = _activeController;
    if (controller != null && !controller.isClosed) {
      controller.close();
    }
    _activeController = null;
  }

  void _handleLine(String line, StreamController<SseMessage> controller) {
    if (line.isEmpty) {
      final message = _builder.build();
      if (message != null) {
        controller.add(message);
      }
      _builder = _SseMessageBuilder();
      return;
    }

    if (line.startsWith(':')) {
      return;
    }

    final separatorIndex = line.indexOf(':');
    String field;
    String value;
    if (separatorIndex == -1) {
      field = line;
      value = '';
    } else {
      field = line.substring(0, separatorIndex);
      value = line.substring(separatorIndex + 1);
      if (value.startsWith(' ')) {
        value = value.substring(1);
      }
    }

    switch (field) {
      case 'event':
        _builder.event = value;
        break;
      case 'data':
        _builder.addData(value);
        break;
      case 'id':
        _builder.id = value;
        break;
      case 'retry':
        final retry = int.tryParse(value);
        if (retry != null) {
          _builder.retry = Duration(milliseconds: retry);
        }
        break;
    }
  }

  _SseMessageBuilder _builder = _SseMessageBuilder();
}

class _SseMessageBuilder {
  String? event;
  String? id;
  Duration? retry;
  final StringBuffer _data = StringBuffer();

  void addData(String value) {
    if (_data.isNotEmpty) {
      _data.write('\n');
    }
    _data.write(value);
  }

  SseMessage? build() {
    if (event == null && id == null && _data.isEmpty) {
      return null;
    }
    return SseMessage(
      event: event,
      id: id,
      data: _data.isEmpty ? null : _data.toString(),
      retry: retry,
    );
  }
}
</file>

<file path="packages/chatkit_core/lib/src/models/attachments.dart">
import 'package:meta/meta.dart';

@immutable
sealed class ChatKitAttachment {
  const ChatKitAttachment({
    required this.id,
    required this.name,
    required this.mimeType,
    this.uploadUrl,
    this.size,
    this.uploadMethod,
    this.uploadFields,
    this.uploadHeaders,
  });

  final String id;
  final String name;
  final String mimeType;
  final String? uploadUrl;
  final int? size;
  final String? uploadMethod;
  final Map<String, String>? uploadFields;
  final Map<String, String>? uploadHeaders;

  String get type;

  Map<String, Object?> toJson();

  static ChatKitAttachment fromJson(Map<String, Object?> json) {
    final type = json['type'] as String? ?? 'file';
    final size = _parseSize(json['size'] ?? json['file_size']);
    final uploadMethod = _string(json['upload_method']);
    final uploadFields = _stringMap(json['upload_fields']);
    final uploadHeaders = _stringMap(json['upload_headers']);
    switch (type) {
      case 'image':
        return ImageAttachment(
          id: json['id'] as String,
          name: json['name'] as String,
          mimeType: json['mime_type'] as String? ??
              json['mimeType'] as String? ??
              'application/octet-stream',
          previewUrl: json['preview_url'] as String? ??
              json['preview'] as String? ??
              '',
          uploadUrl: json['upload_url'] as String?,
          size: size,
          uploadMethod: uploadMethod,
          uploadFields: uploadFields,
          uploadHeaders: uploadHeaders,
        );
      default:
        return FileAttachment(
          id: json['id'] as String,
          name: json['name'] as String,
          mimeType: json['mime_type'] as String? ??
              json['mimeType'] as String? ??
              'application/octet-stream',
          uploadUrl: json['upload_url'] as String?,
          size: size,
          uploadMethod: uploadMethod,
          uploadFields: uploadFields,
          uploadHeaders: uploadHeaders,
        );
    }
  }
}

class FileAttachment extends ChatKitAttachment {
  const FileAttachment({
    required super.id,
    required super.name,
    required super.mimeType,
    super.uploadUrl,
    super.size,
    super.uploadMethod,
    super.uploadFields,
    super.uploadHeaders,
  });

  @override
  String get type => 'file';

  @override
  Map<String, Object?> toJson() => {
        'type': type,
        'id': id,
        'name': name,
        'mime_type': mimeType,
        if (size != null) 'size': size,
        if (uploadUrl != null) 'upload_url': uploadUrl,
      };
}

class ImageAttachment extends ChatKitAttachment {
  const ImageAttachment({
    required super.id,
    required super.name,
    required super.mimeType,
    required this.previewUrl,
    super.uploadUrl,
    super.size,
    super.uploadMethod,
    super.uploadFields,
    super.uploadHeaders,
  });

  final String previewUrl;

  @override
  String get type => 'image';

  @override
  Map<String, Object?> toJson() => {
        'type': type,
        'id': id,
        'name': name,
        'mime_type': mimeType,
        'preview_url': previewUrl,
        if (size != null) 'size': size,
        if (uploadUrl != null) 'upload_url': uploadUrl,
      };
}

int? _parseSize(Object? raw) {
  if (raw == null) {
    return null;
  }
  if (raw is num) {
    return raw.round();
  }
  if (raw is String) {
    return int.tryParse(raw);
  }
  return null;
}

String? _string(Object? value) {
  if (value == null) {
    return null;
  }
  if (value is String) {
    return value;
  }
  return value.toString();
}

Map<String, String>? _stringMap(Object? value) {
  if (value == null) {
    return null;
  }
  if (value is Map) {
    final map = <String, String>{};
    value.forEach((key, entryValue) {
      final keyString = _string(key);
      final valueString = _string(entryValue);
      if (keyString != null && valueString != null) {
        map[keyString] = valueString;
      }
    });
    return map.isEmpty ? null : map;
  }
  return null;
}
</file>

<file path="packages/chatkit_core/lib/src/models/entities.dart">
import 'package:meta/meta.dart';

@immutable
class Entity {
  const Entity({
    required this.id,
    required this.title,
    this.icon,
    this.interactive,
    this.group,
    this.data = const {},
  });

  final String id;
  final String title;
  final String? icon;
  final bool? interactive;
  final String? group;
  final Map<String, Object?> data;

  factory Entity.fromJson(Map<String, Object?> json) => Entity(
        id: json['id'] as String,
        title: (json['title'] as String?) ?? (json['label'] as String?) ?? '',
        icon: json['icon'] as String?,
        interactive: json['interactive'] as bool?,
        group: json['group'] as String?,
        data: Map<String, Object?>.from(
          (json['data'] as Map?) ??
              (json['metadata'] as Map?) ??
              const <String, Object?>{},
        ),
      );

  Map<String, Object?> toJson() => {
        'id': id,
        'title': title,
        if (icon != null) 'icon': icon,
        if (interactive != null) 'interactive': interactive,
        if (group != null) 'group': group,
        if (data.isNotEmpty) 'data': data,
      };

  @Deprecated('Use title')
  String get label => title;

  @Deprecated('Use data')
  Map<String, Object?> get metadata => data;
}

@immutable
class EntityPreview {
  const EntityPreview({
    required this.preview,
  });

  final Map<String, Object?>? preview;

  factory EntityPreview.fromJson(Map<String, Object?> json) => EntityPreview(
        preview: json['preview'] as Map<String, Object?>?,
      );

  Map<String, Object?> toJson() => {
        'preview': preview,
      };
}
</file>

<file path="packages/chatkit_core/lib/src/models/page.dart">
import 'package:meta/meta.dart';

import '../utils/json.dart';

@immutable
class Page<T> {
  const Page({
    required this.data,
    this.hasMore = false,
    this.after,
  });

  final List<T> data;
  final bool hasMore;
  final String? after;

  factory Page.fromJson(
    Map<String, Object?> json,
    T Function(Map<String, Object?> json) factory,
  ) {
    final items = (json['data'] as List?)?.map((entry) {
          return factory(castMap(entry));
        }).toList() ??
        const [];
    return Page<T>(
      data: items,
      hasMore: json['has_more'] as bool? ?? false,
      after: json['after'] as String?,
    );
  }

  Map<String, Object?> toJson(Object? Function(T value) encoder) => {
        'data': data.map(encoder).toList(),
        'has_more': hasMore,
        if (after != null) 'after': after,
      };
}
</file>

<file path="packages/chatkit_core/lib/src/models/widgets.dart">
import 'package:meta/meta.dart';

import '../utils/json.dart';

@immutable
class WidgetRoot {
  const WidgetRoot({
    required this.type,
    this.id,
    this.key,
    this.props = const {},
    this.children = const [],
  });

  final String type;
  final String? id;
  final String? key;
  final Map<String, Object?> props;
  final List<WidgetComponent> children;

  factory WidgetRoot.fromJson(Map<String, Object?> json) {
    return WidgetRoot(
      type: json['type'] as String? ?? 'unknown',
      id: json['id'] as String?,
      key: json['key'] as String?,
      props: castMap(json['props']),
      children: (json['children'] as List?)
              ?.map((child) => WidgetComponent.fromJson(castMap(child)))
              .toList(growable: false) ??
          const [],
    );
  }

  Map<String, Object?> toJson() => {
        'type': type,
        if (id != null) 'id': id,
        if (key != null) 'key': key,
        if (props.isNotEmpty) 'props': props,
        if (children.isNotEmpty)
          'children': children.map((child) => child.toJson()).toList(),
      };
}

@immutable
class WidgetComponent {
  const WidgetComponent({
    required this.type,
    this.id,
    this.key,
    this.props = const {},
    this.children = const [],
  });

  final String type;
  final String? id;
  final String? key;
  final Map<String, Object?> props;
  final List<WidgetComponent> children;

  factory WidgetComponent.fromJson(Map<String, Object?> json) {
    return WidgetComponent(
      type: json['type'] as String? ?? 'unknown',
      id: json['id'] as String?,
      key: json['key'] as String?,
      props: castMap(json['props']),
      children: (json['children'] as List?)
              ?.map((child) => WidgetComponent.fromJson(castMap(child)))
              .toList(growable: false) ??
          const [],
    );
  }

  Map<String, Object?> toJson() => {
        'type': type,
        if (id != null) 'id': id,
        if (key != null) 'key': key,
        if (props.isNotEmpty) 'props': props,
        if (children.isNotEmpty)
          'children': children.map((child) => child.toJson()).toList(),
      };
}
</file>

<file path="packages/chatkit_core/lib/src/utils/json.dart">
DateTime? parseDateTime(Object? value) {
  if (value is DateTime) {
    return value.toUtc();
  }
  if (value is String && value.isNotEmpty) {
    return DateTime.tryParse(value)?.toUtc();
  }
  return null;
}

Map<String, Object?> castMap(Object? value) {
  if (value is Map<String, Object?>) {
    return value;
  }
  if (value is Map) {
    return value.map(
      (key, value) => MapEntry(key.toString(), value as Object?),
    );
  }
  return {};
}

List<Map<String, Object?>> castListOfMaps(Object? value) {
  if (value is List) {
    return value.map((entry) => castMap(entry)).toList(growable: false);
  }
  return const [];
}
</file>

<file path="packages/chatkit_core/lib/src/errors.dart">
/// Base class for ChatKit related failures.
class ChatKitException implements Exception {
  ChatKitException(this.message, {this.cause});

  final String message;
  final Object? cause;

  @override
  String toString() =>
      'ChatKitException($message${cause != null ? ', cause: $cause' : ''})';
}

/// Thrown when the server responds with an error payload.
class ChatKitServerException extends ChatKitException {
  ChatKitServerException(
    super.message, {
    super.cause,
    this.statusCode,
    this.error,
  });

  final int? statusCode;
  final Map<String, Object?>? error;
}

/// Indicates that an operation cannot be performed while a response is streaming.
class ChatKitStreamingInProgressException extends ChatKitException {
  ChatKitStreamingInProgressException(String message) : super(message);
}

/// Raised when an operation is attempted while another conflicting action is running.
class ChatKitBusyException extends ChatKitException {
  ChatKitBusyException(String message) : super(message);
}

/// Raised when the API configuration is invalid.
class ChatKitConfigurationException extends ChatKitException {
  ChatKitConfigurationException(String message) : super(message);
}
</file>

<file path="packages/chatkit_core/lib/chatkit_core.dart">
library chatkit_core;

export 'src/chatkit_controller.dart';
export 'src/options.dart';
export 'src/events/events.dart';
export 'src/models/models.dart';
export 'src/actions/client_tools.dart';
export 'src/errors.dart';
</file>

<file path="packages/chatkit_core/test/hosted_resilience_test.dart">
import 'dart:async';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

class _NoopApiClient extends ChatKitApiClient {
  _NoopApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chatkit'),
        );

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {}
}

class _FailingApiClient extends ChatKitApiClient {
  _FailingApiClient(this.statusCode)
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chatkit'),
        );

  final int statusCode;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    throw ChatKitServerException(
      'failure',
      statusCode: statusCode,
      error: const {'code': 'auth_expired'},
    );
  }
}

class _FailThenSucceedApiClient extends ChatKitApiClient {
  _FailThenSucceedApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chatkit'),
        );

  bool _failedOnce = false;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (!_failedOnce) {
      _failedOnce = true;
      throw ChatKitServerException(
        'failure',
        statusCode: 401,
        error: const {'code': 'auth_expired'},
      );
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {}
}

void main() {
  test('stale client notice triggers handshake and restores composer',
      () async {
    var staleCalls = 0;
    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com/chatkit'),
        hostedHooks: HostedHooksOption(
          onStaleClient: () => staleCalls += 1,
        ),
      ),
      apiClient: _NoopApiClient(),
    );

    final events = <ChatKitEvent>[];
    final sub = controller.events.listen(events.add);

    controller.debugHandleStreamEvent(
      NoticeEvent(
        message: 'client stale',
        level: 'warning',
        code: 'stale_client',
        data: const {},
        title: null,
      ),
    );

    await Future<void>.delayed(const Duration(milliseconds: 20));

    expect(
      events.whereType<ChatKitNoticeEvent>().map((event) => event.code),
      contains('stale_client'),
    );
    final availabilityEvents =
        events.whereType<ChatKitComposerAvailabilityEvent>().toList();
    expect(availabilityEvents, isNotEmpty);
    expect(availabilityEvents.first.available, isFalse);
    expect(availabilityEvents.last.available, isTrue);
    expect(staleCalls, 1);

    await sub.cancel();
    await controller.dispose();
  });

  test('auth expiry hook invoked on 401 and restored after refreshing',
      () async {
    var expiredCalls = 0;
    var restoredCalls = 0;
    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com/chatkit'),
        hostedHooks: HostedHooksOption(
          onAuthExpired: () => expiredCalls += 1,
          onAuthRestored: () => restoredCalls += 1,
        ),
      ),
      apiClient: _FailingApiClient(401),
    );

    await expectLater(
      controller.listThreads(),
      throwsA(isA<ChatKitServerException>()),
    );
    await Future<void>.delayed(const Duration(milliseconds: 10));
    expect(expiredCalls, 1);
    expect(restoredCalls, 0);

    controller.debugHandleStreamEvent(
      NoticeEvent(
        message: 'client stale',
        level: 'warning',
        code: 'stale_client',
        data: const {},
        title: null,
      ),
    );
    await Future<void>.delayed(const Duration(milliseconds: 10));
    expect(restoredCalls, 1);

    await controller.dispose();
  });

  test('auth restore hook fires on next successful request without notice',
      () async {
    var expiredCalls = 0;
    var restoredCalls = 0;
    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com/chatkit'),
        hostedHooks: HostedHooksOption(
          onAuthExpired: () => expiredCalls += 1,
          onAuthRestored: () => restoredCalls += 1,
        ),
      ),
      apiClient: _FailThenSucceedApiClient(),
    );

    await expectLater(
      controller.listThreads(),
      throwsA(isA<ChatKitServerException>()),
    );
    expect(expiredCalls, 1);
    expect(restoredCalls, 0);

    final page = await controller.listThreads();
    expect(page.data, isEmpty);
    expect(restoredCalls, 1);

    await controller.dispose();
  });
}
</file>

<file path="packages/chatkit_core/test/streaming_fixture_test.dart">
import 'dart:async';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

import 'fixtures/streaming_fixture.dart';

class _NoopApiClient extends ChatKitApiClient {
  _NoopApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );
}

void main() {
  test('applies streaming fixture updates and emits response lifecycle events',
      () async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final events = <ChatKitEvent>[];
    final sub = controller.events.listen(events.add);
    addTearDown(() => sub.cancel());

    for (final json in streamingFixtureEvents()) {
      controller.debugHandleStreamEvent(ThreadStreamEvent.fromJson(json));
    }

    await Future<void>.delayed(Duration.zero);

    final assistant = controller.threadItemById('msg_assistant');
    expect(assistant, isNotNull);

    final firstContent =
        assistant!.content.isNotEmpty ? assistant.content.first : null;
    expect(firstContent, isNotNull);
    expect(firstContent!['text'], 'Hello athlete! Here is your summary.');

    final annotations = firstContent['annotations'];
    expect(annotations, isA<List>());
    final annotationIds = (annotations as List)
        .whereType<Map>()
        .map((entry) => entry['file_id'])
        .toList();
    expect(annotationIds, contains('file_weekly_plan'));

    final widgetJson = (assistant.raw['widget'] as Map).cast<String, Object?>();
    final children = (widgetJson['children'] as List)
        .map((child) => (child as Map).cast<String, Object?>())
        .toList();
    final streamText = children.firstWhere(
      (child) => child['id'] == 'stream_text',
      orElse: () => {},
    );
    expect(
      streamText['value'],
      'Focus: Recovery mobility\nNext: Long run Saturday',
    );
    expect(streamText['streaming'], isFalse);

    final responseStartIndex =
        events.indexWhere((event) => event is ChatKitResponseStartEvent);
    final responseEndIndex =
        events.indexWhere((event) => event is ChatKitResponseEndEvent);
    expect(responseStartIndex, isNot(-1));
    expect(responseEndIndex, isNot(-1));
    expect(responseStartIndex, lessThan(responseEndIndex));

    final progressEvents = events
        .whereType<ChatKitThreadEvent>()
        .map((event) => event.streamEvent)
        .whereType<ProgressUpdateEvent>()
        .toList();
    expect(progressEvents, hasLength(1));
    expect(progressEvents.first.text, 'Summaries compiled');
  });

  test('workflow task updates mutate workflow structure', () async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    for (final json in workflowFixtureEvents()) {
      controller.debugHandleStreamEvent(ThreadStreamEvent.fromJson(json));
    }

    final item = controller.threadItemById('workflow_item');
    expect(item, isNotNull);

    final workflow = (item!.raw['workflow'] as Map?)?.cast<String, Object?>();
    expect(workflow, isNotNull);

    final tasks = (workflow!['tasks'] as List?)?.cast<Map<String, Object?>>();
    expect(tasks, isNotNull);
    expect(tasks, isNotEmpty);

    final task = tasks!.first;
    expect(task['id'], 'task_collect_inputs');
    expect(task['status'], 'complete');
    expect(task['notes'], 'All questionnaires answered.');
  });
}
</file>

<file path="packages/chatkit_core/test/thread_event_test.dart">
import 'package:chatkit_core/chatkit_core.dart';
import 'package:test/test.dart';

void main() {
  group('ThreadStreamEvent', () {
    test('parses thread.created', () {
      final event = ThreadStreamEvent.fromJson({
        'type': 'thread.created',
        'thread': {
          'id': 'thr_123',
          'title': 'Sample',
          'created_at': '2024-01-01T00:00:00Z',
          'status': {'type': 'active'},
          'items': {
            'data': [],
            'after': null,
            'has_more': false,
          },
        },
      });

      expect(event, isA<ThreadCreatedEvent>());
      final created = event as ThreadCreatedEvent;
      expect(created.thread.metadata.id, 'thr_123');
      expect(created.thread.metadata.title, 'Sample');
    });

    test('falls back to unknown event', () {
      final event = ThreadStreamEvent.fromJson({'type': 'mystery'});
      expect(event, isA<UnknownStreamEvent>());
    });
  });
}
</file>

<file path="packages/chatkit_flutter/lib/src/theme/chatkit_theme.dart">
import 'dart:math' as math;

import 'package:chatkit_core/chatkit_core.dart';
import 'package:flutter/material.dart';

/// Core theme data for ChatKit Flutter surfaces.
///
/// This class centralises the palette, spacing, radii, typography and
/// component-level styling required to achieve visual parity with ChatKit-JS
/// while still honouring [`ThemeOption`] overrides provided by host apps.
@immutable
class ChatKitThemeData {
  const ChatKitThemeData({
    required this.materialTheme,
    required this.palette,
    required this.spacing,
    required this.radii,
    required this.typography,
    required this.components,
    required this.shadows,
  });

  final ThemeData materialTheme;
  final ChatKitPalette palette;
  final ChatKitSpacing spacing;
  final ChatKitRadii radii;
  final ChatKitTypography typography;
  final ChatKitComponentStyles components;
  final ChatKitShadows shadows;

  ChatKitThemeData copyWith({
    ThemeData? materialTheme,
    ChatKitPalette? palette,
    ChatKitSpacing? spacing,
    ChatKitRadii? radii,
    ChatKitTypography? typography,
    ChatKitComponentStyles? components,
    ChatKitShadows? shadows,
  }) {
    return ChatKitThemeData(
      materialTheme: materialTheme ?? this.materialTheme,
      palette: palette ?? this.palette,
      spacing: spacing ?? this.spacing,
      radii: radii ?? this.radii,
      typography: typography ?? this.typography,
      components: components ?? this.components,
      shadows: shadows ?? this.shadows,
    );
  }

  /// Builds a theme from the resolved [ThemeOption] provided by ChatKit core.
  ///
  /// [base] is the host theme and [platformBrightness] reflects the current
  /// system brightness, supporting `ColorSchemeOption.system`.
  factory ChatKitThemeData.fromOptions({
    required ThemeData base,
    ThemeOption? option,
    Brightness? platformBrightness,
  }) {
    final spacing = ChatKitSpacing.defaults(density: option?.density);
    final radii = ChatKitRadii.fromBase(
      option?.shapes?.radius ?? _baseRadiusForPreset(option?.radius),
    );

    final material = _resolveMaterialTheme(
      base: base,
      option: option,
      radii: radii,
      spacing: spacing,
      platformBrightness: platformBrightness,
    );

    final palette = ChatKitPalette.fromMaterial(
      material,
      option?.color?.grayscale,
    );
    final typography = ChatKitTypography.fromTheme(material.textTheme);

    final elevations = option?.elevations;
    final components = ChatKitComponentStyles(
      surface: ChatKitSurfaceStyle(
        background: material.colorScheme.surface,
        foreground: material.colorScheme.onSurface,
        border: material.colorScheme.outlineVariant,
        elevation: elevations?.surface ?? 0,
        radius: radii.card,
      ),
      composer: _surfaceFromOptions(
        base: ChatKitSurfaceStyle(
          background: material.colorScheme.surface,
          foreground: material.colorScheme.onSurface,
          border: material.colorScheme.outlineVariant,
          elevation: elevations?.composer ?? 6,
          radius: radii.composer,
        ),
        overrides: option?.components?.composer,
      ),
      history: _surfaceFromOptions(
        base: ChatKitSurfaceStyle(
          background: palette.surfaceContainerHigh,
          foreground: material.colorScheme.onSurface,
          border: material.colorScheme.outlineVariant,
          elevation: elevations?.history ?? 4,
          radius: radii.card,
        ),
        overrides: option?.components?.history,
      ),
      assistantBubble: _surfaceFromOptions(
        base: ChatKitSurfaceStyle(
          background: palette.surfaceContainer,
          foreground: material.colorScheme.onSurface,
          border: palette.borderMuted,
          elevation: elevations?.assistantBubble ?? 0,
          radius: radii.messageBubble,
        ),
        overrides: option?.components?.assistantBubble,
      ),
      userBubble: _surfaceFromOptions(
        base: ChatKitSurfaceStyle(
          background: palette.primaryStrong,
          foreground: palette.onPrimaryStrong,
          border: palette.primaryStrongBorder,
          elevation: elevations?.userBubble ?? 0,
          radius: radii.messageBubble,
        ),
        overrides: option?.components?.userBubble,
      ),
    );

    final shadows = ChatKitShadows.defaults(palette);

    return ChatKitThemeData(
      materialTheme: material,
      palette: palette,
      spacing: spacing,
      radii: radii,
      typography: typography,
      components: components,
      shadows: shadows,
    );
  }

  static ThemeData _resolveMaterialTheme({
    required ThemeData base,
    required ChatKitRadii radii,
    required ChatKitSpacing spacing,
    ThemeOption? option,
    Brightness? platformBrightness,
  }) {
    ThemeData material;
    switch (option?.colorScheme) {
      case ColorSchemeOption.dark:
        material = ThemeData(
          brightness: Brightness.dark,
          useMaterial3: false,
        );
        break;
      case ColorSchemeOption.light:
        material = ThemeData(
          brightness: Brightness.light,
          useMaterial3: false,
        );
        break;
      case ColorSchemeOption.system:
        final brightness = platformBrightness ?? base.brightness;
        material = ThemeData(
          brightness: brightness,
          useMaterial3: false,
        );
        break;
      case null:
        material = base.copyWith(useMaterial3: false);
        break;
    }

    material = material.copyWith(
      visualDensity: _visualDensityForOption(option?.density),
    );

    var scheme = material.colorScheme;

    final accent = option?.color?.accent;
    if (accent != null) {
      final primaryAccent = _parseColor(accent.primary);
      final adjustedPrimary =
          _applyAccentLevel(primaryAccent, accent.level) ?? primaryAccent;
      scheme = scheme.copyWith(
        primary: adjustedPrimary ?? scheme.primary,
        onPrimary: _parseColor(accent.onPrimary) ?? scheme.onPrimary,
        secondary: _parseColor(accent.secondary) ?? scheme.secondary,
        onSecondary: _parseColor(accent.onSecondary) ?? scheme.onSecondary,
      );
    }

    final surface = option?.color?.surface;
    Color? scaffoldBackground;
    Color? canvasColor;
    if (surface != null) {
      final primarySurface = _parseColor(surface.primary);
      final secondarySurface = _parseColor(surface.secondary);
      final tertiarySurface = _parseColor(surface.tertiary);
      final quaternarySurface = _parseColor(surface.quaternary);
      final backgroundSurface = _parseColor(surface.background);
      final foregroundSurface = _parseColor(surface.foreground);
      scheme = scheme.copyWith(
        surface: primarySurface ?? backgroundSurface ?? scheme.surface,
        surfaceTint: secondarySurface ?? scheme.surfaceTint,
        onSurface: foregroundSurface ?? scheme.onSurface,
      );
      scaffoldBackground =
          tertiarySurface ?? primarySurface ?? backgroundSurface;
      canvasColor = quaternarySurface;
    }

    material = material.copyWith(
      colorScheme: scheme,
      scaffoldBackgroundColor:
          scaffoldBackground ?? material.scaffoldBackgroundColor,
      canvasColor: canvasColor ?? material.canvasColor,
    );

    // Typography overrides.
    final typography = option?.typography;
    if (typography != null) {
      TextTheme textTheme = material.textTheme;
      TextTheme primaryTextTheme = material.primaryTextTheme;

      if (typography.fontFamily != null) {
        textTheme = textTheme.apply(fontFamily: typography.fontFamily);
        primaryTextTheme =
            primaryTextTheme.apply(fontFamily: typography.fontFamily);
      }

      final baseSize = typography.baseSize;
      if (baseSize != null && baseSize > 0) {
        final factor = baseSize / 16.0;
        textTheme = textTheme.apply(fontSizeFactor: factor);
        primaryTextTheme = primaryTextTheme.apply(fontSizeFactor: factor);
      }

      material = material.copyWith(
        textTheme: textTheme,
        primaryTextTheme: primaryTextTheme,
      );
    }

    // Shape overrides.
    final baseRadius = radii.card;
    final roundedRectangle = RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(baseRadius),
    );
    final bottomSheetRadius = RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(
        top: Radius.circular(baseRadius),
      ),
    );

    // Compose component defaults that match ChatKit-JS.
    material = material.copyWith(
      cardTheme: material.cardTheme.copyWith(
        shape: roundedRectangle,
        elevation: option?.elevations?.surface ?? 0,
        margin: EdgeInsets.zero,
        clipBehavior: Clip.antiAlias,
        surfaceTintColor: const Color(0x00000000),
      ),
      dialogTheme: material.dialogTheme.copyWith(
        shape: roundedRectangle,
        surfaceTintColor: const Color(0x00000000),
      ),
      bottomSheetTheme: material.bottomSheetTheme.copyWith(
        shape: bottomSheetRadius,
        elevation: option?.elevations?.surface ?? 8,
        backgroundColor: material.colorScheme.surface,
        surfaceTintColor: const Color(0x00000000),
      ),
      inputDecorationTheme: _inputDecorationTheme(material, spacing, radii),
      filledButtonTheme: _filledButtonTheme(material, spacing, radii),
      outlinedButtonTheme: _outlinedButtonTheme(material, spacing, radii),
      textButtonTheme: _textButtonTheme(material, spacing, radii),
      elevatedButtonTheme: _elevatedButtonTheme(material, spacing, radii),
      iconButtonTheme: _iconButtonTheme(material, radii),
      chipTheme: material.chipTheme.copyWith(
        shape: StadiumBorder(
          side: BorderSide(color: material.colorScheme.outlineVariant),
        ),
        labelPadding: EdgeInsets.symmetric(
          horizontal: spacing.xs,
          vertical: spacing.xxs,
        ),
        padding: EdgeInsets.symmetric(
          horizontal: spacing.xs,
          vertical: spacing.xxs,
        ),
      ),
      dropdownMenuTheme: material.dropdownMenuTheme.copyWith(
        inputDecorationTheme:
            _inputDecorationTheme(material, spacing, radii).copyWith(
          filled: true,
        ),
      ),
      dataTableTheme: material.dataTableTheme.copyWith(
        headingRowColor: WidgetStateProperty.all(
          material.colorScheme.surfaceContainerHighest,
        ),
        headingTextStyle: material.textTheme.labelMedium?.copyWith(
          fontWeight: FontWeight.w600,
        ),
        dataTextStyle: material.textTheme.bodyMedium,
        dividerThickness: 1,
        columnSpacing: spacing.lg,
      ),
    );

    return material;
  }

  static double _baseRadiusForPreset(ThemeRadiusOption? preset) {
    switch (preset) {
      case ThemeRadiusOption.pill:
        return 24;
      case ThemeRadiusOption.round:
        return 18;
      case ThemeRadiusOption.soft:
        return 12;
      case ThemeRadiusOption.sharp:
        return 6;
      case null:
        return 12;
    }
  }

  static VisualDensity _visualDensityForOption(ThemeDensityOption? density) {
    switch (density) {
      case ThemeDensityOption.compact:
        return VisualDensity.compact;
      case ThemeDensityOption.spacious:
        return VisualDensity.comfortable;
      case ThemeDensityOption.normal:
      case null:
        return VisualDensity.standard;
    }
  }

  static Color? _applyAccentLevel(Color? color, int? level) {
    if (color == null || level == null) {
      return color;
    }
    final int clamped = level.clamp(0, 3).toInt();
    if (clamped == 0) {
      return color;
    }
    final hsl = HSLColor.fromColor(color);
    final lightnessAdjust = 0.04 * clamped;
    final saturationAdjust = 0.02 * clamped;
    final newLightness =
        (hsl.lightness + lightnessAdjust).clamp(0.0, 1.0).toDouble();
    final newSaturation =
        (hsl.saturation - saturationAdjust).clamp(0.0, 1.0).toDouble();
    return hsl
        .withLightness(newLightness)
        .withSaturation(newSaturation)
        .toColor();
  }

  static Color _resolveGrayscaleTone({
    required GrayscaleOptions? options,
    required String? explicit,
    required double targetLightness,
    required Color fallback,
    double saturation = 0.08,
  }) {
    final parsed = _parseColor(explicit);
    if (parsed != null) {
      return parsed;
    }
    if (options?.hue != null) {
      return _grayscaleFromHue(
        options!,
        targetLightness: targetLightness,
        saturation: saturation,
      );
    }
    return fallback;
  }

  static Color _grayscaleFromHue(
    GrayscaleOptions options, {
    required double targetLightness,
    double saturation = 0.08,
  }) {
    final hue = options.hue ?? 210;
    final int tint = options.tintStep?.clamp(0, 9).toInt() ?? 4;
    final int shade = options.shade?.clamp(-4, 4).toInt() ?? 0;
    final tintOffset = (tint - 4) * 0.012;
    final shadeOffset = shade * 0.02;
    final computedLightness = (targetLightness + tintOffset - shadeOffset)
        .clamp(0.02, 0.98)
        .toDouble();
    final computedSaturation =
        (saturation + shade * 0.01).clamp(0.0, 1.0).toDouble();

    return HSLColor.fromAHSL(
      1,
      hue,
      computedSaturation,
      computedLightness,
    ).toColor();
  }

  static InputDecorationTheme _inputDecorationTheme(
    ThemeData material,
    ChatKitSpacing spacing,
    ChatKitRadii radii,
  ) {
    final baseBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(radii.field),
      borderSide: const BorderSide(color: Color(0x00000000), width: 0),
    );
    final outlineBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(radii.field),
      borderSide: BorderSide(
        color: material.colorScheme.outlineVariant,
        width: 1,
      ),
    );
    final focusBorder = OutlineInputBorder(
      borderRadius: BorderRadius.circular(radii.field),
      borderSide: BorderSide(
        color: material.colorScheme.primary,
        width: 1.5,
      ),
    );
    return InputDecorationTheme(
      filled: true,
      isDense: true,
      fillColor: material.colorScheme.surfaceContainerHigh,
      hintStyle: material.textTheme.bodyMedium?.copyWith(
        color: material.colorScheme.onSurface.withValues(alpha: 0.55),
      ),
      contentPadding: EdgeInsets.symmetric(
        horizontal: spacing.lg,
        vertical: spacing.sm,
      ),
      border: baseBorder,
      enabledBorder: outlineBorder,
      disabledBorder: baseBorder,
      focusedBorder: focusBorder,
      errorBorder: outlineBorder.copyWith(
        borderSide: BorderSide(
          color: material.colorScheme.error,
          width: 1.5,
        ),
      ),
      focusedErrorBorder: focusBorder.copyWith(
        borderSide: BorderSide(
          color: material.colorScheme.error,
          width: 1.5,
        ),
      ),
    );
  }

  static FilledButtonThemeData _filledButtonTheme(
    ThemeData material,
    ChatKitSpacing spacing,
    ChatKitRadii radii,
  ) {
    return FilledButtonThemeData(
      style: FilledButton.styleFrom(
        minimumSize: Size(spacing.xxxl, spacing.xxl),
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.button),
        ),
        textStyle: material.textTheme.labelLarge?.copyWith(
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  static OutlinedButtonThemeData _outlinedButtonTheme(
    ThemeData material,
    ChatKitSpacing spacing,
    ChatKitRadii radii,
  ) {
    return OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        minimumSize: Size(spacing.xxxl, spacing.xxl),
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        side: BorderSide(color: material.colorScheme.outlineVariant),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.button),
        ),
        textStyle: material.textTheme.labelLarge,
      ),
    );
  }

  static TextButtonThemeData _textButtonTheme(
    ThemeData material,
    ChatKitSpacing spacing,
    ChatKitRadii radii,
  ) {
    return TextButtonThemeData(
      style: TextButton.styleFrom(
        minimumSize: Size(spacing.xxxl, spacing.xxl),
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.button),
        ),
        textStyle: material.textTheme.labelLarge,
      ),
    );
  }

  static ElevatedButtonThemeData _elevatedButtonTheme(
    ThemeData material,
    ChatKitSpacing spacing,
    ChatKitRadii radii,
  ) {
    return ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        minimumSize: Size(spacing.xxxl, spacing.xxl),
        padding: EdgeInsets.symmetric(
          horizontal: spacing.lg,
          vertical: spacing.sm,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.button),
        ),
        textStyle: material.textTheme.labelLarge,
      ),
    );
  }

  static IconButtonThemeData _iconButtonTheme(
    ThemeData material,
    ChatKitRadii radii,
  ) {
    return IconButtonThemeData(
      style: IconButton.styleFrom(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(radii.icon),
        ),
        minimumSize: const Size.square(40),
        padding: EdgeInsets.zero,
        backgroundColor: const Color(0x00000000),
        foregroundColor: material.colorScheme.onSurface,
      ),
    );
  }

  static ChatKitSurfaceStyle _surfaceFromOptions({
    required ChatKitSurfaceStyle base,
    ThemeComponentStyle? overrides,
  }) {
    if (overrides == null) {
      return base;
    }
    return ChatKitSurfaceStyle(
      background: _parseColor(overrides.background) ?? base.background,
      foreground: _parseColor(overrides.text) ?? base.foreground,
      border: _parseColor(overrides.border) ?? base.border,
      elevation: overrides.elevation ?? base.elevation,
      radius: overrides.radius ?? base.radius,
    );
  }

  static Color? _parseColor(String? value) {
    if (value == null || value.isEmpty) {
      return null;
    }
    var hex = value.replaceFirst('#', '');
    if (hex.length == 6) {
      hex = 'ff$hex';
    }
    final intValue = int.tryParse(hex, radix: 16);
    if (intValue == null) {
      return null;
    }
    return Color(intValue);
  }
}

/// Inherited theme scope used to expose [ChatKitThemeData] down the tree.
class ChatKitTheme extends InheritedWidget {
  const ChatKitTheme({
    super.key,
    required this.data,
    required super.child,
  });

  final ChatKitThemeData data;

  static ChatKitThemeData of(BuildContext context) {
    final scope = context.dependOnInheritedWidgetOfExactType<ChatKitTheme>();
    assert(scope != null,
        'ChatKitTheme.of() called with no ChatKitTheme in context.');
    return scope!.data;
  }

  @override
  bool updateShouldNotify(ChatKitTheme oldWidget) => data != oldWidget.data;
}

/// Palette tokens derived from the resolved [ThemeData].
@immutable
class ChatKitPalette {
  const ChatKitPalette({
    required this.background,
    required this.surface,
    required this.surfaceAlt,
    required this.surfaceContainer,
    required this.surfaceContainerHigh,
    required this.primary,
    required this.onPrimary,
    required this.primaryStrong,
    required this.onPrimaryStrong,
    required this.primaryStrongBorder,
    required this.secondary,
    required this.onSurface,
    required this.onSurfaceMuted,
    required this.onSurfaceSubtle,
    required this.borderStrong,
    required this.borderMuted,
    required this.success,
    required this.warning,
    required this.danger,
    required this.info,
    required this.overlayStrong,
    required this.overlayWeak,
    required this.transparent,
  });

  final Color background;
  final Color surface;
  final Color surfaceAlt;
  final Color surfaceContainer;
  final Color surfaceContainerHigh;
  final Color primary;
  final Color onPrimary;
  final Color primaryStrong;
  final Color onPrimaryStrong;
  final Color primaryStrongBorder;
  final Color secondary;
  final Color onSurface;
  final Color onSurfaceMuted;
  final Color onSurfaceSubtle;
  final Color borderStrong;
  final Color borderMuted;
  final Color success;
  final Color warning;
  final Color danger;
  final Color info;
  final Color overlayStrong;
  final Color overlayWeak;
  final Color transparent;

  factory ChatKitPalette.fromMaterial(
    ThemeData material,
    GrayscaleOptions? grayscale,
  ) {
    final scheme = material.colorScheme;
    final brightness = scheme.brightness;
    final onSurface = ChatKitThemeData._resolveGrayscaleTone(
      options: grayscale,
      explicit: grayscale?.label1,
      targetLightness: brightness == Brightness.dark ? 0.88 : 0.12,
      fallback: scheme.onSurface,
      saturation: 0.12,
    );
    final onSurfaceMuted = onSurface.withValues(alpha: 0.72);
    final onSurfaceSubtle = onSurface.withValues(alpha: 0.55);
    final borderFallback = ChatKitThemeData._resolveGrayscaleTone(
      options: grayscale,
      explicit: grayscale?.border,
      targetLightness: brightness == Brightness.dark ? 0.55 : 0.7,
      fallback: scheme.outlineVariant,
      saturation: 0.08,
    );
    final overlayTint = ChatKitThemeData._resolveGrayscaleTone(
      options: grayscale,
      explicit: grayscale?.tintColor ?? grayscale?.tint,
      targetLightness: brightness == Brightness.dark ? 0.25 : 0.2,
      fallback: onSurface,
      saturation: 0.12,
    );
    final background = ChatKitThemeData._resolveGrayscaleTone(
      options: grayscale,
      explicit: grayscale?.background,
      targetLightness: brightness == Brightness.dark ? 0.08 : 0.98,
      fallback: material.scaffoldBackgroundColor,
      saturation: 0.04,
    );

    return ChatKitPalette(
      background: background,
      surface: scheme.surface,
      surfaceAlt: scheme.surfaceContainerHighest,
      surfaceContainer: scheme.surface.withValues(alpha: 0.98),
      surfaceContainerHigh: scheme.surface.withValues(alpha: 0.95),
      primary: scheme.primary,
      onPrimary: scheme.onPrimary,
      primaryStrong: scheme.primary,
      onPrimaryStrong: scheme.onPrimary,
      primaryStrongBorder: scheme.primaryContainer.withValues(alpha: 0.45),
      secondary: scheme.secondary,
      onSurface: onSurface,
      onSurfaceMuted: onSurfaceMuted,
      onSurfaceSubtle: onSurfaceSubtle,
      borderStrong: borderFallback,
      borderMuted: scheme.outlineVariant,
      success: const Color(0xFF12B76A),
      warning: const Color(0xFFF79009),
      danger: const Color(0xFFD92D20),
      info: const Color(0xFF1570EF),
      overlayStrong: overlayTint.withValues(alpha: 0.65),
      overlayWeak: overlayTint.withValues(alpha: 0.35),
      transparent: const Color(0x00000000),
    );
  }
}

/// Standard spacing scale (multiples of 4) used across ChatKit surfaces.
@immutable
class ChatKitSpacing {
  const ChatKitSpacing({
    required this.xxxs,
    required this.xxs,
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
    required this.xl,
    required this.xxl,
    required this.xxxl,
  });

  final double xxxs;
  final double xxs;
  final double xs;
  final double sm;
  final double md;
  final double lg;
  final double xl;
  final double xxl;
  final double xxxl;

  factory ChatKitSpacing.defaults({ThemeDensityOption? density}) {
    final scale = switch (density) {
      ThemeDensityOption.compact => 0.88,
      ThemeDensityOption.spacious => 1.15,
      _ => 1.0,
    };
    double scaleValue(double value) =>
        (value * scale * 100).roundToDouble() / 100;

    return ChatKitSpacing(
      xxxs: scaleValue(2),
      xxs: scaleValue(4),
      xs: scaleValue(8),
      sm: scaleValue(12),
      md: scaleValue(16),
      lg: scaleValue(20),
      xl: scaleValue(24),
      xxl: scaleValue(32),
      xxxl: scaleValue(40),
    );
  }
}

/// Radii tokens centralising curvature across surfaces.
@immutable
class ChatKitRadii {
  const ChatKitRadii({
    required this.xs,
    required this.sm,
    required this.md,
    required this.lg,
    required this.xl,
    required this.full,
    required this.field,
    required this.button,
    required this.icon,
    required this.card,
    required this.composer,
    required this.messageBubble,
  });

  final double xs;
  final double sm;
  final double md;
  final double lg;
  final double xl;
  final double full;
  final double field;
  final double button;
  final double icon;
  final double card;
  final double composer;
  final double messageBubble;

  factory ChatKitRadii.fromBase(double? base) {
    final core = base ?? 12;
    return ChatKitRadii(
      xs: math.max(2, core * 0.25),
      sm: math.max(4, core * 0.4),
      md: math.max(6, core * 0.6),
      lg: math.max(8, core * 0.8),
      xl: math.max(12, core * 1.0),
      full: 999,
      field: math.max(10, core * 0.9),
      button: math.max(10, core * 0.9),
      icon: 20,
      card: math.max(12, core),
      composer: math.max(20, core * 1.4),
      messageBubble: math.max(12, core),
    );
  }
}

/// Encapsulates typography primitives consumed by style helpers.
@immutable
class ChatKitTypography {
  const ChatKitTypography({
    required this.bodyMedium,
    required this.bodySmall,
    required this.labelLarge,
    required this.labelMedium,
    required this.headlineSmall,
  });

  final TextStyle? bodyMedium;
  final TextStyle? bodySmall;
  final TextStyle? labelLarge;
  final TextStyle? labelMedium;
  final TextStyle? headlineSmall;

  factory ChatKitTypography.fromTheme(TextTheme textTheme) {
    return ChatKitTypography(
      bodyMedium: textTheme.bodyMedium,
      bodySmall: textTheme.bodySmall,
      labelLarge: textTheme.labelLarge,
      labelMedium: textTheme.labelMedium,
      headlineSmall: textTheme.headlineSmall,
    );
  }
}

/// Container for component-level surface tokens.
@immutable
class ChatKitComponentStyles {
  const ChatKitComponentStyles({
    required this.surface,
    required this.composer,
    required this.history,
    required this.assistantBubble,
    required this.userBubble,
  });

  final ChatKitSurfaceStyle surface;
  final ChatKitSurfaceStyle composer;
  final ChatKitSurfaceStyle history;
  final ChatKitSurfaceStyle assistantBubble;
  final ChatKitSurfaceStyle userBubble;
}

/// Describes a single surface's colours, radius, border and elevation.
@immutable
class ChatKitSurfaceStyle {
  const ChatKitSurfaceStyle({
    required this.background,
    required this.foreground,
    this.border,
    this.elevation = 0,
    this.radius,
  });

  final Color background;
  final Color foreground;
  final Color? border;
  final double elevation;
  final double? radius;
}

/// Drop shadow presets used for key elevations like composer overlays.
@immutable
class ChatKitShadows {
  const ChatKitShadows({
    required this.none,
    required this.soft,
    required this.medium,
    required this.strong,
  });

  final List<BoxShadow> none;
  final List<BoxShadow> soft;
  final List<BoxShadow> medium;
  final List<BoxShadow> strong;

  factory ChatKitShadows.defaults(ChatKitPalette palette) {
    return ChatKitShadows(
      none: const <BoxShadow>[],
      soft: <BoxShadow>[
        BoxShadow(
          color: palette.overlayWeak.withValues(alpha: 0.18),
          blurRadius: 12,
          offset: const Offset(0, 4),
        ),
      ],
      medium: <BoxShadow>[
        BoxShadow(
          color: palette.overlayWeak.withValues(alpha: 0.22),
          blurRadius: 18,
          offset: const Offset(0, 6),
        ),
      ],
      strong: <BoxShadow>[
        BoxShadow(
          color: palette.overlayStrong.withValues(alpha: 0.25),
          blurRadius: 24,
          offset: const Offset(0, 10),
        ),
      ],
    );
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/widgets/media_player.dart">
import 'package:flutter/material.dart';
import 'package:just_audio/just_audio.dart';
import 'package:video_player/video_player.dart';

import '../theme/chatkit_theme.dart';

class ChatKitVideoPlayer extends StatefulWidget {
  const ChatKitVideoPlayer({
    super.key,
    required this.url,
    this.aspectRatio,
    this.autoplay = false,
  });

  final String url;
  final double? aspectRatio;
  final bool autoplay;

  @override
  State<ChatKitVideoPlayer> createState() => _ChatKitVideoPlayerState();
}

class _ChatKitVideoPlayerState extends State<ChatKitVideoPlayer> {
  late final VideoPlayerController _controller;
  late final Future<void> _initialize;
  bool _isPlaying = false;

  @override
  void initState() {
    super.initState();
    _controller = VideoPlayerController.networkUrl(Uri.parse(widget.url));
    _initialize = _controller.initialize().then((_) {
      if (widget.autoplay) {
        _controller.play();
        _isPlaying = true;
      }
      if (mounted) {
        setState(() {});
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _togglePlay() {
    if (!_controller.value.isInitialized) {
      return;
    }
    setState(() {
      if (_controller.value.isPlaying) {
        _controller.pause();
        _isPlaying = false;
      } else {
        _controller.play();
        _isPlaying = true;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<void>(
      future: _initialize,
      builder: (context, snapshot) {
        if (snapshot.connectionState != ConnectionState.done) {
          return const SizedBox(
            height: 180,
            child: Center(child: CircularProgressIndicator()),
          );
        }
        final aspect = widget.aspectRatio ?? _controller.value.aspectRatio;
        return AspectRatio(
          aspectRatio: aspect,
          child: Stack(
            alignment: Alignment.bottomCenter,
            children: [
              VideoPlayer(_controller),
              _VideoControlsOverlay(
                isPlaying: _isPlaying,
                onToggle: _togglePlay,
              ),
              VideoProgressIndicator(
                _controller,
                allowScrubbing: true,
              ),
            ],
          ),
        );
      },
    );
  }
}

class _VideoControlsOverlay extends StatelessWidget {
  const _VideoControlsOverlay({
    required this.isPlaying,
    required this.onToggle,
  });

  final bool isPlaying;
  final VoidCallback onToggle;

  @override
  Widget build(BuildContext context) {
    final palette = ChatKitTheme.of(context).palette;
    final theme = Theme.of(context);
    return Positioned.fill(
      child: Material(
        color: palette.overlayStrong.withValues(alpha: 0.4),
        child: InkWell(
          onTap: onToggle,
          child: Center(
            child: Icon(
              isPlaying ? Icons.pause_circle : Icons.play_circle,
              color: theme.colorScheme.onInverseSurface,
              size: 48,
            ),
          ),
        ),
      ),
    );
  }
}

class ChatKitAudioPlayer extends StatefulWidget {
  const ChatKitAudioPlayer({
    super.key,
    required this.url,
  });

  final String url;

  @override
  State<ChatKitAudioPlayer> createState() => _ChatKitAudioPlayerState();
}

class _ChatKitAudioPlayerState extends State<ChatKitAudioPlayer> {
  late final AudioPlayer _player;
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _player = AudioPlayer();
    _initialize();
  }

  Future<void> _initialize() async {
    try {
      await _player.setUrl(widget.url);
    } finally {
      if (mounted) {
        setState(() {
          _loading = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _player.dispose();
    super.dispose();
  }

  Future<void> _togglePlay() async {
    if (_player.playing) {
      await _player.pause();
    } else {
      await _player.play();
    }
    if (mounted) {
      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Theme.of(context).colorScheme.outlineVariant),
        borderRadius: BorderRadius.circular(12),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      child: _loading
          ? const SizedBox(
              height: 48,
              child: Center(child: CircularProgressIndicator()),
            )
          : Row(
              children: [
                IconButton(
                  icon: Icon(
                    _player.playing ? Icons.pause : Icons.play_arrow,
                  ),
                  onPressed: _togglePlay,
                ),
                Expanded(
                  child: StreamBuilder<Duration?>(
                    stream: _player.durationStream,
                    builder: (context, snapshot) {
                      final total = snapshot.data ?? Duration.zero;
                      return StreamBuilder<Duration>(
                        stream: _player.positionStream,
                        builder: (context, positionSnapshot) {
                          final position =
                              positionSnapshot.data ?? Duration.zero;
                          final value = total.inMilliseconds == 0
                              ? 0.0
                              : position.inMilliseconds / total.inMilliseconds;
                          return Slider(
                            value: value.clamp(0.0, 1.0),
                            onChanged: (newValue) {
                              final target = Duration(
                                  milliseconds:
                                      (total.inMilliseconds * newValue)
                                          .round());
                              _player.seek(target);
                            },
                          );
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
    );
  }
}
</file>

<file path="packages/chatkit_flutter/lib/chatkit_flutter.dart">
library chatkit_flutter;

export 'src/widgets/chatkit_view.dart';
export 'src/gallery/chatkit_gallery.dart';
</file>

<file path="packages/chatkit_flutter/pubspec.yaml">
name: chatkit_flutter
description: Flutter widgets and UI scaffolding for the ChatKit Dart client.
version: 0.1.0
homepage: https://github.com/openai/chatkit-js
repository: https://github.com/diwakarmoturu/chatkit-dart
publish_to: none

environment:
  sdk: ">=3.3.0 <4.0.0"
  flutter: ">=3.19.0"

dependencies:
  flutter:
    sdk: flutter
  chatkit_core:
    path: ../chatkit_core
  flutter_markdown: ^0.7.2
  intl: ^0.19.0
  file_picker: ^8.0.0+1
  image_picker: ^1.0.7
  desktop_drop: ^0.5.0
  cached_network_image: ^3.3.1
  collection: ^1.18.0
  meta: ^1.11.0
  mime: ^1.0.5
  video_player: ^2.8.3
  just_audio: ^0.9.36
  fl_chart: ^0.66.2
  flutter_map: ^6.1.0
  latlong2: ^0.9.1
  smooth_page_indicator: ^1.1.0
  signature: ^5.4.1
  share_plus: ^7.2.1
  phosphor_flutter: ^2.0.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.2

flutter:
  uses-material-design: true
</file>

<file path="SECURITY.md">
# Security Guidelines

Follow these recommendations when deploying ChatKit with the Dart/Flutter client:

## Authentication & tokens

- **Hosted mode:** Supply a short-lived `clientToken` and (optionally) a `getClientSecret` refresh hook via `HostedApiConfig` to fetch replacement tokens from your backend. Never embed static API keys in the app.
- **Custom backend:** Use `CustomApiConfig(headersBuilder: ...)` to inject per-request auth headers (session JWT, etc.) retrieved from secure storage.
- Rotate credentials frequently and prefer HTTPS for all endpoints.

## Domain allow-list

- When using hosted ChatKit, configure `domainKey` in the dashboard and set the same key via `CustomApiConfig(domainKey: ...)`. This allows the backend to verify the origin of requests.

## Attachments

- Validate file type/size server-side even if the client enforces limits (`ComposerAttachmentOption.maxSize`, `accept`).
- For two-phase uploads, ensure pre-signed URLs are scoped to a single attachment and expire quickly.
- Use authenticated URLs when rendering attachments or widget assets in the UI.

## Client tools & widget actions

- Treat tool invocations (`onClientTool`) as untrusted input; validate parameters before making network calls or writing to storage.
- Widget actions bubble back to your server (`sendCustomAction`). Sanitize payloads and enforce authorization per user/thread.

## Entities & previews

- Autocomplete responses (`entity.onTagSearch`) should be filtered to the requesting user. Avoid returning confidential data they shouldn't see.
- Widget previews returned by `onRequestPreview` are executed client-side; ensure they do not leak secrets and only include whitelisted actions.

## Error handling

- Listen to `chatkit.error` events emitted by the controller and provide user-friendly messaging without exposing stack traces.
- Log detailed error information on the backend where secure.

## Transport

- The controller automatically reconnects on transient SSE failures. Still, deploy behind HTTPS and handle 401/403 to force re-authentication.
- Set appropriate CORS rules on the backend for your Flutter web targets.

## Reporting vulnerabilities

If you discover a vulnerability in this port, please open an issue or reach out to the repository maintainer with a detailed report so it can be addressed promptly.
</file>

<file path="packages/chatkit_core/lib/src/api/api_client.dart">
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;

import '../errors.dart';
import '../models/request.dart';
import '../models/response.dart';
import '../options.dart';
import '../utils/json.dart';
import 'sse_client.dart';

typedef StreamEventCallback = FutureOr<void> Function(ThreadStreamEvent event);

class ChatKitApiClient {
  ChatKitApiClient({
    required ChatKitApiConfig apiConfig,
    http.Client? httpClient,
    SseClient? sseClient,
  })  : _apiConfig = apiConfig,
        _httpClient = httpClient ?? http.Client(),
        _sseClient =
            sseClient ?? SseClient(httpClient: httpClient ?? http.Client()),
        _currentClientSecret = switch (apiConfig) {
          HostedApiConfig(:final clientToken) => clientToken,
          _ => null,
        };

  final ChatKitApiConfig _apiConfig;
  final http.Client _httpClient;
  final SseClient _sseClient;

  String? _currentClientSecret;
  Future<String>? _refreshingClientSecret;
  String? _acceptLanguage;

  String? get acceptLanguage => _acceptLanguage;

  set acceptLanguage(String? value) {
    final trimmed = value?.trim();
    _acceptLanguage = (trimmed == null || trimmed.isEmpty) ? null : trimmed;
  }

  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    final uri = await _buildUri();
    final payload = {
      ...request.toJson(),
      ...bodyOverrides,
    };
    final body = jsonEncode(payload);
    var attemptedAuthRefresh = false;

    while (true) {
      final httpRequest = http.Request('POST', uri)
        ..headers[HttpHeaders.contentTypeHeader] = 'application/json'
        ..body = body;

      try {
        final streamedResponse = await _sendRequest(httpRequest);
        final response = await http.Response.fromStream(streamedResponse);

        if (response.statusCode < 200 || response.statusCode >= 300) {
          throw ChatKitServerException(
            'Request failed with status ${response.statusCode}',
            statusCode: response.statusCode,
            error: castMap(
              response.body.isNotEmpty ? jsonDecode(response.body) : null,
            ),
          );
        }

        if (response.body.isEmpty) {
          return const {};
        }

        final json = jsonDecode(response.body);
        return castMap(json);
      } on ChatKitServerException catch (error) {
        if (_canAttemptHostedRefresh(error.statusCode) &&
            !attemptedAuthRefresh) {
          attemptedAuthRefresh = true;
          final refreshed = await _tryRefreshHostedSecret();
          if (refreshed) {
            continue;
          }
        }
        rethrow;
      }
    }
  }

  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    final uri = await _buildUri();
    final payload = {
      ...request.toJson(),
      ...bodyOverrides,
    };
    final Set<String> recentEventIds = LinkedHashSet<String>();
    const maxTrackedEventIds = 64;
    var attemptedAuthRefresh = false;

    while (true) {
      var shouldRetryAuth = false;
      try {
        await _sseClient.post(
          uri,
          body: payload,
          sendOverride: (req) => _sendRequest(req),
          keepAliveTimeout: keepAliveTimeout,
          onKeepAliveTimeout: onKeepAliveTimeout,
          onRetrySuggested: onRetrySuggested,
          onMessage: (message) async {
            final eventId = message.id;
            if (eventId != null && eventId.isNotEmpty) {
              final added = recentEventIds.add(eventId);
              if (!added) {
                return;
              }
              if (recentEventIds.length > maxTrackedEventIds) {
                recentEventIds.remove(recentEventIds.first);
              }
            }

            final data = message.data;
            if (data == null || data.isEmpty) {
              return;
            }

            final decoded = jsonDecode(data);
            if (decoded is List) {
              for (final entry in decoded) {
                await onEvent(ThreadStreamEvent.fromJson(castMap(entry)));
              }
            } else if (decoded is Map<String, Object?>) {
              await onEvent(ThreadStreamEvent.fromJson(decoded));
            }
          },
          onError: (error, stackTrace) {
            if (error is ChatKitServerException &&
                _canAttemptHostedRefresh(error.statusCode) &&
                !attemptedAuthRefresh) {
              shouldRetryAuth = true;
              return;
            }
            onError?.call(error, stackTrace);
          },
          onDone: onDone,
        );
      } on SocketException catch (error, stackTrace) {
        onError?.call(error, stackTrace);
        rethrow;
      }

      if (shouldRetryAuth) {
        attemptedAuthRefresh = true;
        recentEventIds.clear();
        final refreshed = await _tryRefreshHostedSecret();
        if (refreshed) {
          continue;
        }
        final unauthorized = ChatKitServerException(
          'Request failed with status 401',
          statusCode: 401,
        );
        onError?.call(unauthorized, StackTrace.current);
      }
      break;
    }
  }

  Future<void> close() async {
    _httpClient.close();
  }

  void cancelActiveStream() {
    _sseClient.cancelActive();
  }

  Future<Uri> _buildUri() async {
    return switch (_apiConfig) {
      CustomApiConfig(:final url) => Uri.parse(url),
      HostedApiConfig() => Uri.parse('https://api.openai.com/v1/chatkit'),
      _ => Uri.parse('https://api.openai.com/v1/chatkit'),
    };
  }

  Future<void> _applyHeaders(http.BaseRequest request) async {
    request.headers.putIfAbsent(
      HttpHeaders.contentTypeHeader,
      () => 'application/json',
    );
    request.headers.putIfAbsent(
      'accept',
      () => 'application/json, text/event-stream',
    );
    request.headers['x-chatkit-sdk'] = 'chatkit-dart';
    final language = _acceptLanguage;
    if (language != null && language.isNotEmpty) {
      request.headers[HttpHeaders.acceptLanguageHeader] = language;
    }

    switch (_apiConfig) {
      case CustomApiConfig(:final domainKey, :final headersBuilder):
        if (domainKey != null) {
          request.headers['x-chatkit-domain-key'] = domainKey;
        }
        if (headersBuilder != null) {
          final extra = await Future.value(headersBuilder(request));
          if (extra.isNotEmpty) {
            request.headers.addAll(extra);
          }
        }
      // fetchOverride handled in _sendRequest
      case HostedApiConfig():
        await _ensureHostedCredentials();
        final secret = _currentClientSecret;
        if (secret == null || secret.isEmpty) {
          throw ChatKitConfigurationException(
            'Hosted API client secret is not available.',
          );
        }
        request.headers['authorization'] = 'Bearer $secret';
        break;
      default:
        break;
    }
  }

  Future<void> _ensureHostedCredentials({bool forceRefresh = false}) async {
    final config = _hostedConfig;
    if (config == null) {
      return;
    }

    if (!forceRefresh &&
        _currentClientSecret != null &&
        _currentClientSecret!.isNotEmpty) {
      return;
    }

    final getter = config.getClientSecret;
    if (getter == null) {
      final token = config.clientToken;
      if (token == null || token.isEmpty) {
        throw ChatKitConfigurationException(
          'HostedApiConfig requires a clientToken or getClientSecret callback.',
        );
      }
      _currentClientSecret = token;
      return;
    }

    if (!forceRefresh && _refreshingClientSecret != null) {
      _currentClientSecret = await _refreshingClientSecret!;
      return;
    }

    final future = Future<String>.value(getter(_currentClientSecret));
    if (!forceRefresh) {
      _refreshingClientSecret = future;
    }

    try {
      final secret = await future;
      if (secret.isEmpty) {
        throw ChatKitConfigurationException(
          'Hosted client secret callback returned an empty value.',
        );
      }
      _currentClientSecret = secret;
    } finally {
      if (!forceRefresh && identical(_refreshingClientSecret, future)) {
        _refreshingClientSecret = null;
      }
    }
  }

  Future<bool> _tryRefreshHostedSecret() async {
    final config = _hostedConfig;
    if (config == null) {
      return false;
    }
    if (config.getClientSecret == null) {
      return false;
    }
    await _ensureHostedCredentials(forceRefresh: true);
    return _currentClientSecret != null && _currentClientSecret!.isNotEmpty;
  }

  bool _canAttemptHostedRefresh(int? statusCode) {
    if (statusCode != 401) {
      return false;
    }
    final config = _hostedConfig;
    if (config == null) {
      return false;
    }
    return config.getClientSecret != null;
  }

  Future<http.StreamedResponse> _sendRequest(http.Request request) async {
    await _applyHeaders(request);
    if (_apiConfig case CustomApiConfig(:final fetchOverride)) {
      if (fetchOverride != null) {
        return await Future.value(fetchOverride(request));
      }
    }
    return _httpClient.send(request);
  }

  HostedApiConfig? get _hostedConfig {
    final config = _apiConfig;
    return config is HostedApiConfig ? config : null;
  }
}
</file>

<file path="packages/chatkit_core/lib/src/options.dart">
import 'dart:async';

import 'package:http/http.dart' as http;
import 'package:meta/meta.dart';

import 'actions/client_tools.dart';
import 'models/entities.dart';

/// Base interface implemented by API configuration variants.
abstract class ChatKitApiConfig {
  const ChatKitApiConfig();
}

/// Hosted mode configuration that relies on ChatKit-hosted authentication.
@immutable
class HostedApiConfig extends ChatKitApiConfig {
  const HostedApiConfig({
    this.clientToken,
    this.getClientSecret,
  }) : assert(
          clientToken != null || getClientSecret != null,
          'HostedApiConfig requires either clientToken or getClientSecret.',
        );

  /// Initial client token/secret to use for hosted authentication.
  final String? clientToken;

  /// Callback that provides (or refreshes) the client secret used to
  /// authenticate requests against the hosted ChatKit deployment.
  final FutureOr<String> Function(String? currentClientSecret)? getClientSecret;
}

/// Custom backend configuration which mirrors the JS `CustomApiConfig`.
@immutable
class CustomApiConfig extends ChatKitApiConfig {
  const CustomApiConfig({
    required this.url,
    this.domainKey,
    this.uploadStrategy,
    this.headersBuilder,
    this.fetchOverride,
  });

  /// Fully-qualified or relative URL for the ChatKit-compatible endpoint.
  final String url;

  /// Optional domain verification key that is sent alongside chat requests.
  final String? domainKey;

  /// Strategy to use for uploading attachments.
  final FileUploadStrategy? uploadStrategy;

  /// Optional hook that allows per-request header customization (e.g. auth).
  final FutureOr<Map<String, String>> Function(http.BaseRequest request)?
      headersBuilder;

  final FutureOr<http.StreamedResponse> Function(http.BaseRequest request)?
      fetchOverride;
}

/// Attachment upload strategies available in JS and mirrored here.
@immutable
sealed class FileUploadStrategy {
  const FileUploadStrategy();
}

/// Upload files via a single POST directly to the specified URL.
class DirectUploadStrategy extends FileUploadStrategy {
  const DirectUploadStrategy({required this.uploadUrl});

  final String uploadUrl;
}

/// Use two-phase uploads where the backend returns a signed URL.
class TwoPhaseUploadStrategy extends FileUploadStrategy {
  const TwoPhaseUploadStrategy();
}

/// The high-level options object accepted by [ChatKitController].
@immutable
class ChatKitOptions {
  const ChatKitOptions({
    required this.api,
    this.transport,
    this.hostedHooks,
    this.locale,
    Object? theme,
    this.initialThread,
    this.onClientTool,
    this.header,
    this.history,
    this.startScreen,
    this.threadItemActions,
    this.composer,
    this.disclaimer,
    this.entities,
    this.widgets,
    this.localizationOverrides,
    this.localization,
    this.onLog,
  }) : theme = theme;

  final ChatKitApiConfig api;
  final TransportOption? transport;
  final HostedHooksOption? hostedHooks;
  final String? locale;
  final Object? theme;
  final String? initialThread;
  final ChatKitClientToolHandler? onClientTool;
  final HeaderOption? header;
  final HistoryOption? history;
  final StartScreenOption? startScreen;
  final ThreadItemActionsOption? threadItemActions;
  final ComposerOption? composer;
  final DisclaimerOption? disclaimer;
  final EntitiesOption? entities;
  final WidgetsOption? widgets;
  final Map<String, String>? localizationOverrides;
  final LocalizationOption? localization;
  final void Function(String name, Map<String, Object?> data)? onLog;

  ChatKitOptions copyWith({
    ChatKitApiConfig? api,
    TransportOption? transport,
    String? locale,
    Object? theme,
    String? initialThread,
    ChatKitClientToolHandler? onClientTool,
    HeaderOption? header,
    HistoryOption? history,
    StartScreenOption? startScreen,
    ThreadItemActionsOption? threadItemActions,
    ComposerOption? composer,
    DisclaimerOption? disclaimer,
    EntitiesOption? entities,
    WidgetsOption? widgets,
    Map<String, String>? localizationOverrides,
    LocalizationOption? localization,
    void Function(String name, Map<String, Object?> data)? onLog,
  }) {
    return ChatKitOptions(
      api: api ?? this.api,
      transport: transport ?? this.transport,
      hostedHooks: hostedHooks ?? this.hostedHooks,
      locale: locale ?? this.locale,
      theme: theme ?? this.theme,
      initialThread: initialThread ?? this.initialThread,
      onClientTool: onClientTool ?? this.onClientTool,
      header: header ?? this.header,
      history: history ?? this.history,
      startScreen: startScreen ?? this.startScreen,
      threadItemActions: threadItemActions ?? this.threadItemActions,
      composer: composer ?? this.composer,
      disclaimer: disclaimer ?? this.disclaimer,
      entities: entities ?? this.entities,
      widgets: widgets ?? this.widgets,
      localizationOverrides:
          localizationOverrides ?? this.localizationOverrides,
      localization: localization ?? this.localization,
      onLog: onLog ?? this.onLog,
    );
  }

  /// Returns the simple color scheme preset when [theme] was provided as
  /// `'light'`, `'dark'`, or `'system'`.
  ColorSchemeOption? get themeColorScheme {
    final value = theme;
    if (value is ColorSchemeOption) {
      return value;
    }
    if (value is ThemeOption) {
      return value.colorScheme;
    }
    if (value is String) {
      switch (value.trim().toLowerCase()) {
        case 'light':
          return ColorSchemeOption.light;
        case 'dark':
          return ColorSchemeOption.dark;
        case 'system':
          return ColorSchemeOption.system;
      }
    }
    return null;
  }

  /// Returns a [ThemeOption] regardless of whether the caller provided a
  /// string preset, an enum, or a fully-specified theme object.
  ThemeOption? get resolvedTheme {
    final value = theme;
    if (value is ThemeOption) {
      return value;
    }
    final scheme = themeColorScheme;
    if (scheme != null) {
      return ThemeOption(colorScheme: scheme);
    }
    return null;
  }
}

@immutable
class TransportOption {
  const TransportOption({
    this.keepAliveTimeout,
    this.initialBackoff,
    this.maxBackoff,
  });

  final Duration? keepAliveTimeout;
  final Duration? initialBackoff;
  final Duration? maxBackoff;
}

@immutable
class HostedHooksOption {
  const HostedHooksOption({
    this.onAuthExpired,
    this.onAuthRestored,
    this.onStaleClient,
  });

  final VoidCallback? onAuthExpired;
  final VoidCallback? onAuthRestored;
  final FutureOr<void> Function()? onStaleClient;
}

/// Theme options intentionally mirror the TS definitions but favour optional
/// fields to remain forward compatible with new surfaces.
@immutable
class ThemeOption {
  const ThemeOption({
    this.colorScheme,
    this.color,
    this.typography,
    this.shapes,
    this.radius,
    this.density,
    this.breakpoints,
    this.backgroundGradient,
    this.elevations,
    this.components,
  });

  final ColorSchemeOption? colorScheme;
  final ThemeColorOptions? color;
  final ThemeTypographyOptions? typography;
  final ThemeShapeOptions? shapes;
  final ThemeRadiusOption? radius;
  final ThemeDensityOption? density;
  final ThemeBreakpointOptions? breakpoints;
  final ThemeGradientOptions? backgroundGradient;
  final ThemeElevationOptions? elevations;
  final ThemeComponentOptions? components;
}

enum ColorSchemeOption {
  light,
  dark,
  system,
}

enum ThemeRadiusOption {
  pill,
  round,
  soft,
  sharp,
}

enum ThemeDensityOption {
  compact,
  normal,
  spacious,
}

@immutable
class ThemeColorOptions {
  const ThemeColorOptions({
    this.grayscale,
    this.accent,
    this.surface,
    this.gradients,
  });

  final GrayscaleOptions? grayscale;
  final AccentColorOptions? accent;
  final SurfaceColorOptions? surface;
  final ThemeGradientOptions? gradients;
}

@immutable
class GrayscaleOptions {
  const GrayscaleOptions({
    this.label0,
    this.label1,
    this.label2,
    this.label3,
    this.border,
    this.background,
    this.tint,
    this.tintColor,
    this.shadow,
    this.hue,
    this.tintStep,
    this.shade,
  });

  final String? label0;
  final String? label1;
  final String? label2;
  final String? label3;
  final String? border;
  final String? background;
  final String? tint;
  final String? tintColor;
  final String? shadow;
  final double? hue;
  final int? tintStep;
  final int? shade;
}

@immutable
class AccentColorOptions {
  const AccentColorOptions({
    this.primary,
    this.onPrimary,
    this.secondary,
    this.onSecondary,
    this.level,
  });

  final String? primary;
  final String? onPrimary;
  final String? secondary;
  final String? onSecondary;
  final int? level;
}

@immutable
class SurfaceColorOptions {
  const SurfaceColorOptions({
    this.primary,
    this.secondary,
    this.tertiary,
    this.quaternary,
    this.background,
    this.foreground,
  });

  final String? primary;
  final String? secondary;
  final String? tertiary;
  final String? quaternary;
  final String? background;
  final String? foreground;
}

@immutable
class ThemeGradientOptions {
  const ThemeGradientOptions({
    required this.colors,
    this.angle,
  });

  /// List of hex colors applied sequentially in the gradient.
  final List<String> colors;

  /// Optional angle in degrees (0 = left to right, 90 = bottom to top).
  final double? angle;
}

@immutable
class ThemeElevationOptions {
  const ThemeElevationOptions({
    this.surface,
    this.composer,
    this.history,
    this.assistantBubble,
    this.userBubble,
  });

  final double? surface;
  final double? composer;
  final double? history;
  final double? assistantBubble;
  final double? userBubble;
}

@immutable
class ThemeComponentOptions {
  const ThemeComponentOptions({
    this.composer,
    this.history,
    this.assistantBubble,
    this.userBubble,
  });

  final ThemeComponentStyle? composer;
  final ThemeComponentStyle? history;
  final ThemeComponentStyle? assistantBubble;
  final ThemeComponentStyle? userBubble;
}

@immutable
class ThemeComponentStyle {
  const ThemeComponentStyle({
    this.background,
    this.text,
    this.border,
    this.elevation,
    this.radius,
  });

  final String? background;
  final String? text;
  final String? border;
  final double? elevation;
  final double? radius;
}

@immutable
class ThemeTypographyOptions {
  const ThemeTypographyOptions({
    this.fontFamily,
    this.monospaceFontFamily,
    this.fontFamilyMono,
    this.baseSize,
    this.fontSources,
  });

  final String? fontFamily;
  final String? monospaceFontFamily;
  final String? fontFamilyMono;
  final double? baseSize;
  final List<ThemeFontSource>? fontSources;
}

@immutable
class ThemeFontSource {
  const ThemeFontSource({
    required this.family,
    required this.src,
    this.weight,
    this.style,
    this.display,
    this.unicodeRange,
  });

  final String family;
  final String src;
  final String? weight;
  final String? style;
  final String? display;
  final String? unicodeRange;
}

@immutable
class ThemeShapeOptions {
  const ThemeShapeOptions({
    this.radius,
    this.rounding,
  });

  final double? radius;
  final double? rounding;
}

@immutable
class ThemeBreakpointOptions {
  const ThemeBreakpointOptions({
    this.compact,
    this.medium,
    this.expanded,
  });

  final double? compact;
  final double? medium;
  final double? expanded;
}

@immutable
class HeaderOption {
  const HeaderOption({
    this.enabled,
    this.title,
    this.leftAction,
    this.rightAction,
  });

  final bool? enabled;
  final HeaderTitleOption? title;
  final HeaderActionOption? leftAction;
  final HeaderActionOption? rightAction;
}

@immutable
class HeaderTitleOption {
  const HeaderTitleOption({
    this.enabled,
    this.text,
  });

  final bool? enabled;
  final String? text;
}

@immutable
class HeaderActionOption {
  const HeaderActionOption({
    required this.icon,
    required this.onClick,
  });

  final String icon;
  final VoidCallback onClick;
}

typedef VoidCallback = void Function();

class HeaderIcons {
  const HeaderIcons._();

  static const sidebarLeft = 'sidebar-left';
  static const sidebarRight = 'sidebar-right';
  static const sidebarOpenLeft = 'sidebar-open-left';
  static const sidebarOpenRight = 'sidebar-open-right';
  static const sidebarOpenLeftAlt = 'sidebar-open-left-alt';
  static const sidebarOpenRightAlt = 'sidebar-open-right-alt';
  static const sidebarFloatingLeft = 'sidebar-floating-left';
  static const sidebarFloatingRight = 'sidebar-floating-right';
  static const sidebarFloatingOpenLeft = 'sidebar-floating-open-left';
  static const sidebarFloatingOpenRight = 'sidebar-floating-open-right';
  static const sidebarCollapseLeft = 'sidebar-collapse-left';
  static const sidebarCollapseRight = 'sidebar-collapse-right';
  static const collapseLeft = 'collapse-left';
  static const collapseRight = 'collapse-right';
  static const openLeft = 'open-left';
  static const openRight = 'open-right';
  static const doubleChevronLeft = 'double-chevron-left';
  static const doubleChevronRight = 'double-chevron-right';
  static const home = 'home';
  static const homeAlt = 'home-alt';
  static const backSmall = 'back-small';
  static const backLarge = 'back-large';
  static const expandLarge = 'expand-large';
  static const collapseLarge = 'collapse-large';
  static const expandSmall = 'expand-small';
  static const collapseSmall = 'collapse-small';
  static const star = 'star';
  static const starFilled = 'star-filled';
  static const chatTemporary = 'chat-temporary';
  static const settingsCog = 'settings-cog';
  static const grid = 'grid';
  static const dotsHorizontal = 'dots-horizontal';
  static const dotsVertical = 'dots-vertical';
  static const dotsHorizontalCircle = 'dots-horizontal-circle';
  static const dotsVerticalCircle = 'dots-vertical-circle';
  static const menu = 'menu';
  static const menuInverted = 'menu-inverted';
  static const hamburger = 'hamburger';
  static const compose = 'compose';
  static const lightMode = 'light-mode';
  static const darkMode = 'dark-mode';
  static const close = 'close';

  @Deprecated('Use HeaderIcons.compose')
  static const add = compose;
  @Deprecated('Use HeaderIcons.menu')
  static const arrowDown = menu;
  @Deprecated('Use HeaderIcons.backLarge')
  static const arrowLeft = backLarge;
  @Deprecated('Use HeaderIcons.openRight')
  static const arrowRight = openRight;
  @Deprecated('Use HeaderIcons.menu')
  static const arrowUp = menu;
  @Deprecated('Use HeaderIcons.dotsHorizontal')
  static const more = dotsHorizontal;
  @Deprecated('Use HeaderIcons.settingsCog')
  static const settings = settingsCog;
  @Deprecated('Use HeaderIcons.hamburger')
  static const menuLegacy = hamburger;
}

@immutable
class HistoryOption {
  const HistoryOption({
    this.enabled,
    this.showDelete,
    this.showRename,
  });

  final bool? enabled;
  final bool? showDelete;
  final bool? showRename;
}

@immutable
class StartScreenOption {
  const StartScreenOption({
    this.greeting,
    this.prompts,
  });

  final String? greeting;
  final List<StartScreenPrompt>? prompts;
}

@immutable
class StartScreenPrompt {
  const StartScreenPrompt({
    required this.label,
    required this.prompt,
    this.icon,
  });

  final String label;
  final String prompt;
  final String? icon;
}

@immutable
class ThreadItemActionsOption {
  const ThreadItemActionsOption({
    this.feedback,
    this.retry,
    this.share,
    this.shareActions,
  });

  final bool? feedback;
  final bool? retry;
  final bool? share;
  final ShareActionsOption? shareActions;
}

enum ShareTargetType {
  copy,
  system,
  custom,
}

@immutable
class ShareTargetOption {
  const ShareTargetOption({
    required this.id,
    required this.label,
    this.type = ShareTargetType.custom,
    this.description,
    this.icon,
    this.toast,
  });

  final String id;
  final String label;
  final ShareTargetType type;
  final String? description;
  final String? icon;
  final String? toast;
}

@immutable
class ShareActionsOption {
  const ShareActionsOption({
    this.targets,
    this.onSelectTarget,
    this.copyToast,
    this.systemToast,
    this.defaultToast,
  });

  final List<ShareTargetOption>? targets;
  final FutureOr<void> Function(ShareTargetInvocation invocation)?
      onSelectTarget;
  final String? copyToast;
  final String? systemToast;
  final String? defaultToast;
}

@immutable
class ShareTargetInvocation {
  const ShareTargetInvocation({
    required this.targetId,
    required this.itemId,
    required this.threadId,
    required this.text,
  });

  final String targetId;
  final String itemId;
  final String threadId;
  final String text;
}

@immutable
class ComposerOption {
  const ComposerOption({
    this.placeholder,
    this.attachments,
    this.tools,
    this.models,
  });

  final String? placeholder;
  final ComposerAttachmentOption? attachments;
  final List<ToolOption>? tools;
  final List<ModelOption>? models;
}

@immutable
class ComposerAttachmentOption {
  const ComposerAttachmentOption({
    required this.enabled,
    this.maxSize,
    this.maxCount,
    this.accept,
  });

  final bool enabled;
  final int? maxSize;
  final int? maxCount;
  final Map<String, List<String>>? accept;
}

@immutable
class ToolOption {
  const ToolOption({
    String? id,
    @Deprecated('Use id') String? name,
    required this.label,
    this.description,
    this.shortLabel,
    this.placeholderOverride,
    this.icon,
    this.pinned = false,
  })  : assert(id != null || name != null, 'ToolOption.id is required'),
        id = id ?? (name as String);

  final String id;
  final String label;
  final String? description;
  final String? shortLabel;
  final String? placeholderOverride;
  final String? icon;
  final bool pinned;

  @Deprecated('Use id')
  String get name => id;
}

@immutable
class ModelOption {
  const ModelOption({
    required this.id,
    required this.label,
    this.description,
    bool? disabled,
    bool? defaultSelected,
    bool? isDefault,
    bool? defaultOption,
  })  : disabled = disabled ?? false,
        defaultSelected =
            defaultSelected ?? isDefault ?? defaultOption ?? false;

  final String id;
  final String label;
  final String? description;
  final bool disabled;
  final bool defaultSelected;

  @Deprecated('Use defaultSelected')
  bool get isDefault => defaultSelected;
}

@immutable
class DisclaimerOption {
  const DisclaimerOption({
    required this.text,
    this.highContrast,
  });

  final String text;
  final bool? highContrast;
}

@immutable
class EntitiesOption {
  const EntitiesOption({
    this.onTagSearch,
    this.onClick,
    this.onRequestPreview,
  });

  final FutureOr<List<Entity>> Function(String query)? onTagSearch;
  final void Function(Entity entity)? onClick;
  final FutureOr<EntityPreview?> Function(Entity entity)? onRequestPreview;
}

@immutable
class WidgetsOption {
  const WidgetsOption({
    this.onAction,
  });

  final FutureOr<void> Function(
    WidgetAction action,
    WidgetItemContext item,
  )? onAction;
}

@immutable
class LocalizationOption {
  const LocalizationOption({
    this.bundles = const {},
    this.defaultLocale,
    this.loader,
    this.pluralResolver,
  });

  /// Static bundles to register alongside built-in translations.
  final Map<String, Map<String, String>> bundles;

  /// Optional default locale to fall back to when the requested locale is not available.
  final String? defaultLocale;

  /// Optional asynchronous loader invoked when a locale bundle is requested but not cached.
  final FutureOr<Map<String, String>> Function(String locale)? loader;

  /// Optional pluralization resolver to format strings with counts.
  final String Function(
    String key,
    num count, {
    Map<String, Object?> params,
  })? pluralResolver;
}

@immutable
class WidgetAction {
  const WidgetAction({
    required this.type,
    this.payload = const {},
  });

  final String type;
  final Map<String, Object?> payload;
}

@immutable
class WidgetItemContext {
  const WidgetItemContext({
    required this.id,
    required this.widget,
  });

  final String id;
  final Map<String, Object?> widget;
}
</file>

<file path="packages/chatkit_core/test/client_tool_test.dart">
import 'dart:async';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

import 'fixtures/streaming_fixture.dart';

class _ClientToolApiClient extends ChatKitApiClient {
  _ClientToolApiClient({required this.onSubmit})
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );

  final void Function(ChatKitRequest request) onSubmit;
  int submissionCount = 0;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.get_by_id') {
      final threadId = request.params['thread_id'] as String? ?? 'thread_tool';
      return {
        'id': threadId,
        'title': 'Tool thread',
        'created_at': DateTime(2024).toUtc().toIso8601String(),
        'status': {'type': 'active'},
        'items': {
          'data': <Map<String, Object?>>[],
          'after': null,
          'has_more': false,
        },
      };
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.add_client_tool_output') {
      submissionCount += 1;
      onSubmit(request);
      onDone?.call();
      return;
    }
    onDone?.call();
  }
}

void main() {
  test('client tool invocation dispatches handler and submits result',
      () async {
    Map<String, Object?>? submittedPayload;
    String? submittedThreadId;
    final apiClient = _ClientToolApiClient(
      onSubmit: (request) {
        submittedThreadId = request.params['thread_id'] as String?;
        final resultParam = request.params['result'];
        if (resultParam is Map<String, Object?>) {
          submittedPayload = Map<String, Object?>.from(resultParam);
        }
      },
    );

    var handlerInvoked = false;
    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com'),
        onClientTool: (invocation) async {
          handlerInvoked = true;
          expect(invocation.name, 'browser');
          expect(invocation.params['location'], 'Valencia');
          return {
            'status': 'ok',
            'summary': 'Fetched latest weather.',
          };
        },
      ),
      apiClient: apiClient,
    );
    addTearDown(controller.dispose);

    await controller.setThreadId('thread_tool');

    for (final json in clientToolFixtureEvents()) {
      controller.debugHandleStreamEvent(ThreadStreamEvent.fromJson(json));
    }

    // Allow async handler to complete.
    await Future<void>.delayed(const Duration(milliseconds: 10));

    expect(handlerInvoked, isTrue);
    expect(apiClient.submissionCount, 1);
    expect(submittedThreadId, 'thread_tool');
    expect(submittedPayload, isNotNull);
    expect(submittedPayload!['type'], 'success');
    final data = submittedPayload!['data'] as Map<String, Object?>?;
    expect(data, isNotNull);
    expect(data!['status'], 'ok');
    expect(data['summary'], 'Fetched latest weather.');
  });
}
</file>

<file path="packages/chatkit_core/test/controller_busy_test.dart">
import 'dart:async';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

void main() {
  group('ChatKitController', () {
    test('fetchUpdates reloads active thread even when id is unchanged',
        () async {
      final responses = [
        _threadResponse(
          id: 'thr_1',
          itemId: 'item_initial',
          createdAt: '2024-01-01T00:00:00Z',
          text: 'first',
        ),
        _threadResponse(
          id: 'thr_1',
          itemId: 'item_updated',
          createdAt: '2024-01-01T00:00:01Z',
          text: 'second',
        ),
      ];
      final apiClient = _RecordingApiClient(responses);
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: apiClient,
      );

      await controller.setThreadId('thr_1');
      expect(apiClient.requestTypes, ['threads.get_by_id']);
      expect(
        controller.threadItems.first.content.first['text'],
        equals('first'),
      );

      apiClient.requestTypes.clear();
      await controller.fetchUpdates();
      expect(apiClient.requestTypes, ['threads.get_by_id']);
      expect(
        controller.threadItems.first.content.first['text'],
        equals('second'),
      );

      await controller.dispose();
    });

    test('setThreadId throws ChatKitBusyException while streaming', () async {
      final apiClient = _BlockingApiClient();
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: apiClient,
      );

      final sendFuture = controller.sendUserMessage(text: 'hi');
      await apiClient.started.future;

      await expectLater(
        controller.setThreadId('thr_2'),
        throwsA(isA<ChatKitStreamingInProgressException>()),
      );

      apiClient.complete();
      await expectLater(sendFuture, completes);
      await controller.dispose();
    });

    test('composer state clears immediately after sendUserMessage', () async {
      final apiClient = _BlockingApiClient();
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: apiClient,
      );

      final sendFuture = controller.sendUserMessage(text: 'clear me');
      await apiClient.started.future;

      expect(controller.composerState.text, isEmpty);
      expect(controller.composerState.attachments, isEmpty);
      expect(controller.composerState.tags, isEmpty);

      apiClient.complete();
      await sendFuture;
      await controller.dispose();
    });

    test('backgrounding prevents new streaming requests', () async {
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: _RecordingApiClient(const []),
      );

      controller.handleAppBackgrounded();
      await expectLater(
        controller.sendUserMessage(text: 'hi'),
        throwsA(isA<ChatKitBusyException>()),
      );

      controller.handleAppForegrounded(forceRefresh: true);
      await controller.dispose();
    });

    test('foreground triggers debounced fetch after backgrounding', () async {
      final responses = [
        _threadResponse(
          id: 'thr_foreground',
          itemId: 'item_1',
          createdAt: '2024-01-01T00:00:00Z',
          text: 'hello',
        ),
      ];
      final apiClient = _RecordingApiClient(responses);
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: apiClient,
      );

      final thread = Thread(
        metadata: ThreadMetadata(
          id: 'thr_foreground',
          title: 'Foreground test',
          createdAt: DateTime(2024),
          status: ThreadStatus.fromJson({'type': 'active'}),
        ),
        items: const [],
        after: null,
        hasMore: false,
      );
      controller.debugHandleStreamEvent(ThreadCreatedEvent(thread: thread));

      controller.handleAppBackgrounded();
      controller.handleAppForegrounded();
      await Future<void>.delayed(const Duration(milliseconds: 20));
      expect(apiClient.requestTypes, contains('threads.get_by_id'));

      apiClient.requestTypes.clear();
      controller.handleAppForegrounded();
      await Future<void>.delayed(const Duration(milliseconds: 20));
      expect(apiClient.requestTypes, isEmpty);

      await controller.dispose();
    });

    test('backgrounding cancels active stream via api client', () async {
      final apiClient = _CancelableApiClient();
      final controller = ChatKitController(
        const ChatKitOptions(
          api: CustomApiConfig(url: 'https://example.com/chat'),
        ),
        apiClient: apiClient,
      );

      controller.handleAppBackgrounded();

      expect(apiClient.cancelled, isTrue);

      await controller.dispose();
    });
  });
}

class _RecordingApiClient extends ChatKitApiClient {
  _RecordingApiClient(this._responses)
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chat'),
        );

  final List<Map<String, Object?>> _responses;
  final List<String> requestTypes = [];
  int _cursor = 0;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    requestTypes.add(request.type);
    final response = _responses[_cursor];
    if (_cursor < _responses.length - 1) {
      _cursor += 1;
    }
    return response;
  }
}

class _BlockingApiClient extends ChatKitApiClient {
  _BlockingApiClient()
      : started = Completer<void>(),
        _finish = Completer<void>(),
        super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chat'),
        );

  final Completer<void> started;
  final Completer<void> _finish;

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (!started.isCompleted) {
      started.complete();
    }
    await _finish.future;
    onDone?.call();
  }

  void complete() {
    if (!_finish.isCompleted) {
      _finish.complete();
    }
  }
}

class _CancelableApiClient extends ChatKitApiClient {
  _CancelableApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com/chat'),
        );

  bool cancelled = false;

  @override
  void cancelActiveStream() {
    cancelled = true;
    super.cancelActiveStream();
  }
}

Map<String, Object?> _threadResponse({
  required String id,
  required String itemId,
  required String createdAt,
  required String text,
}) {
  return {
    'id': id,
    'created_at': createdAt,
    'status': {'type': 'active'},
    'items': {
      'data': [
        {
          'id': itemId,
          'thread_id': id,
          'created_at': createdAt,
          'type': 'assistant_message',
          'role': 'assistant',
          'content': [
            {'type': 'output_text', 'text': text},
          ],
        },
      ],
      'after': null,
      'has_more': false,
    },
  };
}
</file>

<file path="packages/chatkit_core/test/transport_retry_test.dart">
import 'dart:async';
import 'dart:io';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

class _RetryingApiClient extends ChatKitApiClient {
  _RetryingApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );

  final List<Duration> retryHints = [];
  int callCount = 0;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.get_by_id') {
      final threadId = request.params['thread_id'] as String? ?? 'thread_retry';
      return {
        'id': threadId,
        'title': 'Retry thread',
        'created_at': '2024-06-01T00:00:00Z',
        'status': {'type': 'active'},
        'items': {
          'data': <Map<String, Object?>>[],
          'after': null,
          'has_more': false,
        },
      };
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    callCount += 1;
    if (callCount == 1) {
      const hint = Duration(milliseconds: 1500);
      onRetrySuggested?.call(hint);
      retryHints.add(hint);
      throw const SocketException('offline');
    }

    final item = ThreadItem(
      id: 'assistant_retry',
      threadId: 'thread_retry',
      createdAt: DateTime.utc(2024, 6, 2, 12),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Retry succeeded.'},
      ],
      attachments: const [],
      metadata: const {},
      raw: const {
        'type': 'assistant_message',
        'content': [
          {'type': 'output_text', 'text': 'Retry succeeded.'},
        ],
      },
    );
    await onEvent(ThreadItemAddedEvent(item: item));
    await onEvent(ThreadItemDoneEvent(item: item));
    onDone?.call();
  }
}

void main() {
  test('sendUserMessage retries with server hint and logs retry details',
      () async {
    final client = _RetryingApiClient();
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
        transport: TransportOption(
          initialBackoff: Duration(milliseconds: 20),
          maxBackoff: Duration(milliseconds: 40),
        ),
      ),
      apiClient: client,
    );
    addTearDown(controller.dispose);

    final events = <ChatKitEvent>[];
    final sub = controller.events.listen(events.add);
    addTearDown(() => sub.cancel());

    await controller.setThreadId('thread_retry');
    await controller.sendUserMessage(text: 'hello from dart');

    expect(client.callCount, 2);
    expect(client.retryHints, contains(const Duration(milliseconds: 1500)));

    final retryLogs = events.whereType<ChatKitLogEvent>().where(
          (event) =>
              event.name == 'transport.retry' &&
              event.data['server_hint_ms'] == 1500,
        );
    expect(retryLogs, isNotEmpty);

    final retryItem = controller.threadItemById('assistant_retry');
    expect(retryItem, isNotNull);
    expect(retryItem!.content.first['text'], 'Retry succeeded.');
  });

  test('sendUserMessage logs streaming latency metrics', () async {
    final client = _LatencyApiClient();
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: client,
    );
    addTearDown(controller.dispose);

    final logEvents = <ChatKitLogEvent>[];
    final sub = controller.events.listen((event) {
      if (event is ChatKitLogEvent) {
        logEvents.add(event);
      }
    });
    addTearDown(() => sub.cancel());

    await controller.setThreadId('thread_latency');
    await controller.sendUserMessage(text: 'measure me');
    await Future<void>.delayed(Duration.zero);

    final names = logEvents.map((event) => event.name).toList();
    expect(names, contains('transport.streaming.start'));
    expect(names, contains('transport.streaming.first_event'));
    expect(names, contains('transport.streaming.complete'));

    final startLog = logEvents.lastWhere(
      (event) => event.name == 'transport.streaming.start',
    );
    final firstEventLog = logEvents.lastWhere(
      (event) => event.name == 'transport.streaming.first_event',
    );
    final completeLog = logEvents.lastWhere(
      (event) => event.name == 'transport.streaming.complete',
    );

    expect(startLog.data['request_type'], 'threads.add_user_message');
    expect(firstEventLog.data['request_type'], 'threads.add_user_message');
    expect(
      (completeLog.data['event_count'] as num?)?.toInt(),
      greaterThanOrEqualTo(2),
    );
    expect(
      (completeLog.data['duration_ms'] as num?)?.toInt(),
      greaterThanOrEqualTo(0),
    );
    expect(completeLog.data['status'], anyOf('success', 'queued'));
  });
}

class _LatencyApiClient extends ChatKitApiClient {
  _LatencyApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.get_by_id') {
      final threadId = request.params['thread_id'] as String? ?? 'thread_latency';
      return {
        'id': threadId,
        'title': 'Latency thread',
        'created_at': '2024-06-02T00:00:00Z',
        'status': {'type': 'active'},
        'items': {
          'data': <Map<String, Object?>>[],
          'after': null,
          'has_more': false,
        },
      };
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    final item = ThreadItem(
      id: 'assistant_latency',
      threadId: 'thread_latency',
      createdAt: DateTime.utc(2024, 6, 2, 12),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Latency measurement'},
      ],
      attachments: const [],
      metadata: const {},
      raw: const {
        'type': 'assistant_message',
        'content': [
          {'type': 'output_text', 'text': 'Latency measurement'},
        ],
      },
    );
    await Future<void>.delayed(const Duration(milliseconds: 5));
    await onEvent(ThreadItemAddedEvent(item: item));
    await onEvent(ThreadItemDoneEvent(item: item));
    onDone?.call();
  }
}
</file>

<file path="packages/chatkit_flutter/test/golden/widget_dsl_golden_test.dart">
import 'dart:convert';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:chatkit_flutter/src/theme/chatkit_theme.dart';
import 'package:chatkit_flutter/src/widgets/widget_renderer.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

class _NoopApiClient extends ChatKitApiClient {
  _NoopApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );
}

Map<String, Object?> _deepCopy(Map<String, Object?> value) {
  return (jsonDecode(jsonEncode(value)) as Map).cast<String, Object?>();
}

Widget _buildThemedHarness({
  required ChatKitController controller,
  required Widget child,
  Color backgroundColor = const Color(0xFFF1F5F9),
  Brightness? platformBrightness,
  ThemeData? overrideBaseTheme,
}) {
  final brightness = platformBrightness ?? Brightness.light;
  final baseTheme = overrideBaseTheme ??
      ThemeData(
        useMaterial3: true,
        brightness: brightness,
      );
  final chatTheme = ChatKitThemeData.fromOptions(
    base: baseTheme,
    option: controller.options.resolvedTheme,
    platformBrightness: brightness,
  );
  return MaterialApp(
    theme: baseTheme,
    home: ChatKitTheme(
      data: chatTheme,
      child: Theme(
        data: chatTheme.materialTheme,
        child: Scaffold(
          backgroundColor: backgroundColor,
          body: child,
        ),
      ),
    ),
  );
}

final Map<String, Object?> _dashboardWidget = <String, Object?>{
  'id': 'weekly_summary',
  'type': 'card',
  'size': 'lg',
  'padding': 'lg',
  'background': '#FFFFFF',
  'children': <Map<String, Object?>>[
    <String, Object?>{
      'type': 'row',
      'gap': 'md',
      'align': 'center',
      'justify': 'space_between',
      'wrap': 'wrap',
      'children': <Map<String, Object?>>[
        <String, Object?>{
          'type': 'column',
          'gap': 'xs',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'text',
              'value': 'Training overview',
              'size': 'lg',
              'weight': 'semibold',
            },
            <String, Object?>{
              'type': 'text',
              'value': 'Week 5 · 4 sessions completed',
              'size': 'sm',
              'weight': 'medium',
            },
          ],
        },
        <String, Object?>{
          'type': 'button.group',
          'gap': 'sm',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'button',
              'label': 'Open dashboard',
              'variant': 'solid',
              'action': <String, Object?>{'type': 'open_dashboard'},
            },
            <String, Object?>{
              'type': 'button',
              'label': 'Share recap',
              'variant': 'outline',
              'action': <String, Object?>{'type': 'share_recap'},
            },
          ],
        },
      ],
    },
    <String, Object?>{
      'type': 'progress',
      'value': 0.75,
      'label': 'Goal completion',
    },
    <String, Object?>{
      'type': 'timeline',
      'alignment': 'start',
      'lineStyle': 'dashed',
      'items': <Map<String, Object?>>[
        <String, Object?>{
          'title': 'Tempo run debrief',
          'subtitle': 'Added cadence drills',
          'timestamp': '2024-06-10T09:00:00Z',
          'status': <String, Object?>{'type': 'success'},
        },
        <String, Object?>{
          'title': 'Nutrition check-in',
          'subtitle': 'Updated macros',
          'timestamp': '2024-06-11T13:00:00Z',
          'status': <String, Object?>{'type': 'info'},
        },
        <String, Object?>{
          'title': 'Draft workout plan',
          'subtitle': 'Preview next block',
          'timestamp': '2024-06-12T18:00:00Z',
          'status': <String, Object?>{'type': 'pending'},
        },
      ],
    },
    <String, Object?>{
      'type': 'list',
      'gap': 'sm',
      'children': <Map<String, Object?>>[
        <String, Object?>{
          'type': 'list.item',
          'title': 'Focus',
          'subtitle': 'Aerobic base & recovery',
          'badge': 'Pinned',
          'icon': 'flag',
        },
        <String, Object?>{
          'type': 'list.item',
          'title': 'Next milestone',
          'subtitle': 'Half marathon tune up',
          'icon': 'bolt',
        },
      ],
    },
  ],
};

final Map<String, Object?> _formWidget = <String, Object?>{
  'id': 'plan_form_card',
  'type': 'card',
  'padding': 'lg',
  'background': '#FFFFFF',
  'children': <Map<String, Object?>>[
    <String, Object?>{
      'type': 'text',
      'value': 'Create training block',
      'size': 'lg',
      'weight': 'semibold',
    },
    <String, Object?>{
      'type': 'form',
      'children': <Map<String, Object?>>[
        <String, Object?>{
          'type': 'row',
          'gap': 'md',
          'wrap': 'wrap',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'input',
              'name': 'plan_name',
              'label': 'Plan name',
              'placeholder': 'Enter a title',
              'required': true,
              'errorText': 'Required field',
              'helperText': 'Visible to clients',
            },
            <String, Object?>{
              'type': 'select.single',
              'name': 'coach',
              'label': 'Assign coach',
              'defaultValue': 'coach_ada',
              'options': <Map<String, Object?>>[
                <String, Object?>{
                  'label': 'Ada Lovelace',
                  'value': 'coach_ada',
                },
                <String, Object?>{
                  'label': 'Grace Hopper',
                  'value': 'coach_grace',
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'type': 'textarea',
          'name': 'notes',
          'label': 'Notes',
          'rows': 3,
          'helperText': 'Include warmups and cooldowns',
          'defaultValue': 'Focus on even pacing and recovery.',
        },
        <String, Object?>{
          'type': 'checkbox.group',
          'name': 'focus',
          'label': 'Focus areas',
          'options': <Map<String, Object?>>[
            <String, Object?>{'label': 'Conditioning', 'value': 'conditioning'},
            <String, Object?>{'label': 'Strength', 'value': 'strength'},
            <String, Object?>{'label': 'Mobility', 'value': 'mobility'},
          ],
          'defaultValue': <String>['conditioning', 'mobility'],
        },
        <String, Object?>{
          'type': 'chips',
          'name': 'tags',
          'label': 'Tags',
          'options': <Map<String, Object?>>[
            <String, Object?>{'label': 'Week 5', 'value': 'w5'},
            <String, Object?>{'label': 'Recovery', 'value': 'recovery'},
            <String, Object?>{'label': 'Power', 'value': 'power'},
          ],
          'defaultValue': <String>['w5', 'power'],
        },
      ],
      'onSubmitAction': <String, Object?>{
        'type': 'save_plan',
        'label': 'Save plan',
      },
    },
  ],
};

final Map<String, Object?> _insightsWidget = <String, Object?>{
  'id': 'insights_panel',
  'type': 'card',
  'padding': 'lg',
  'background': '#FFFFFF',
  'children': <Map<String, Object?>>[
    <String, Object?>{
      'type': 'accordion',
      'id': 'insights_accordion',
      'allowMultiple': false,
      'items': <Map<String, Object?>>[
        <String, Object?>{
          'title': 'Recent wins',
          'subtitle': 'Week of June 10',
          'expanded': true,
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'status',
              'level': 'success',
              'message': 'Long run completed with negative split.',
            },
            <String, Object?>{
              'type': 'list',
              'gap': 'sm',
              'children': <Map<String, Object?>>[
                <String, Object?>{
                  'type': 'list.item',
                  'title': 'Mileage',
                  'subtitle': '42 km (target 40 km)',
                  'badge': '+5%',
                  'children': <Map<String, Object?>>[
                    <String, Object?>{
                      'type': 'text',
                      'value': '84% of monthly goal',
                      'size': 'sm',
                    },
                  ],
                },
                <String, Object?>{
                  'type': 'list.item',
                  'title': 'Sleep quality',
                  'subtitle': 'Average 7h 25m',
                  'icon': 'moon',
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'title': 'Risks',
          'subtitle': 'Monitor closely',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'status',
              'level': 'warning',
              'message': 'Right hamstring tightness flagged twice last week.',
            },
            <String, Object?>{
              'type': 'markdown',
              'value':
                  '- Add extra mobility after sessions\n- Reduce intensity if soreness > 4/10',
            },
          ],
        },
      ],
    },
    <String, Object?>{
      'type': 'tabs',
      'tabs': <Map<String, Object?>>[
        <String, Object?>{
          'label': 'Metrics',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'chart',
              'height': 240,
              'datasets': <Map<String, Object?>>[
                <String, Object?>{
                  'label': 'Mileage',
                  'type': 'line',
                  'color': '#2563eb',
                  'data': <Map<String, Object?>>[
                    {'x': 'Mon', 'y': 5},
                    {'x': 'Tue', 'y': 7},
                    {'x': 'Wed', 'y': 6},
                    {'x': 'Thu', 'y': 8},
                    {'x': 'Fri', 'y': 4},
                    {'x': 'Sat', 'y': 12},
                    {'x': 'Sun', 'y': 0},
                  ],
                },
                <String, Object?>{
                  'label': 'Pace',
                  'type': 'bar',
                  'color': '#f59e0b',
                  'data': <Map<String, Object?>>[
                    {'x': 'Mon', 'y': 5.2},
                    {'x': 'Tue', 'y': 5.1},
                    {'x': 'Wed', 'y': 5.3},
                    {'x': 'Thu', 'y': 5.0},
                    {'x': 'Fri', 'y': 5.6},
                    {'x': 'Sat', 'y': 4.8},
                    {'x': 'Sun', 'y': 0},
                  ],
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'label': 'Notes',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'markdown',
              'value':
                  'Coach reminder: prioritise recovery nutrition and hydration on double days.',
            },
          ],
        },
      ],
    },
    <String, Object?>{
      'type': 'carousel',
      'id': 'insights_carousel',
      'height': 200,
      'showIndicators': true,
      'showControls': true,
      'loop': false,
      'items': <Map<String, Object?>>[
        <String, Object?>{
          'title': 'Day 1 · Strength',
          'subtitle': 'Lower body focus',
          'badge': 'New',
          'tags': <String>['Gym', 'Mobility'],
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'box',
              'background': '#E0F2FE',
              'padding': 'lg',
              'radius': 20,
              'children': <Map<String, Object?>>[
                {
                  'type': 'text',
                  'value':
                      'Focus on Z2 mileage, mobility drills, and posterior-chain strength.',
                  'size': 'sm',
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'title': 'Day 3 · Speed',
          'subtitle': 'Track intervals',
          'description': '6 × 400m at 5k pace, 200m float recoveries.',
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'box',
              'background': '#FEE2E2',
              'padding': 'lg',
              'radius': 20,
              'children': <Map<String, Object?>>[
                {
                  'type': 'text',
                  'value':
                      'Include 15 minute warm-up, drills, strides, then intervals with full recovery.',
                  'size': 'sm',
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'title': 'Day 5 · Long run',
          'subtitle': 'Z2 endurance',
          'tags': <String>['Road', 'Fuel plan'],
          'children': <Map<String, Object?>>[
            <String, Object?>{
              'type': 'box',
              'background': '#DCFCE7',
              'padding': 'lg',
              'radius': 20,
              'children': <Map<String, Object?>>[
                {
                  'type': 'text',
                  'value':
                      'Negative split the final 20 minutes and practice race-day fueling.',
                  'size': 'sm',
                },
              ],
            },
          ],
        },
      ],
    },
  ],
};

final Map<String, Object?> _workflowWidget = <String, Object?>{
  'id': 'workflow_card',
  'type': 'card',
  'padding': 'lg',
  'background': '#FAFAFA',
  'children': <Map<String, Object?>>[
    <String, Object?>{
      'type': 'wizard',
      'id': 'plan_wizard',
      'nextLabel': 'Continue',
      'previousLabel': 'Back',
      'finishLabel': 'Launch plan',
      'steps': <Map<String, Object?>>[
        <String, Object?>{
          'title': 'Review goals',
          'children': <Map<String, Object?>>[
            {'type': 'text', 'value': 'Target race: Valencia Marathon'},
            {
              'type': 'definition.list',
              'items': <Map<String, Object?>>[
                {'label': 'A-goal', 'value': 'Sub 3:00'},
                {'label': 'Start date', 'value': '2024-06-24'},
              ],
            },
          ],
        },
        <String, Object?>{
          'title': 'Configure block',
          'children': <Map<String, Object?>>[
            {
              'type': 'list',
              'children': <Map<String, Object?>>[
                {
                  'type': 'list.item',
                  'title': 'Intensity split',
                  'subtitle': '75% easy / 25% quality',
                },
                {
                  'type': 'list.item',
                  'title': 'Fuel reminders',
                  'subtitle': 'Before workout & mid-run',
                  'badge': 'Coach note',
                },
              ],
            },
          ],
        },
        <String, Object?>{
          'title': 'Preview timeline',
          'children': <Map<String, Object?>>[
            {
              'type': 'timeline',
              'alignment': 'start',
              'lineStyle': 'solid',
              'items': <Map<String, Object?>>[
                {
                  'title': 'Kickoff sync',
                  'timestamp': '2024-06-25T09:00:00Z',
                  'status': {'type': 'info'},
                },
                {
                  'title': 'First assessment',
                  'timestamp': '2024-07-01T15:00:00Z',
                  'status': {'type': 'pending'},
                },
                {
                  'title': 'Deload week',
                  'timestamp': '2024-08-05T08:00:00Z',
                  'status': {'type': 'success'},
                },
              ],
            },
          ],
        },
      ],
    },
    <String, Object?>{
      'type': 'modal',
      'title': 'Coach tips',
      'trigger': {'label': 'Open preparation tips'},
      'actions': const [
        {'label': 'Mark as read', 'type': 'noop'},
      ],
      'children': <Map<String, Object?>>[
        {
          'type': 'markdown',
          'value':
              '**Hydration**: target 500ml per hour.\n\n**Mobility**: dedicate 10 minutes after each run.',
        },
      ],
    },
  ],
};

final Map<String, Object?> _carouselOnlyWidget = <String, Object?>{
  'id': 'progress_carousel',
  'type': 'carousel',
  'height': 180,
  'showIndicators': true,
  'showControls': true,
  'loop': false,
  'items': <Map<String, Object?>>[
    <String, Object?>{
      'title': 'Week 1',
      'subtitle': 'Foundation',
      'tags': <String>['Base', 'Mobility'],
      'children': <Map<String, Object?>>[
        {'type': 'text', 'value': 'Focus on Z2 mileage and drills.'},
      ],
    },
    <String, Object?>{
      'title': 'Week 2',
      'subtitle': 'Introduce strides',
      'tags': <String>['Speed'],
      'children': <Map<String, Object?>>[
        {'type': 'text', 'value': 'Add 6 × 20s strides post easy run.'},
      ],
    },
    <String, Object?>{
      'title': 'Week 3',
      'subtitle': 'Progressive long run',
      'tags': <String>['Threshold'],
      'children': <Map<String, Object?>>[
        {'type': 'text', 'value': 'Last 6 km at marathon effort.'},
      ],
    },
  ],
};

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  setUp(() {
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
        .setMockMethodCallHandler(SystemChannels.platform, (methodCall) async {
      if (methodCall.method == 'Clipboard.setData') {
        return null;
      }
      return null;
    });
  });

  tearDown(() {
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger
        .setMockMethodCallHandler(SystemChannels.platform, null);
  });

  testWidgets('dashboard widget layout golden', (tester) async {
    tester.view.devicePixelRatio = 1.0;
    tester.view.physicalSize = const Size(1600, 1200);
    addTearDown(() {
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final widgetJson = _deepCopy(_dashboardWidget);
    final item = ThreadItem(
      id: 'assistant_dashboard',
      threadId: 'thread_ui',
      createdAt: DateTime.utc(2024, 1, 1),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Preview'},
      ],
      attachments: const [],
      metadata: const {},
      raw: {
        'widget': _deepCopy(_dashboardWidget),
      },
    );

    await tester.pumpWidget(
      _buildThemedHarness(
        controller: controller,
        backgroundColor: const Color(0xFFF1F5F9),
        child: Center(
          child: SizedBox(
            width: 720,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: item,
            ),
          ),
        ),
      ),
    );
    await tester.pumpAndSettle();

    await expectLater(
      find.byType(ChatKitWidgetRenderer),
      matchesGoldenFile('goldens/dashboard_widget.png'),
    );
  });

  testWidgets('form widget layout golden', (tester) async {
    tester.view.devicePixelRatio = 1.0;
    tester.view.physicalSize = const Size(1400, 1200);
    addTearDown(() {
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final widgetJson = _deepCopy(_formWidget);
    final item = ThreadItem(
      id: 'assistant_form',
      threadId: 'thread_ui',
      createdAt: DateTime.utc(2024, 1, 1),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Form preview'},
      ],
      attachments: const [],
      metadata: const {},
      raw: {
        'widget': _deepCopy(_formWidget),
      },
    );

    await tester.pumpWidget(
      _buildThemedHarness(
        controller: controller,
        backgroundColor: const Color(0xFFF8FAFC),
        child: Center(
          child: SizedBox(
            width: 560,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: item,
            ),
          ),
        ),
      ),
    );
    await tester.pumpAndSettle();

    await expectLater(
      find.byType(ChatKitWidgetRenderer),
      matchesGoldenFile('goldens/form_widget.png'),
    );
  });

  testWidgets('insights widget layout golden', (tester) async {
    tester.view.devicePixelRatio = 1.0;
    tester.view.physicalSize = const Size(1600, 1200);
    addTearDown(() {
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final widgetJson = _deepCopy(_insightsWidget);
    final item = ThreadItem(
      id: 'insights_item',
      threadId: 'thread_ui',
      createdAt: DateTime.utc(2024, 1, 1),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Insights preview'},
      ],
      raw: {
        'widget': _deepCopy(_insightsWidget),
      },
    );

    await tester.pumpWidget(
      _buildThemedHarness(
        controller: controller,
        backgroundColor: const Color(0xFFF1F5F9),
        child: Center(
          child: SizedBox(
            width: 880,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: item,
            ),
          ),
        ),
      ),
    );
    await tester.pumpAndSettle();

    await expectLater(
      find.byType(ChatKitWidgetRenderer),
      matchesGoldenFile('goldens/insights_widget.png'),
    );
  });

  testWidgets('workflow widget layout golden', (tester) async {
    tester.view.devicePixelRatio = 1.0;
    tester.view.physicalSize = const Size(1400, 1100);
    addTearDown(() {
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final widgetJson = _deepCopy(_workflowWidget);
    final item = ThreadItem(
      id: 'workflow_item',
      threadId: 'thread_ui',
      createdAt: DateTime.utc(2024, 1, 1),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Workflow preview'},
      ],
      raw: {
        'widget': _deepCopy(_workflowWidget),
      },
    );

    await tester.pumpWidget(
      _buildThemedHarness(
        controller: controller,
        backgroundColor: const Color(0xFFF8FAFC),
        child: Center(
          child: SizedBox(
            width: 720,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: item,
            ),
          ),
        ),
      ),
    );
    await tester.pumpAndSettle();

    await expectLater(
      find.byType(ChatKitWidgetRenderer),
      matchesGoldenFile('goldens/workflow_widget.png'),
    );
  });

  testWidgets('carousel keyboard navigation updates slide index',
      (tester) async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
      apiClient: _NoopApiClient(),
    );
    addTearDown(controller.dispose);

    final widgetJson = _deepCopy(_carouselOnlyWidget);
    final item = ThreadItem(
      id: 'carousel_item',
      threadId: 'thread_ui',
      createdAt: DateTime.utc(2024, 1, 1),
      type: 'assistant_message',
      role: 'assistant',
      content: const [],
      raw: {
        'widget': _deepCopy(_carouselOnlyWidget),
      },
    );

    await tester.pumpWidget(
      _buildThemedHarness(
        controller: controller,
        child: Center(
          child: SizedBox(
            width: 480,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: item,
            ),
          ),
        ),
      ),
    );
    await tester.pumpAndSettle();

    final state = tester.state(find.byType(ChatKitWidgetRenderer)) as dynamic;
    state.debugRequestFocusForCarousel('progress_carousel');
    await tester.pump();

    final pageController =
        state.debugCarouselController('progress_carousel') as PageController;
    expect(pageController.page ?? pageController.initialPage.toDouble(), 0);

    await tester.sendKeyDownEvent(LogicalKeyboardKey.arrowRight);
    await tester.sendKeyUpEvent(LogicalKeyboardKey.arrowRight);
    await tester.pumpAndSettle();
    expect(pageController.page?.round(), 1);

    await tester.sendKeyDownEvent(LogicalKeyboardKey.arrowLeft);
    await tester.sendKeyUpEvent(LogicalKeyboardKey.arrowLeft);
    await tester.pumpAndSettle();
    expect(pageController.page?.round(), 0);
  });
}
</file>

<file path="packages/examples/coach_demo/lib/main.dart">
import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_flutter/chatkit_flutter.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const CoachDemoApp());
}

class CoachDemoApp extends StatelessWidget {
  const CoachDemoApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ChatKit Coach Demo',
      theme: ThemeData(
        useMaterial3: true,
        colorSchemeSeed: Colors.indigo,
      ),
      home: const CoachDemoScreen(),
    );
  }
}

class CoachDemoScreen extends StatefulWidget {
  const CoachDemoScreen({super.key});

  @override
  State<CoachDemoScreen> createState() => _CoachDemoScreenState();
}

class _CoachDemoScreenState extends State<CoachDemoScreen> {
  late final ChatKitController _controller;

  @override
  void initState() {
    super.initState();
    _controller = ChatKitController(_buildOptions());
  }

  ChatKitOptions _buildOptions() {
    return ChatKitOptions(
      api: const CustomApiConfig(
        url: 'http://localhost:8000/chatkit',
      ),
      history: const HistoryOption(
        enabled: true,
        showDelete: true,
        showRename: true,
      ),
      threadItemActions: const ThreadItemActionsOption(
        feedback: true,
        retry: true,
        share: true,
      ),
      startScreen: const StartScreenOption(
        greeting: 'What can Coach help you with today?',
        prompts: [
          const StartScreenPrompt(
            label: 'Plan a workout',
            prompt: 'Create a 30 minute HIIT session using body weight only.',
            icon: 'sparkle',
          ),
          const StartScreenPrompt(
            label: 'Healthy dinner ideas',
            prompt: 'Suggest three quick dinners under 600 calories.',
            icon: 'book-open',
          ),
        ],
      ),
      disclaimer: const DisclaimerOption(
        text:
            'Coach is a demo experience. Review any generated plan for accuracy before sharing.',
      ),
      composer: const ComposerOption(
        placeholder: 'Ask Coach anything…',
        attachments: const ComposerAttachmentOption(enabled: false),
        tools: const [
          ToolOption(
            id: 'browser',
            label: 'Browser',
            description: 'Search the web for current information',
            shortLabel: 'Web',
            placeholderOverride: 'Search the web for…',
          ),
          ToolOption(
            id: 'calendar',
            label: 'Calendar',
            description: 'Schedule sessions and reminders',
            shortLabel: 'Calendar',
          ),
        ],
        models: const [
          ModelOption(
            id: 'gpt-4o',
            label: 'GPT-4o',
            description: 'High quality reasoning',
            defaultSelected: true,
          ),
          ModelOption(
            id: 'gpt-4o-mini',
            label: 'GPT-4o mini',
            description: 'Faster, lower-latency responses',
          ),
        ],
      ),
      entities: EntitiesOption(
        onTagSearch: (query) async => _demoEntities
            .where(
              (entity) =>
                  entity.title.toLowerCase().contains(query.toLowerCase()),
            )
            .toList(),
        onClick: (entity) {
          debugPrint('Entity tapped: ${entity.title}');
        },
        onRequestPreview: (entity) async => EntityPreview(
          preview: _buildEntityPreview(entity),
        ),
      ),
      widgets: WidgetsOption(
        onAction: (action, widgetItem) async {
          debugPrint(
            'Widget action "${action.type}" from widget ${widgetItem.id}',
          );
        },
      ),
    );
  }

  static const List<Entity> _demoEntities = [
    Entity(
      id: 'client_ada',
      title: 'Ada Lovelace',
      group: 'Clients',
      data: {
        'kind': 'client',
        'description': 'Marathon trainee · weekly strength sessions',
      },
    ),
    Entity(
      id: 'plan_strength_01',
      title: 'Strength Plan · Phase 1',
      group: 'Plans',
      data: {
        'kind': 'plan',
        'description': '4 week foundational cycle',
      },
    ),
    Entity(
      id: 'resource_recovery',
      title: 'Recovery Guide',
      group: 'Resources',
      data: {
        'kind': 'resource',
        'description': 'Stretching and mobility routines',
      },
    ),
  ];

  static Map<String, Object?> _buildEntityPreview(Entity entity) {
    final description = entity.data['description'] as String?;
    return {
      'type': 'card',
      'children': [
        {
          'type': 'text',
          'value': entity.title,
          'size': 'lg',
          'weight': 'bold',
        },
        if (description != null)
          {
            'type': 'text',
            'value': description,
            'size': 'sm',
          },
        {
          'type': 'progress',
          'value': 0.6,
          'label': 'Completion progress',
        },
        {
          'type': 'button.group',
          'children': [
            {
              'type': 'button',
              'label': 'Open',
              'variant': 'solid',
              'action': {
                'type': 'open_entity',
                'payload': {'id': entity.id},
              },
            },
            {
              'type': 'button',
              'label': 'Assign',
              'variant': 'outline',
              'action': {
                'type': 'assign_entity',
                'payload': {'id': entity.id},
              },
            },
          ],
        },
      ],
    };
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ChatKit Coach Demo'),
        actions: [
          IconButton(
            tooltip: 'Component gallery',
            icon: const Icon(Icons.dashboard_customize_outlined),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute<void>(
                  builder: (_) => const _GalleryScreen(),
                ),
              );
            },
          ),
        ],
      ),
      body: ChatKitView(controller: _controller),
    );
  }
}

class _GalleryScreen extends StatefulWidget {
  const _GalleryScreen();

  @override
  State<_GalleryScreen> createState() => _GalleryScreenState();
}

class _GalleryScreenState extends State<_GalleryScreen> {
  Brightness _brightness = Brightness.light;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Component Gallery'),
        actions: [
          IconButton(
            tooltip: _brightness == Brightness.dark
                ? 'View light theme'
                : 'View dark theme',
            icon: Icon(
              _brightness == Brightness.dark
                  ? Icons.light_mode
                  : Icons.dark_mode,
            ),
            onPressed: () {
              setState(() {
                _brightness = _brightness == Brightness.dark
                    ? Brightness.light
                    : Brightness.dark;
              });
            },
          ),
        ],
      ),
      body: AnimatedSwitcher(
        duration: const Duration(milliseconds: 250),
        child: ChatKitGallery(
          key: ValueKey(_brightness),
          brightness: _brightness,
        ),
      ),
    );
  }
}
</file>

<file path="packages/chatkit_flutter/test/chatkit_view_test.dart">
import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:chatkit_core/src/utils/json.dart';
import 'package:chatkit_flutter/chatkit_flutter.dart';
import 'package:chatkit_flutter/src/theme/chatkit_theme.dart';
import 'package:chatkit_flutter/src/widgets/widget_renderer.dart';
import 'package:flutter/material.dart' hide Page;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

Widget _buildRendererHarness({
  required ChatKitController controller,
  required Widget body,
  Color backgroundColor = Colors.white,
  Brightness brightness = Brightness.light,
}) {
  final baseTheme = ThemeData(
    useMaterial3: true,
    brightness: brightness,
  );
  final chatTheme = ChatKitThemeData.fromOptions(
    base: baseTheme,
    option: controller.options.resolvedTheme,
    platformBrightness: brightness,
  );
  return MaterialApp(
    theme: baseTheme,
    home: ChatKitTheme(
      data: chatTheme,
      child: Theme(
        data: chatTheme.materialTheme,
        child: Scaffold(
          backgroundColor: backgroundColor,
          body: body,
        ),
      ),
    ),
  );
}

void main() {
  testWidgets('ChatKitView renders start screen by default', (tester) async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com/chatkit'),
      ),
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: Center(
          child: SizedBox(
            height: 600,
            width: 400,
            child: ChatKitView(controller: controller),
          ),
        ),
      ),
    );

    expect(find.text('What can I help with today?'), findsOneWidget);
    await controller.dispose();
  });

  testWidgets('Transition widget respects animation configuration',
      (tester) async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
    );

    final widgetJson = <String, Object?>{
      'type': 'Transition',
      'animation': 'slide',
      'direction': 'left',
      'duration': 320,
      'curve': 'easeInOut',
      'maintainState': false,
      'children': {
        'type': 'Text',
        'value': 'Animated content',
      },
    };

    final item = ThreadItem(
      id: 'item_transition',
      threadId: 'thread_transition',
      createdAt: DateTime(2024),
      type: 'widget',
      content: const [],
      attachments: const <ChatKitAttachment>[],
      metadata: const {},
      raw: {'widget': widgetJson},
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: Padding(
          padding: const EdgeInsets.all(16),
          child: ChatKitWidgetRenderer(
            widgetJson: widgetJson,
            controller: controller,
            item: item,
          ),
        ),
      ),
    );

    final switcherFinder = find.byType(AnimatedSwitcher);
    expect(switcherFinder, findsOneWidget);
    final switcher = tester.widget<AnimatedSwitcher>(switcherFinder);
    expect(switcher.duration, const Duration(milliseconds: 320));
    expect(switcher.switchInCurve, Curves.easeInOut);
    expect(switcher.switchOutCurve, Curves.easeInOut);
    expect(find.byType(SlideTransition), findsOneWidget);

    await controller.dispose();
  });

  testWidgets('History panel shows pinned section and search filters',
      (tester) async {
    final threads = <ThreadMetadata>[
      _thread(
        id: 'thread_pinned',
        title: 'Pinned Brainstorm',
        createdAt: DateTime(2024, 6, 10, 9),
        metadata: {
          'pinned': true,
          'keywords': ['brainstorm', 'roadmap'],
        },
      ),
      _thread(
        id: 'thread_recent',
        title: 'Quarterly Planning',
        createdAt: DateTime(2024, 6, 11, 12),
        metadata: {
          'keywords': ['planning'],
        },
      ),
      _thread(
        id: 'thread_shared',
        title: 'Shared Quarterly Update',
        createdAt: DateTime(2024, 6, 12, 8),
        metadata: {
          'shared': true,
          'keywords': ['shared update'],
        },
      ),
      _thread(
        id: 'thread_archived',
        title: 'Legacy Support',
        createdAt: DateTime(2024, 6, 1, 10),
        status: ThreadStatus.fromJson({'type': 'closed'}),
        metadata: {
          'keywords': ['legacy'],
        },
      ),
    ];

    final controller = _FakeChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
        history: HistoryOption(enabled: true),
        header: HeaderOption(),
      ),
      threads: threads,
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: Center(
          child: SizedBox(
            height: 700,
            width: 900,
            child: ChatKitView(controller: controller),
          ),
        ),
      ),
    );

    // Open the history panel.
    await tester.tap(find.byIcon(Icons.history));
    await tester.pumpAndSettle();

    expect(find.text('Pinned'), findsOneWidget);
    expect(find.text('Pinned Brainstorm'), findsOneWidget);
    expect(find.text('Legacy Support'), findsNothing);

    final searchField = find.byWidgetPredicate(
      (widget) =>
          widget is TextField &&
          widget.decoration?.hintText == 'Search conversations',
    );
    await tester.enterText(searchField, 'shared');
    await tester.pump(const Duration(milliseconds: 350));
    await tester.pumpAndSettle();

    expect(find.text('Shared Quarterly Update'), findsOneWidget);
    expect(find.text('Pinned Brainstorm'), findsNothing);

    await controller.dispose();
  });

  testWidgets('Entity picker supports keyboard navigation and selection',
      (tester) async {
    final entities = <Entity>[
      const Entity(
        id: 'entity_acme',
        title: 'Acme Inc.',
        data: {'description': 'Key account'},
      ),
      const Entity(
        id: 'entity_globex',
        title: 'Globex Corp',
        data: {'description': 'Supplier'},
      ),
      const Entity(
        id: 'entity_initech',
        title: 'Initech',
        data: {'description': 'Manufacturing partner'},
      ),
    ];

    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com'),
        entities: EntitiesOption(
          onTagSearch: (query) => entities
              .where(
                (entity) =>
                    entity.title.toLowerCase().contains(query.toLowerCase()),
              )
              .toList(),
        ),
        history: const HistoryOption(enabled: false),
      ),
      apiClient: _NoopApiClient(),
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: Center(
          child: SizedBox(
            height: 700,
            width: 900,
            child: ChatKitView(controller: controller),
          ),
        ),
      ),
    );

    // Open the entity picker via the composer shortcut button.
    await tester.tap(find.byTooltip('Add tag'));
    await tester.pumpAndSettle();

    final searchField = find.byWidgetPredicate(
      (widget) =>
          widget is TextField &&
          widget.decoration?.hintText == 'Search entities',
    );
    await tester.tap(searchField);
    await tester.pump();
    await tester.enterText(searchField, 'c');
    await tester.pump(const Duration(milliseconds: 250));
    await tester.pump();

    final acmeTile = find.widgetWithText(ListTile, 'Acme Inc.');
    expect(tester.widget<ListTile>(acmeTile).selected, isTrue);

    await tester.sendKeyEvent(LogicalKeyboardKey.arrowDown);
    await tester.pump();

    final globexTile = find.widgetWithText(ListTile, 'Globex Corp');
    expect(tester.widget<ListTile>(acmeTile).selected, isFalse);
    expect(tester.widget<ListTile>(globexTile).selected, isTrue);

    await tester.sendKeyEvent(LogicalKeyboardKey.enter);
    await tester.pumpAndSettle();

    expect(find.byType(AlertDialog), findsNothing);
    expect(find.widgetWithText(InputChip, 'Globex Corp'), findsOneWidget);

    await controller.dispose();
  });

  testWidgets('custom share target invokes handler and shows toast',
      (tester) async {
    ShareTargetInvocation? invocation;
    final controller = ChatKitController(
      ChatKitOptions(
        api: const CustomApiConfig(url: 'https://example.com'),
        threadItemActions: ThreadItemActionsOption(
          share: true,
          shareActions: ShareActionsOption(
            targets: const [
              ShareTargetOption(
                id: 'crm',
                label: 'Send to CRM',
                type: ShareTargetType.custom,
                toast: 'Shared to CRM.',
              ),
            ],
            onSelectTarget: (event) {
              invocation = event;
            },
          ),
        ),
      ),
      apiClient: _NoopApiClient(),
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: ChatKitView(controller: controller),
      ),
    );

    final item = ThreadItem(
      id: 'item_1',
      threadId: 'thread_1',
      createdAt: DateTime(2024),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'output_text', 'text': 'Hello world'},
      ],
    );
    controller.debugHandleStreamEvent(ThreadItemAddedEvent(item: item));
    await tester.pump();

    final state = tester.state(find.byType(ChatKitView)) as dynamic;
    final target = const ShareTargetOption(
      id: 'crm',
      label: 'Send to CRM',
      type: ShareTargetType.custom,
      toast: 'Shared to CRM.',
    );

    await state.debugPerformShareTarget(
      target: target,
      shareText: 'Hello world',
      shareActions: ShareActionsOption(
        onSelectTarget: (event) {
          invocation = event;
        },
      ),
    );
    await tester.pump();
    await tester.pump(const Duration(milliseconds: 200));

    expect(invocation, isNotNull);
    expect(invocation!.targetId, 'crm');
    expect(find.text('Shared to CRM.'), findsOneWidget);

    await controller.dispose();
  });

  testWidgets('default share workflow copies content and toasts',
      (tester) async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
        threadItemActions: ThreadItemActionsOption(share: true),
      ),
      apiClient: _NoopApiClient(),
    );
    final events = <ChatKitEvent>[];
    final subscription = controller.events.listen(events.add);
    const channel = SystemChannels.platform;
    final messenger =
        TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger;
    messenger.setMockMethodCallHandler(
      channel,
      (methodCall) async {
        if (methodCall.method == 'Clipboard.setData') {
          return null;
        }
        return null;
      },
    );

    addTearDown(() async {
      messenger.setMockMethodCallHandler(channel, null);
      await subscription.cancel();
      await controller.dispose();
    });

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: ChatKitView(controller: controller),
      ),
    );

    final item = ThreadItem(
      id: 'share_item',
      threadId: 'thread_share',
      createdAt: DateTime(2024),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'text', 'text': 'Shareable insight about training.'},
      ],
    );
    controller.debugHandleStreamEvent(ThreadItemAddedEvent(item: item));
    await tester.pump();

    controller.shareItem(item.id);
    await tester.pump();
    await tester.pump(const Duration(milliseconds: 500));
    expect(
      events.any(
        (event) => event is ChatKitShareEvent && event.itemId == item.id,
      ),
      isTrue,
    );

    var foundCopy = false;
    for (var i = 0; i < 10 && !foundCopy; i++) {
      await tester.pump(const Duration(milliseconds: 100));
      foundCopy = find.text('Copy to clipboard').evaluate().isNotEmpty;
    }
    if (!foundCopy) {
      final debugTexts = tester
          .widgetList<Text>(find.byType(Text))
          .map((widget) => widget.data)
          .whereType<String>()
          .toList();
      // ignore: avoid_print
      print('available texts: ' + debugTexts.join(' | '));
    }
    expect(foundCopy, isTrue);
    await tester.tap(find.text('Copy to clipboard'));
    await tester.pump();
    await tester.pump(const Duration(milliseconds: 200));

    expect(find.text('Message copied to clipboard.'), findsOneWidget);
  });

  testWidgets('ChatKitView hides hidden context items when configured',
      (tester) async {
    final controller = ChatKitController(
      const ChatKitOptions(
        api: CustomApiConfig(url: 'https://example.com'),
      ),
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: ChatKitView(
          controller: controller,
          hideHiddenItems: true,
        ),
      ),
    );

    controller.debugHandleStreamEvent(
      ThreadCreatedEvent(
        thread: Thread(
          metadata: ThreadMetadata(
            id: 'thread_test',
            title: 'Test thread',
            createdAt: DateTime(2024),
            status: ThreadStatus.fromJson({'type': 'active'}),
            metadata: const {},
          ),
        ),
      ),
    );
    await tester.pump();

    final visible = ThreadItem(
      id: 'item_visible',
      threadId: 'thread_test',
      createdAt: DateTime(2024),
      type: 'assistant_message',
      role: 'assistant',
      content: const [
        {'type': 'text', 'text': 'Visible assistant message'},
      ],
    );
    final hidden = ThreadItem(
      id: 'item_hidden',
      threadId: 'thread_test',
      createdAt: DateTime(2024),
      type: 'hidden_context',
      role: 'assistant',
      content: const [
        {'type': 'text', 'text': 'Hidden payload'},
      ],
    );

    controller.debugHandleStreamEvent(ThreadItemAddedEvent(item: hidden));
    controller.debugHandleStreamEvent(ThreadItemAddedEvent(item: visible));
    await tester.pump();
    await tester.pump(const Duration(milliseconds: 200));

    final state = tester.state(find.byType(ChatKitView)) as dynamic;
    final items = state.debugVisibleItems() as List<ThreadItem>;

    expect(items.any((item) => item.id == hidden.id), isFalse);
    expect(items.any((item) => item.id == visible.id), isTrue);
    await controller.dispose();
  });

  testWidgets('Form submission nests payload keys', (tester) async {
    final controller = _CapturingController();
    final widgetJson = {
      'type': 'form',
      'onSubmitAction': {
        'type': 'form.submit',
        'label': 'Submit',
      },
      'children': [
        {
          'type': 'input',
          'name': 'profile.name',
          'label': 'Name',
        },
        {
          'type': 'input',
          'name': 'profile[address][city]',
          'label': 'City',
        },
        {
          'type': 'input',
          'name': 'phones[0]',
          'label': 'Primary Phone',
        },
        {
          'type': 'checkbox',
          'name': 'flags[marketing]',
          'label': 'Marketing Opt-in',
        },
      ],
    };

    final item = ThreadItem(
      id: 'item_form',
      threadId: 'thread_form',
      createdAt: DateTime(2024),
      type: 'widget',
      content: const [],
      attachments: const <ChatKitAttachment>[],
      metadata: const {},
      raw: {'widget': widgetJson},
    );

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: Padding(
          padding: const EdgeInsets.all(16),
          child: ChatKitWidgetRenderer(
            widgetJson: widgetJson,
            controller: controller,
            item: item,
          ),
        ),
      ),
    );

    final nameField = find.byWidgetPredicate(
      (widget) => widget is TextField && widget.decoration?.labelText == 'Name',
    );
    final cityField = find.byWidgetPredicate(
      (widget) => widget is TextField && widget.decoration?.labelText == 'City',
    );
    final phoneField = find.byWidgetPredicate(
      (widget) =>
          widget is TextField &&
          widget.decoration?.labelText == 'Primary Phone',
    );

    await tester.enterText(nameField, 'Alice');
    await tester.enterText(cityField, 'Paris');
    await tester.enterText(phoneField, '+33123456789');

    final marketingCheckbox =
        find.widgetWithText(CheckboxListTile, 'Marketing Opt-in');
    await tester.tap(marketingCheckbox);

    await tester.tap(find.widgetWithText(FilledButton, 'Submit'));
    await tester.pump();

    final action = controller.lastAction;
    expect(action, isNotNull);
    final payload = castMap(action!['payload']);
    final form = castMap(payload['form']);
    final profile = castMap(form['profile']);
    final address = castMap(profile['address']);
    expect(profile['name'], 'Alice');
    expect(address['city'], 'Paris');

    final phones = (form['phones'] as List?)?.cast<Object?>() ?? const [];
    expect(phones, equals(['+33123456789']));

    final flags = castMap(form['flags']);
    expect(flags['marketing'], isTrue);

    final flat = castMap(payload['formFlat']);
    expect(flat['profile.name'], 'Alice');
    expect(flat['profile[address][city]'], 'Paris');

    await controller.dispose();
  });

  testWidgets('attachment ingestion and retry update composer state',
      (tester) async {
    final controller = _StubUploadController();
    tester.view.physicalSize = const Size(1600, 1200);
    tester.view.devicePixelRatio = 1.0;
    addTearDown(() {
      tester.view.resetPhysicalSize();
      tester.view.resetDevicePixelRatio();
    });

    await tester.pumpWidget(
      _buildRendererHarness(
        controller: controller,
        body: ChatKitView(controller: controller),
      ),
    );

    final state = tester.state(find.byType(ChatKitView)) as dynamic;
    state.debugSuppressSnackbars = true;
    await state.debugAddAttachment(
      name: 'sample.txt',
      bytes: Uint8List.fromList('hello'.codeUnits),
      mimeType: 'text/plain',
    );
    await tester.pump();

    expect(controller.composerState.attachments.length, 1);
    expect(controller.composerState.attachments.first.name, 'sample.txt');

    controller.failNextUpload = true;
    await state.debugAddAttachment(
      name: 'retry.txt',
      bytes: Uint8List.fromList('retry'.codeUnits),
      mimeType: 'text/plain',
    );
    await tester.pump();

    expect(controller.composerState.attachments.length, 1);
    expect(find.text('Attachment upload failed.'), findsOneWidget);
    expect(find.text('Retry upload'), findsOneWidget);

    controller.failNextUpload = false;
    final pendingUpload = (state.debugPendingUploads as List)
        .cast<dynamic>()
        .firstWhere((upload) => upload.error != null);
    await state.debugRetryUpload(pendingUpload);
    await tester.pump();
    await tester.pump(const Duration(milliseconds: 20));

    expect(controller.composerState.attachments.length, 2);
    expect(
      controller.composerState.attachments.last.name,
      'retry.txt',
    );

    await controller.dispose();
  }, skip: true);
}

ThreadMetadata _thread({
  required String id,
  required String title,
  required DateTime createdAt,
  ThreadStatus? status,
  Map<String, Object?> metadata = const {},
}) {
  return ThreadMetadata(
    id: id,
    title: title,
    createdAt: createdAt,
    status: status ?? ThreadStatus.fromJson({'type': 'active'}),
    metadata: metadata,
  );
}

class _NoopApiClient extends ChatKitApiClient {
  _NoopApiClient()
      : super(
          apiConfig: const CustomApiConfig(url: 'https://example.com'),
        );

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    throw UnimplementedError('Network calls are not supported in widget tests');
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    throw UnimplementedError(
        'Streaming calls are not supported in widget tests');
  }

  @override
  Future<void> close() async {}
}

class _CapturingController extends ChatKitController {
  _CapturingController()
      : super(
          const ChatKitOptions(
            api: CustomApiConfig(url: 'https://example.com'),
          ),
          apiClient: _NoopApiClient(),
        );

  Map<String, Object?>? lastAction;
  String? lastItemId;

  @override
  Future<void> sendCustomAction(
    Map<String, Object?> action, {
    String? itemId,
  }) async {
    lastAction = action;
    lastItemId = itemId;
  }
}

class _FakeChatKitController extends ChatKitController {
  _FakeChatKitController(
    ChatKitOptions options, {
    required List<ThreadMetadata> threads,
  })  : _threads = threads,
        super(options, apiClient: _NoopApiClient());

  List<ThreadMetadata> _threads;

  @override
  Future<Page<ThreadMetadata>> listThreads({
    int limit = 20,
    String? after,
    String order = 'desc',
    String? section,
    String? query,
    bool? pinnedOnly,
    Map<String, Object?> metadata = const {},
  }) async {
    Iterable<ThreadMetadata> filtered = _threads;

    if (section != null && section.isNotEmpty) {
      final normalized = section.toLowerCase();
      filtered = filtered.where((thread) {
        final statusType = thread.status.type;
        if (normalized == 'archived') {
          return statusType == 'closed';
        }
        if (normalized == 'shared') {
          return _isShared(thread);
        }
        if (normalized == 'recent') {
          return statusType != 'closed';
        }
        return true;
      });
    }

    if (query != null && query.trim().isNotEmpty) {
      final q = query.trim().toLowerCase();
      filtered = filtered.where((thread) {
        if ((thread.title ?? '').toLowerCase().contains(q)) {
          return true;
        }
        if (thread.id.toLowerCase().contains(q)) {
          return true;
        }
        final keywords = thread.metadata['keywords'];
        if (keywords is List) {
          for (final keyword in keywords) {
            if (keyword is String && keyword.toLowerCase().contains(q)) {
              return true;
            }
          }
        }
        final description = thread.metadata['description'];
        if (description is String && description.toLowerCase().contains(q)) {
          return true;
        }
        return false;
      });
    }

    if (pinnedOnly == true) {
      filtered = filtered.where(_isPinned);
    }

    final sorted = filtered.toList();
    if (order == 'desc') {
      sorted.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    } else {
      sorted.sort((a, b) => a.createdAt.compareTo(b.createdAt));
    }

    if (after != null) {
      final index = sorted.indexWhere((thread) => thread.id == after);
      if (index != -1 && index + 1 < sorted.length) {
        sorted.removeRange(0, index + 1);
      } else if (index != -1) {
        sorted.clear();
      }
    }

    final items = sorted.take(limit).toList();
    final hasMore = sorted.length > limit;
    final nextAfter = hasMore ? items.last.id : null;

    return Page<ThreadMetadata>(
      data: items,
      hasMore: hasMore,
      after: nextAfter,
    );
  }

  bool _isPinned(ThreadMetadata thread) {
    final pinned = thread.metadata['pinned'];
    return _truthy(pinned);
  }

  bool _isShared(ThreadMetadata thread) {
    final shared = thread.metadata['shared'];
    if (_truthy(shared)) {
      return true;
    }
    final visibility = thread.metadata['visibility'];
    return visibility is String && visibility.toLowerCase() == 'shared';
  }

  bool _truthy(Object? value) {
    if (value is bool) return value;
    if (value is num) return value != 0;
    if (value is String) {
      final normalized = value.trim().toLowerCase();
      return normalized == 'true' ||
          normalized == '1' ||
          normalized == 'yes' ||
          normalized == 'y';
    }
    return false;
  }
}

class _StubUploadController extends ChatKitController {
  _StubUploadController()
      : super(
          const ChatKitOptions(
            api: const CustomApiConfig(url: 'https://example.com'),
            composer: const ComposerOption(
              attachments: ComposerAttachmentOption(enabled: true),
            ),
          ),
          apiClient: _NoopApiClient(),
        );

  bool failNextUpload = false;

  @override
  Future<ChatKitAttachment> registerAttachment({
    required String name,
    required List<int> bytes,
    required String mimeType,
    int? size,
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
  }) async {
    if (failNextUpload) {
      failNextUpload = false;
      throw Exception('upload failed');
    }
    return FileAttachment(
      id: 'attachment_${DateTime.now().microsecondsSinceEpoch}',
      name: name,
      mimeType: mimeType,
      size: size,
    );
  }
}
</file>

<file path="packages/chatkit_core/test/offline_queue_test.dart">
import 'dart:async';
import 'dart:io';

import 'package:chatkit_core/chatkit_core.dart';
import 'package:chatkit_core/src/api/api_client.dart';
import 'package:test/test.dart';

class _FakeChatKitApiClient extends ChatKitApiClient {
  _FakeChatKitApiClient({this.failuresBeforeSuccess = 0})
      : super(apiConfig: const CustomApiConfig(url: 'https://fake.local'));

  int failuresBeforeSuccess;
  int streamingInvocations = 0;

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.get_by_id') {
      final now = DateTime.now().toUtc().toIso8601String();
      final threadId = request.params['thread_id'] as String? ?? 'thread';
      return {
        'id': threadId,
        'title': 'Thread $threadId',
        'created_at': now,
        'status': {'type': 'active'},
        'items': {
          'data': <Map<String, Object?>>[],
          'after': null,
          'has_more': false,
        },
      };
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    streamingInvocations += 1;
    if (streamingInvocations <= failuresBeforeSuccess) {
      throw const SocketException('offline');
    }

    if (request.type == 'threads.add_user_message') {
      final threadId = request.params['thread_id'] as String? ?? 'thread';
      await onEvent(
        ThreadItemAddedEvent(
          item: ThreadItem(
            id: 'msg_$streamingInvocations',
            threadId: threadId,
            createdAt: DateTime.now(),
            type: 'user_message',
            role: 'user',
            content: const [],
            attachments: const [],
            metadata: const {},
            raw: const {},
          ),
        ),
      );
    }
    onDone?.call();
  }
}

void main() {
  group('ChatKitController offline queue', () {
    test('queues streaming request and flushes when connectivity returns',
        () async {
      final apiClient = _FakeChatKitApiClient(failuresBeforeSuccess: 5);
      final controller = ChatKitController(
        const ChatKitOptions(api: CustomApiConfig(url: 'https://fake.local')),
        apiClient: apiClient,
      );
      addTearDown(controller.dispose);

      await controller.setThreadId('thread_1');
      expect(controller.threadItems, isEmpty);

      await controller.sendUserMessage(text: 'hello');

      expect(apiClient.streamingInvocations, greaterThanOrEqualTo(1));
      expect(controller.threadItems.length, greaterThanOrEqualTo(1));

      // Restore connectivity so the queued request can succeed.
      apiClient.failuresBeforeSuccess = 0;

      // Allow the queued request to retry.
      await Future<void>.delayed(const Duration(milliseconds: 100));
      await Future<void>.delayed(const Duration(seconds: 2));
      await Future<void>.delayed(const Duration(milliseconds: 100));

      expect(apiClient.streamingInvocations, greaterThanOrEqualTo(2));
      expect(
        controller.threadItems
            .where((item) => item.metadata['pending'] == true),
        isEmpty,
      );
      expect(
        controller.threadItems.where((item) => item.type == 'user_message'),
        isNotEmpty,
      );
    });

    test('clears pending placeholder when thread.item.done arrives', () async {
      final apiClient = _SilentChatKitApiClient();
      final controller = ChatKitController(
        const ChatKitOptions(api: CustomApiConfig(url: 'https://fake.local')),
        apiClient: apiClient,
      );
      addTearDown(controller.dispose);

      await controller.setThreadId('thread_done_only');
      await controller.sendUserMessage(text: 'ack me');

      final pendingBefore = controller.threadItems
          .where((item) => item.metadata['pending'] == true)
          .toList();
      expect(pendingBefore, hasLength(1));

      final pending = pendingBefore.single;
      controller.debugHandleStreamEvent(
        ThreadItemDoneEvent(
          item: ThreadItem(
            id: 'server-confirmed',
            threadId: pending.threadId,
            createdAt: pending.createdAt.add(const Duration(milliseconds: 500)),
            type: 'user_message',
            role: pending.role,
            content: pending.content,
            attachments: pending.attachments,
            metadata: const {},
            raw: const {},
          ),
        ),
      );

      expect(
        controller.threadItems
            .where((item) => item.metadata['pending'] == true),
        isEmpty,
      );
      expect(
        controller.threadItems.where((item) => item.id == 'server-confirmed'),
        hasLength(1),
      );
    });
  });

  group('ChatKitController user message reconciliation', () {
    test('replaces pending placeholder when server echoes generic message',
        () async {
      final controller = ChatKitController(
        const ChatKitOptions(api: CustomApiConfig(url: 'https://fake.local')),
        apiClient: _SilentChatKitApiClient(),
      );
      addTearDown(controller.dispose);

      await controller.setThreadId('thread_ack_generic');
      expect(controller.threadItems, isEmpty);

      await controller.sendUserMessage(text: 'hello');
      final pendingItems = controller.threadItems;
      expect(pendingItems, hasLength(1));
      expect(pendingItems.single.metadata['pending'], isTrue);

      controller.debugHandleStreamEvent(
        ThreadItemAddedEvent(
          item: ThreadItem(
            id: 'ack_generic',
            threadId: 'thread_ack_generic',
            createdAt: DateTime.now(),
            type: 'message',
            role: 'user',
            content: const [
              {'type': 'input_text', 'text': 'hello'},
            ],
            attachments: const [],
            metadata: const {},
            raw: const {},
          ),
        ),
      );

      final items = controller.threadItems;
      expect(items, hasLength(1));
      final item = items.single;
      expect(item.id, equals('ack_generic'));
      expect(item.metadata['pending'], isNot(true));
      expect(item.type, equals('message'));
    });

    test('replaces pending placeholder when server uses input_message type',
        () async {
      final controller = ChatKitController(
        const ChatKitOptions(api: CustomApiConfig(url: 'https://fake.local')),
        apiClient: _SilentChatKitApiClient(),
      );
      addTearDown(controller.dispose);

      await controller.setThreadId('thread_ack_input');
      await controller.sendUserMessage(text: 'hello');
      expect(
        controller.threadItems
            .where((item) => item.metadata['pending'] == true),
        isNotEmpty,
      );

      controller.debugHandleStreamEvent(
        ThreadItemAddedEvent(
          item: ThreadItem(
            id: 'ack_input',
            threadId: 'thread_ack_input',
            createdAt: DateTime.now(),
            type: 'input_message',
            role: null,
            content: const [
              {'type': 'input_text', 'text': 'hello'},
            ],
            attachments: const [],
            metadata: const {},
            raw: const {},
          ),
        ),
      );

      expect(
        controller.threadItems
            .where((item) => item.metadata['pending'] == true),
        isEmpty,
      );
      expect(
        controller.threadItems.where((item) => item.id == 'ack_input'),
        isNotEmpty,
      );
    });
  });
}

class _SilentChatKitApiClient extends ChatKitApiClient {
  _SilentChatKitApiClient()
      : super(apiConfig: const CustomApiConfig(url: 'https://fake.local'));

  @override
  Future<Map<String, Object?>> send(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    if (request.type == 'threads.get_by_id') {
      final now = DateTime.now().toUtc().toIso8601String();
      final threadId = request.params['thread_id'] as String? ?? 'thread';
      return {
        'id': threadId,
        'title': 'Thread $threadId',
        'created_at': now,
        'status': {'type': 'active'},
        'items': {
          'data': <Map<String, Object?>>[],
          'after': null,
          'has_more': false,
        },
      };
    }
    return const {};
  }

  @override
  Future<void> sendStreaming(
    ChatKitRequest request, {
    required StreamEventCallback onEvent,
    void Function()? onDone,
    void Function(Object error, StackTrace stackTrace)? onError,
    Duration? keepAliveTimeout,
    void Function()? onKeepAliveTimeout,
    void Function(Duration duration)? onRetrySuggested,
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    onDone?.call();
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/widgets/widget_renderer.dart">
import 'dart:async';
import 'dart:convert';
import 'dart:math' as math;

// ignore_for_file: deprecated_member_use

import 'package:cached_network_image/cached_network_image.dart';
import 'package:chatkit_core/chatkit_core.dart';
import 'package:collection/collection.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:latlong2/latlong.dart';
import 'package:signature/signature.dart';
import 'package:smooth_page_indicator/smooth_page_indicator.dart';

import '../theme/chatkit_theme.dart';
import '../theme/icons.dart';
import '../theme/styles.dart';
import 'media_player.dart';

class ChatKitWidgetRenderer extends StatefulWidget {
  const ChatKitWidgetRenderer({
    super.key,
    required this.widgetJson,
    required this.controller,
    required this.item,
  });

  final Map<String, Object?> widgetJson;
  final ChatKitController controller;
  final ThreadItem item;

  @override
  State<ChatKitWidgetRenderer> createState() => _ChatKitWidgetRendererState();
}

class _ChatKitWidgetRendererState extends State<ChatKitWidgetRenderer> {
  ChatKitThemeData _chatThemeOf(BuildContext context) =>
      ChatKitTheme.of(context);

  static const _defaultTransitionAnimation = 'fade';
  static const _defaultSwitchInCurve = Curves.easeOutCubic;
  static const _defaultSwitchOutCurve = Curves.easeInCubic;

  static const Widget _emptyTransitionChild =
      SizedBox.shrink(key: ValueKey('__transition.empty__'));
  static const Map<String, double> _spacingScale = {
    'none': 0,
    '0': 0,
    '2xs': 4,
    'xs': 8,
    'sm': 12,
    'md': 16,
    'lg': 24,
    'xl': 32,
    '2xl': 40,
    '3xl': 48,
    '4xl': 56,
  };

  final Map<String, TextEditingController> _textControllers = {};
  final Map<String, bool> _boolValues = {};
  final Map<String, Set<Object?>> _multiSelectValues = {};
  final Map<String, Object?> _formState = {};
  final Map<String, double> _sliderValues = {};
  final Map<String, int> _stepperValues = {};
  final Map<String, SignatureController> _signatureControllers = {};
  final Map<String, List<TextEditingController>> _otpControllers = {};
  final Map<String, PageController> _pageControllers = {};
  final Map<String, bool> _accordionExpanded = {};
  final Map<String, int> _wizardStepIndex = {};
  final Map<String, Timer> _carouselTimers = {};
  final Map<String, FocusNode> _carouselFocusNodes = {};
  final Map<String, _TableSortState> _tableSortStates = {};
  final Map<String, FocusNode> _selectFocusNodes = {};
  final Map<String, Timer> _selectSearchDebounce = {};
  final Map<String, String> _selectSearchQuery = {};
  final Map<String, Map<String, Object?>> _formComponents = {};
  final Map<String, String> _fieldErrors = {};
  final Set<String> _touchedFields = {};
  final Set<Map<String, Object?>> _pendingSelfActions = {};
  int _containerLoadingDepth = 0;
  String? _cardActionPendingKey;

  @override
  void dispose() {
    for (final controller in _textControllers.values) {
      controller.dispose();
    }
    for (final controllers in _otpControllers.values) {
      for (final controller in controllers) {
        controller.dispose();
      }
    }
    for (final controller in _signatureControllers.values) {
      controller.dispose();
    }
    for (final controller in _pageControllers.values) {
      controller.dispose();
    }
    for (final timer in _carouselTimers.values) {
      timer.cancel();
    }
    for (final node in _carouselFocusNodes.values) {
      node.dispose();
    }
    for (final node in _selectFocusNodes.values) {
      node.dispose();
    }
    for (final timer in _selectSearchDebounce.values) {
      timer.cancel();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final content = _buildComponent(widget.widgetJson, context);
    if (_containerLoadingDepth > 0) {
      return Stack(
        children: [
          AnimatedOpacity(
            opacity: 0.5,
            duration: const Duration(milliseconds: 150),
            child: AbsorbPointer(
              absorbing: true,
              child: content,
            ),
          ),
          const Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(color: Color(0x0F000000)),
            ),
          ),
          const Positioned.fill(
            child: IgnorePointer(
              child: Center(
                child: SizedBox(
                  height: 36,
                  width: 36,
                  child: CircularProgressIndicator(strokeWidth: 3),
                ),
              ),
            ),
          ),
        ],
      );
    }
    return content;
  }

  Widget _buildComponent(Map<String, Object?> component, BuildContext context) {
    final type = (component['type'] as String? ?? '').toLowerCase();
    switch (type) {
      case 'card':
        return _buildCard(component, context);
      case 'hero':
        return _buildHero(component, context);
      case 'section':
      case 'stack':
      case 'box':
      case 'basic':
      case 'column':
      case 'col':
      case 'row':
        return _buildFlexContainer(component, context);
      case 'transition':
        return _buildTransition(component, context);
      case 'text':
      case 'caption':
      case 'label':
      case 'title':
        return _buildText(component, context);
      case 'markdown':
        return _buildMarkdown(component, context);
      case 'image':
        return _buildImage(component, context);
      case 'button':
        return _buildButton(component, context);
      case 'button.group':
      case 'buttongroup':
        return _buildButtonGroup(component, context);
      case 'list':
      case 'listview':
        return _buildList(component, context);
      case 'list.item':
      case 'listviewitem':
        return _buildListItem(component, context);
      case 'form':
        return _buildForm(component, context);
      case 'input':
      case 'textarea':
      case 'select':
      case 'select.single':
      case 'select.multi':
      case 'select.native':
      case 'checkbox':
      case 'checkbox.group':
      case 'toggle':
      case 'radio.group':
      case 'radiogroup':
      case 'radiogroup':
      case 'date.picker':
      case 'datepicker':
      case 'datepicker':
      case 'chips':
        return _buildFormControl(component, context);
      case 'timeline':
        return _buildTimeline(component, context);
      case 'timeline.item':
        return _buildTimelineItem(component, context);
      case 'rating':
        return _buildRating(component, context);
      case 'carousel':
        return _buildCarousel(component, context);
      case 'metadata':
        return _buildMetadata(component, context);
      case 'progress':
        return _buildProgress(component, context);
      case 'icon':
        return _buildIcon(component, context);
      case 'icon.only':
        return _buildIcon(component, context, iconOnly: true);
      case 'badge':
        return _buildBadge(component, context);
      case 'spacer':
        return _buildSpacer(component);
      case 'definition.list':
      case 'definitionlist':
      case 'list.definition':
        return _buildDefinitionList(component, context);
      case 'paginator':
      case 'pagination':
        return _buildPagination(component, context);
      case 'accordion':
        return _buildAccordion(component, context);
      case 'accordion.item':
        return _buildAccordionItem(component, context);
      case 'modal':
      case 'overlay':
        return _buildModal(component, context);
      case 'wizard':
      case 'stepper':
        return _buildWizard(component, context);
      case 'wizard.step':
      case 'step':
        return _buildWizardStep(component, context);
      case 'segmented':
      case 'segmented.control':
        return _buildSegmentedControl(component, context);
      case 'file.viewer':
      case 'fileviewer':
        return _buildFileViewer(component, context);
      case 'divider':
        return const Divider();
      case 'code':
        return _buildCode(component, context);
      case 'blockquote':
        return _buildBlockquote(component, context);
      case 'pill':
        return _buildPill(component, context);
      case 'table':
        return _buildTable(component, context);
      case 'tabs':
        return _buildTabs(component, context);
      case 'chart':
        return _buildChart(component, context);
      case 'video':
        return _buildVideo(component, context);
      case 'audio':
        return _buildAudio(component, context);
      case 'map':
        return _buildMap(component, context);
      case 'status':
        return _buildStatus(component, context);
      default:
        return Text('Unsupported widget type ${component['type']}');
    }
  }

  Widget _buildCard(Map<String, Object?> component, BuildContext context) {
    final chatTheme = _chatThemeOf(context);
    final spacing = chatTheme.spacing;
    final children = _buildChildren(component['children'], context);
    final sizeToken = (component['size'] as String? ?? 'md').toLowerCase();
    final padding = _edgeInsets(component['padding'], context) ??
        _cardPaddingForSize(sizeToken, spacing: spacing);
    final margin = _edgeInsets(component['margin'], context) ??
        _spacingSymmetric(context, vertical: 6);
    final background = _colorFromToken(context, component['background']);
    final status = _buildWidgetStatus(component['status'], context);
    final asForm = component['asForm'] as bool? ?? false;
    final collapsed = component['collapsed'] as bool? ?? false;
    final confirmConfig = castMap(component['confirm']);
    final cancelConfig = castMap(component['cancel']);
    final themeOverride = (component['theme'] as String?)?.toLowerCase().trim();
    final cardIdentifier =
        component['id'] as String? ?? component['key'] as String? ?? 'card';

    final footerButtons = <Widget>[];
    if (cancelConfig.isNotEmpty) {
      footerButtons.add(
        _buildCardActionButton(
          context: context,
          label: cancelConfig['label'] as String? ?? 'Cancel',
          action: castMap(cancelConfig['action']),
          includeForm: asForm,
          isPrimary: false,
          actionKey: '$cardIdentifier:cancel',
        ),
      );
    }
    if (confirmConfig.isNotEmpty) {
      footerButtons.add(
        _buildCardActionButton(
          context: context,
          label: confirmConfig['label'] as String? ?? 'Confirm',
          action: castMap(confirmConfig['action']),
          includeForm: asForm,
          isPrimary: true,
          actionKey: '$cardIdentifier:confirm',
        ),
      );
    }

    final bodyChildren = <Widget>[
      if (status != null)
        Padding(
          padding: _spacingOnly(context, bottom: 12),
          child: status,
        ),
      if (!collapsed) ...children,
      if (footerButtons.isNotEmpty)
        Padding(
          padding: _spacingOnly(context, top: 16),
          child: Wrap(
            spacing: spacing.sm,
            runSpacing: spacing.xs,
            alignment: WrapAlignment.end,
            children: footerButtons,
          ),
        ),
    ];

    Widget card = Card(
      margin: margin,
      color: background,
      child: Padding(
        padding: padding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: bodyChildren,
        ),
      ),
    );

    if (themeOverride == 'light' || themeOverride == 'dark') {
      final brightness =
          themeOverride == 'dark' ? Brightness.dark : Brightness.light;
      final theme = Theme.of(context);
      card = Theme(
        data: theme.copyWith(
          colorScheme: theme.colorScheme.copyWith(brightness: brightness),
          brightness: brightness,
        ),
        child: card,
      );
    }

    return card;
  }

  Widget _buildHero(Map<String, Object?> component, BuildContext context) {
    final children = _buildChildren(component['children'], context);
    final imageUrl =
        component['image'] as String? ?? component['background'] as String?;
    final title = component['title'] as String?;
    final subtitle = component['subtitle'] as String?;
    final chatTheme = _chatThemeOf(context);
    final palette = chatTheme.palette;
    final theme = Theme.of(context);
    final hasImage = imageUrl != null;
    final onColor = hasImage
        ? theme.colorScheme.onPrimary
        : theme.colorScheme.onPrimaryContainer;
    final subtitleColor = onColor.withValues(alpha: 0.7);
    return Container(
      margin: _edgeInsets(component['margin'], context) ??
          _spacingSymmetric(context, vertical: 8),
      padding: _edgeInsets(component['padding'], context) ??
          _spacingAll(context, 24),
      decoration: BoxDecoration(
        borderRadius: _circularRadius(context, 16),
        color: imageUrl == null
            ? Theme.of(context).colorScheme.primaryContainer
            : null,
        image: imageUrl != null
            ? DecorationImage(
                image: CachedNetworkImageProvider(imageUrl),
                fit: BoxFit.cover,
                colorFilter: ColorFilter.mode(
                  palette.overlayStrong.withValues(alpha: 0.45),
                  BlendMode.darken,
                ),
              )
            : null,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (title != null)
            Text(
              title,
              style: theme.textTheme.headlineSmall?.copyWith(color: onColor),
            ),
          if (subtitle != null)
            Padding(
              padding: _spacingOnly(context, top: 8),
              child: Text(
                subtitle,
                style:
                    theme.textTheme.titleMedium?.copyWith(color: subtitleColor),
              ),
            ),
          ...children,
        ],
      ),
    );
  }

  Widget _buildFlexContainer(
      Map<String, Object?> component, BuildContext context) {
    final axis = _resolveAxis(component);
    final wrapMode = (component['wrap'] as String?)
        ?.toLowerCase()
        .trim()
        .replaceAll('_', '-');
    final gapToken = _spacingToDouble(component['gap']);
    final gap =
        gapToken != null ? _resolveSpacingValue(context, gapToken) : null;
    final alignToken = (component['align'] as String?)?.toLowerCase().trim();
    final justifyToken =
        (component['justify'] as String?)?.toLowerCase().trim();
    final children = _buildChildren(component['children'], context);

    Widget content;
    if (wrapMode != null && wrapMode != 'nowrap') {
      final spacing = gap ?? 0;
      content = Wrap(
        direction: axis,
        spacing: spacing,
        runSpacing: spacing,
        alignment: _mapWrapAlignment(justifyToken),
        runAlignment: _mapWrapAlignment(alignToken),
        crossAxisAlignment: _mapWrapCrossAlignment(alignToken),
        verticalDirection: axis == Axis.horizontal && wrapMode == 'wrap-reverse'
            ? VerticalDirection.up
            : VerticalDirection.down,
        children: children,
      );
    } else {
      final spacedChildren = (gap != null && gap > 0)
          ? _withGapBetween(children, gap, axis)
          : children;
      if (axis == Axis.horizontal) {
        final crossAxis = _mapCrossAxisAlignment(alignToken, axis);
        content = Row(
          mainAxisAlignment: _mapMainAxisAlignment(justifyToken),
          crossAxisAlignment: crossAxis,
          mainAxisSize: MainAxisSize.max,
          textBaseline: crossAxis == CrossAxisAlignment.baseline
              ? TextBaseline.alphabetic
              : null,
          children: spacedChildren,
        );
      } else {
        content = Column(
          mainAxisAlignment: _mapMainAxisAlignment(justifyToken),
          crossAxisAlignment: _mapCrossAxisAlignment(alignToken, axis),
          mainAxisSize: MainAxisSize.max,
          children: spacedChildren,
        );
      }
    }

    final decorated = _decorateBox(
      context: context,
      component: component,
      child: content,
    );

    Widget result = decorated.child;
    if (decorated.flex != null) {
      result = _FlexMaybe(flex: decorated.flex!, child: result);
    }
    return result;
  }

  Widget _buildTransition(
      Map<String, Object?> component, BuildContext context) {
    final rawChild = component['children'];
    Map<String, Object?>? childConfig;
    if (rawChild is Map<String, Object?>) {
      childConfig = rawChild;
    } else if (rawChild is List) {
      for (final entry in rawChild) {
        if (entry is Map<String, Object?>) {
          childConfig = entry;
          break;
        }
      }
    }

    Widget child;
    if (childConfig != null) {
      final builtChild = _buildComponent(childConfig, context);
      child = KeyedSubtree(
        key: _resolveComponentKey(childConfig),
        child: builtChild,
      );
    } else {
      child = _emptyTransitionChild;
    }

    final durationMs = (component['duration'] as num?)?.toInt();
    final duration = durationMs != null && durationMs >= 0
        ? Duration(milliseconds: durationMs)
        : const Duration(milliseconds: 250);
    final animationType =
        (component['animation'] as String?)?.toLowerCase().trim() ??
            _defaultTransitionAnimation;
    final direction = (component['direction'] as String?)?.toLowerCase().trim();
    final curveName = (component['curve'] as String?)?.toLowerCase().trim();
    final reverseCurveName =
        (component['reverseCurve'] as String?)?.toLowerCase().trim();

    final padding = _edgeInsets(component['padding'], context);

    Widget animated = AnimatedSwitcher(
      duration: duration,
      reverseDuration: duration,
      switchInCurve: _curveFromName(curveName) ?? _defaultSwitchInCurve,
      switchOutCurve: _curveFromName(reverseCurveName) ??
          _curveFromName(curveName) ??
          _defaultSwitchOutCurve,
      layoutBuilder: (currentChild, previousChildren) {
        return Stack(
          alignment: Alignment.topLeft,
          children: [
            ...previousChildren,
            if (currentChild != null) currentChild,
          ],
        );
      },
      transitionBuilder: (current, animation) {
        return _buildAnimatedSwitcherTransition(
          animationType,
          direction,
          animation,
          current,
        );
      },
      child: child,
    );

    animated = ClipRect(child: animated);

    if (padding != null) {
      animated = Padding(padding: padding, child: animated);
    }

    return animated;
  }

  Curve? _curveFromName(String? name) {
    if (name == null || name.isEmpty) {
      return null;
    }
    switch (name) {
      case 'linear':
        return Curves.linear;
      case 'ease':
      case 'easeinout':
        return Curves.easeInOut;
      case 'easein':
        return Curves.easeIn;
      case 'easeout':
        return Curves.easeOut;
      case 'fastoutslowin':
        return Curves.fastOutSlowIn;
      case 'decelerate':
        return Curves.decelerate;
      case 'easeincubic':
        return Curves.easeInCubic;
      case 'easeoutcubic':
        return Curves.easeOutCubic;
      default:
        return null;
    }
  }

  Offset _transitionOffset(String? direction) {
    switch (direction) {
      case 'left':
        return const Offset(-0.12, 0);
      case 'right':
        return const Offset(0.12, 0);
      case 'down':
        return const Offset(0, -0.12);
      case 'up':
      default:
        return const Offset(0, 0.12);
    }
  }

  Widget _buildAnimatedSwitcherTransition(
    String animationType,
    String? direction,
    Animation<double> animation,
    Widget child,
  ) {
    final normalized =
        animationType.isEmpty ? _defaultTransitionAnimation : animationType;
    switch (normalized) {
      case 'slide':
        final offset = _transitionOffset(direction);
        final isReverse = animation.status == AnimationStatus.reverse;
        final tween = Tween<Offset>(
          begin: isReverse ? Offset.zero : offset,
          end: isReverse ? offset : Offset.zero,
        );
        final position = animation.drive(tween);
        return SlideTransition(
          position: position,
          child: FadeTransition(
            opacity: animation,
            child: child,
          ),
        );
      case 'scale':
        final isReverse = animation.status == AnimationStatus.reverse;
        final tween = Tween<double>(
          begin: isReverse ? 1.0 : 0.92,
          end: isReverse ? 0.92 : 1.0,
        );
        final scale = animation.drive(tween);
        return FadeTransition(
          opacity: animation,
          child: ScaleTransition(
            scale: scale,
            child: child,
          ),
        );
      case 'fade-through':
        final isReverse = animation.status == AnimationStatus.reverse;
        final tween = Tween<double>(
          begin: isReverse ? 1.0 : 0.92,
          end: isReverse ? 0.92 : 1.0,
        );
        final scale = animation.drive(tween);
        return FadeTransition(
          opacity: animation,
          child: ScaleTransition(
            scale: scale,
            child: child,
          ),
        );
      case 'none':
        return child;
      case 'fade':
      default:
        return FadeTransition(
          opacity: animation,
          child: child,
        );
    }
  }

  Widget _buildText(Map<String, Object?> component, BuildContext context) {
    final value = component['value'] as String? ?? '';
    final size = (component['size'] as String? ?? '').toLowerCase();
    final weight = (component['weight'] as String? ?? '').toLowerCase();
    final theme = Theme.of(context);
    TextStyle style = theme.textTheme.bodyMedium ?? const TextStyle();
    switch (size) {
      case 'xs':
        style = theme.textTheme.bodySmall ?? style;
      case 'sm':
        style = theme.textTheme.bodySmall ?? style;
      case 'lg':
        style = theme.textTheme.titleMedium ?? style;
      case 'xl':
        style = theme.textTheme.headlineSmall ?? style;
      case '2xl':
      case '3xl':
      case '4xl':
        style = theme.textTheme.headlineMedium ?? style;
    }
    switch (weight) {
      case 'medium':
        style = style.copyWith(fontWeight: FontWeight.w500);
      case 'semibold':
        style = style.copyWith(fontWeight: FontWeight.w600);
      case 'bold':
        style = style.copyWith(fontWeight: FontWeight.bold);
    }
    return Padding(
      padding: _edgeInsets(component['margin'], context) ??
          _spacingSymmetric(context, vertical: 4),
      child: Text(value, style: style),
    );
  }

  Widget _buildMarkdown(Map<String, Object?> component, BuildContext context) {
    final value = component['value'] as String? ?? '';
    return Padding(
      padding: _edgeInsets(component['margin'], context) ??
          _spacingSymmetric(context, vertical: 4),
      child: MarkdownBody(data: value),
    );
  }

  Widget _buildImage(Map<String, Object?> component, BuildContext context) {
    final src = component['src'] as String?;
    if (src == null) {
      return const SizedBox.shrink();
    }
    final radius = _circularRadius(context, 12);
    return Padding(
      padding: _edgeInsets(component['margin'], context) ??
          _spacingSymmetric(context, vertical: 6),
      child: ClipRRect(
        borderRadius: radius,
        child: CachedNetworkImage(
          imageUrl: src,
          fit: BoxFit.cover,
          height: (component['height'] as num?)?.toDouble(),
          width: (component['width'] as num?)?.toDouble(),
        ),
      ),
    );
  }

  Widget _buildButton(Map<String, Object?> component, BuildContext context) {
    final label = component['label'] as String? ?? 'Action';
    final variantToken =
        (component['variant'] as String? ?? 'solid').toLowerCase().trim();
    final sizeToken =
        (component['size'] as String? ?? 'md').toLowerCase().trim();
    final toneToken =
        (component['tone'] as String? ?? component['intent'] as String? ?? '')
            .toLowerCase()
            .trim();
    final action = component['action'] as Map<String, Object?>?;
    final disabled = component['disabled'] as bool? ?? false;
    final isLoading = action != null && _pendingSelfActions.contains(action);
    final effectiveDisabled = disabled || isLoading;
    final palette = _chatThemeOf(context).palette;

    void Function()? onPressed;
    if (action != null && !effectiveDisabled) {
      onPressed = () => _dispatchAction(
            action,
            context,
            preference: _ActionLoadingPreference.self,
            actionSource: action,
          );
    }

    final ChatKitButtonVariant variant = switch (variantToken) {
      'soft' => ChatKitButtonVariant.soft,
      'outline' => ChatKitButtonVariant.outline,
      'ghost' => ChatKitButtonVariant.ghost,
      _ => ChatKitButtonVariant.solid,
    };

    final ChatKitButtonSize size = switch (sizeToken) {
      'sm' => ChatKitButtonSize.sm,
      'lg' => ChatKitButtonSize.lg,
      _ => ChatKitButtonSize.md,
    };

    final danger = toneToken == 'danger' ||
        toneToken == 'critical' ||
        toneToken == 'error' ||
        variantToken.contains('danger') ||
        (component['color'] as String?)?.toLowerCase() == 'danger';

    final style = ChatKitStyles.buttonStyle(
      context,
      variant: variant,
      size: size,
      danger: danger,
    );

    final colorScheme = Theme.of(context).colorScheme;
    final spinnerColor = switch (variant) {
      ChatKitButtonVariant.solid =>
        danger ? colorScheme.onError : colorScheme.onPrimary,
      _ => danger ? palette.danger : palette.onSurface,
    };

    final Widget child = isLoading
        ? SizedBox(
            width: 18,
            height: 18,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation<Color>(spinnerColor),
            ),
          )
        : Text(label);

    switch (variant) {
      case ChatKitButtonVariant.ghost:
        return TextButton(style: style, onPressed: onPressed, child: child);
      case ChatKitButtonVariant.outline:
        return OutlinedButton(style: style, onPressed: onPressed, child: child);
      case ChatKitButtonVariant.soft:
        return FilledButton.tonal(
          style: style,
          onPressed: onPressed,
          child: child,
        );
      case ChatKitButtonVariant.solid:
        return FilledButton(style: style, onPressed: onPressed, child: child);
    }
  }

  Widget _buildButtonGroup(
      Map<String, Object?> component, BuildContext context) {
    final children = _buildChildren(component['children'], context);
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: children,
    );
  }

  Widget _buildList(Map<String, Object?> component, BuildContext context) {
    final limitRaw = component['limit'];
    final int? limit = switch (limitRaw) {
      final num value when value >= 0 => value.toInt(),
      final String value when value.toLowerCase().trim() == 'auto' => null,
      _ => null,
    };

    final rawChildren = component['children'];
    final items = <Widget>[];
    if (rawChildren is List) {
      for (final child in rawChildren) {
        if (child is Map<String, Object?>) {
          if (limit != null && items.length >= limit) break;
          items.add(_buildComponent(child, context));
        }
      }
    }

    final chatTheme = ChatKitTheme.of(context);
    final spacing = chatTheme.spacing;
    final gap = _spacingToDouble(component['gap']);
    final spacedItems = (gap != null && gap > 0)
        ? _withGapBetween(items, gap, Axis.vertical)
        : items;

    final statusWidget = _buildListStatus(component['status'], context);
    final children = [
      if (statusWidget != null)
        Padding(
          padding: EdgeInsets.only(bottom: spacing.sm),
          child: statusWidget,
        ),
      ...spacedItems,
    ];

    final decorated = _decorateBox(
      context: context,
      component: component,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: children,
      ),
    );

    Widget result = decorated.child;
    if (decorated.flex != null) {
      result = _FlexMaybe(flex: decorated.flex!, child: result);
    }
    return result;
  }

  Widget _buildListItem(Map<String, Object?> component, BuildContext context) {
    final alignToken = (component['align'] as String?)?.toLowerCase().trim();
    final gap = _spacingToDouble(component['gap']);
    final children = _buildChildren(component['children'], context);
    final spacedChildren = (gap != null && gap > 0)
        ? _withGapBetween(children, gap, Axis.horizontal)
        : children;

    final content = Row(
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: _mapCrossAxisAlignment(alignToken, Axis.horizontal),
      mainAxisSize: MainAxisSize.max,
      children: spacedChildren,
    );

    final decorated = _decorateBox(
      context: context,
      component: component,
      child: content,
      applyMargin: false,
    );

    Widget result = decorated.child;
    final action = component['onClickAction'] as Map<String, Object?>?;
    if (action != null) {
      final palette = _chatThemeOf(context).palette;
      result = Material(
        color: palette.transparent,
        child: InkWell(
          borderRadius: decorated.borderRadius,
          onTap: () => _dispatchAction(
            action,
            context,
            preference: _ActionLoadingPreference.self,
            actionSource: action,
          ),
          child: result,
        ),
      );
    }

    if (decorated.margin != null) {
      result = Padding(padding: decorated.margin!, child: result);
    }
    if (decorated.flex != null) {
      result = _FlexMaybe(flex: decorated.flex!, child: result);
    }
    return result;
  }

  Widget _buildTimeline(Map<String, Object?> component, BuildContext context) {
    final spacing = _chatThemeOf(context).spacing;
    final items = (component['items'] as List?)
            ?.map((item) => castMap(item))
            .toList(growable: false) ??
        const [];
    if (items.isEmpty) {
      final children = _buildChildren(component['children'], context);
      return Column(children: children);
    }

    final alignmentToken =
        (component['alignment'] as String? ?? component['align'] as String?)
            ?.toString()
            .toLowerCase()
            .trim();
    final variantToken =
        (component['variant'] as String?)?.toLowerCase().trim();
    final lineStyleToken =
        (component['lineStyle'] as String? ?? variantToken)?.toString();

    final alignment =
        _resolveTimelineAlignment(alignmentToken, _TimelineAlignment.end);
    final lineStyle =
        _resolveTimelineLineStyle(lineStyleToken, _TimelineLineStyle.solid);
    final dense = ((component['density'] as String?)?.toLowerCase().trim() ==
            'compact') ||
        (variantToken != null && variantToken.contains('compact'));
    final showDividers = component['dividers'] as bool? ?? false;

    final children = <Widget>[];
    for (final entry in items.indexed) {
      children.add(
        _buildTimelineEntry(
          entry.$2,
          context,
          index: entry.$1,
          total: items.length,
          alignment: alignment,
          lineStyle: lineStyle,
          dense: dense,
        ),
      );
      if (showDividers && entry.$1 != items.length - 1) {
        children.add(Divider(height: spacing.xxl));
      }
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: children,
    );
  }

  Widget _buildTimelineItem(
      Map<String, Object?> component, BuildContext context) {
    return _buildTimelineEntry(
      component,
      context,
      index: 0,
      total: 1,
      alignment: _TimelineAlignment.end,
      lineStyle: _TimelineLineStyle.solid,
      dense: false,
    );
  }

  Widget _buildTimelineEntry(
    Map<String, Object?> component,
    BuildContext context, {
    required int index,
    required int total,
    required _TimelineAlignment alignment,
    required _TimelineLineStyle lineStyle,
    required bool dense,
  }) {
    final chatTheme = _chatThemeOf(context);
    final spacing = chatTheme.spacing;
    final radii = chatTheme.radii;
    final theme = Theme.of(context);
    final title = component['title'] as String? ?? '';
    final subtitle = component['subtitle'] as String?;
    final timestamp = component['timestamp'] as String?;
    String? formattedTimestamp;
    if (timestamp != null) {
      final parsed = DateTime.tryParse(timestamp);
      formattedTimestamp = parsed != null
          ? DateFormat.yMMMd().add_jm().format(parsed.toLocal())
          : timestamp;
    }
    final statusWidget = _buildWidgetStatus(component['status'], context);
    final color = _colorFromToken(context, component['color']) ??
        theme.colorScheme.primary;
    final lineColor = _colorFromToken(context, component['lineColor']) ??
        color.withValues(alpha: 0.5);
    final iconName = component['icon'] as String?;
    final icon = _iconFromName(iconName);
    final itemAlignmentToken =
        (component['alignment'] as String? ?? component['align'] as String?)
            ?.toString()
            .toLowerCase()
            .trim();
    final itemAlignment =
        _resolveTimelineAlignment(itemAlignmentToken, alignment);
    final alignLeft = switch (itemAlignment) {
      _TimelineAlignment.start => true,
      _TimelineAlignment.end => false,
      _TimelineAlignment.alternate => index.isEven,
    };

    final badge = component['badge'] as String?;
    final tags = (component['tags'] as List?)
            ?.whereType<String>()
            .toList(growable: false) ??
        const [];
    final children = _buildChildren(component['children'], context);

    final contentChildren = <Widget>[
      if (badge != null && badge.isNotEmpty)
        Container(
          padding: EdgeInsets.symmetric(
            horizontal: spacing.sm,
            vertical: spacing.xs,
          ),
          decoration: BoxDecoration(
            color: color.withValues(alpha: 0.12),
            borderRadius: BorderRadius.circular(radii.full),
          ),
          child: Text(
            badge,
            style: theme.textTheme.labelSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      if (title.isNotEmpty)
        Padding(
          padding: EdgeInsets.only(
            top: badge != null && badge.isNotEmpty ? spacing.xs : 0,
          ),
          child: Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      if (subtitle != null && subtitle.isNotEmpty)
        Padding(
          padding: EdgeInsets.only(top: spacing.xxs),
          child: Text(
            subtitle,
            style: theme.textTheme.bodyMedium,
          ),
        ),
      if (formattedTimestamp != null)
        Padding(
          padding: EdgeInsets.only(top: spacing.xxs),
          child: Text(
            formattedTimestamp,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.hintColor,
            ),
          ),
        ),
      if (statusWidget != null)
        Padding(
          padding: EdgeInsets.only(top: spacing.sm),
          child: statusWidget,
        ),
      if (tags.isNotEmpty)
        Padding(
          padding: EdgeInsets.only(top: spacing.sm),
          child: Wrap(
            spacing: spacing.xs,
            runSpacing: spacing.xs - spacing.xxxs,
            children: [
              for (final tag in tags)
                Container(
                  padding: EdgeInsets.symmetric(
                    horizontal: spacing.sm - spacing.xxxs,
                    vertical: spacing.xxs,
                  ),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surfaceContainerHighest
                        .withValues(alpha: 0.6),
                    borderRadius: BorderRadius.circular(radii.full),
                  ),
                  child: Text(
                    tag,
                    style: theme.textTheme.labelSmall?.copyWith(
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
            ],
          ),
        ),
      if (children.isNotEmpty)
        Padding(
          padding: EdgeInsets.only(top: spacing.sm),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: children,
          ),
        ),
    ];

    final content = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: contentChildren,
    );

    final verticalPadding = EdgeInsets.symmetric(
      vertical: dense ? spacing.xs : spacing.md,
    );

    final markerVariant =
        (component['variant'] as String?)?.toLowerCase().trim() ?? '';
    final hollow =
        markerVariant.contains('outline') || markerVariant.contains('hollow');

    final palette = _chatThemeOf(context).palette;
    final axis = SizedBox(
      width: spacing.xxxl,
      child: Column(
        children: [
          Container(
            width: spacing.md + spacing.xxxs,
            height: spacing.md + spacing.xxxs,
            decoration: BoxDecoration(
              color: hollow ? palette.transparent : color,
              borderRadius: BorderRadius.circular(radii.card),
              border: Border.all(color: color, width: 2),
            ),
            alignment: Alignment.center,
            child: icon != null
                ? Icon(
                    icon,
                    size: spacing.xs + spacing.xxxs,
                    color: hollow
                        ? color
                        : Theme.of(context).colorScheme.onPrimary,
                  )
                : null,
          ),
          if (index != total - 1)
            Expanded(
              child: CustomPaint(
                painter: _TimelineConnectorPainter(
                  color: lineColor,
                  style: lineStyle,
                ),
              ),
            ),
        ],
      ),
    );

    return Padding(
      padding: verticalPadding,
      child: IntrinsicHeight(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(child: alignLeft ? content : const SizedBox()),
            axis,
            Expanded(child: alignLeft ? const SizedBox() : content),
          ],
        ),
      ),
    );
  }

  Widget _buildRating(Map<String, Object?> component, BuildContext context) {
    final value = (component['value'] as num?)?.toDouble() ?? 0;
    final max = (component['max'] as num?)?.toDouble() ?? 5;
    final count = math.max(1, max.round());
    final stars = <Widget>[];
    for (var i = 0; i < count; i++) {
      final fill = value - i;
      IconData icon;
      if (fill >= 1) {
        icon = Icons.star;
      } else if (fill > 0) {
        icon = Icons.star_half;
      } else {
        icon = Icons.star_border;
      }
      stars.add(
        Icon(
          icon,
          color: _chatThemeOf(context).palette.warning,
        ),
      );
    }
    return Row(children: stars);
  }

  Widget _buildCarousel(Map<String, Object?> component, BuildContext context) {
    final spacing = _chatThemeOf(context).spacing;
    final slides = _resolveCarouselSlides(component, context);
    if (slides.isEmpty) {
      return const SizedBox.shrink();
    }

    final id = component['id'] as String? ?? widget.item.id;
    final controllerKey = 'carousel::$id';
    final viewportFraction =
        (component['viewportFraction'] as num?)?.toDouble() ?? 1.0;
    final controller =
        _pageControllerFor(controllerKey, viewportFraction: viewportFraction);
    final focusNode = _carouselFocusNodeFor(controllerKey);

    final height = (component['height'] as num?)?.toDouble() ?? 220;
    final showIndicators = component['showIndicators'] as bool? ?? true;
    final showControls = component['showControls'] as bool? ?? false;
    final semanticsLabel = component['label'] as String?;
    final loop = component['loop'] as bool? ?? true;
    final autoPlay = component['autoPlay'] as bool? ?? false;
    final autoPlayInterval = Duration(
      milliseconds: (component['autoPlayInterval'] as num?)?.toInt() ?? 5000,
    );

    if ((!autoPlay || slides.length <= 1) &&
        _carouselTimers.containsKey(controllerKey)) {
      _carouselTimers.remove(controllerKey)?.cancel();
    } else if (autoPlay && slides.length > 1) {
      _carouselTimers[controllerKey]?.cancel();
      _carouselTimers[controllerKey] = Timer.periodic(autoPlayInterval, (_) {
        if (!mounted || !controller.hasClients || slides.isEmpty) return;
        final current = controller.page?.round() ?? controller.initialPage;
        final next = loop
            ? (current + 1) % slides.length
            : math.min(current + 1, slides.length - 1);
        if (!loop && next == current) return;
        _animateCarousel(controller, next);
      });
    }

    final pageView = PageView.builder(
      controller: controller,
      itemCount: slides.length,
      itemBuilder: (context, index) {
        final slide = slides[index];
        return Padding(
          padding: _spacingSymmetric(context, horizontal: 8),
          child: _buildCarouselSlide(
            context: context,
            slide: slide,
            index: index,
            count: slides.length,
          ),
        );
      },
    );

    final indicator = showIndicators && slides.length > 1
        ? Padding(
            padding: _spacingOnly(context, top: 12),
            child: SmoothPageIndicator(
              controller: controller,
              count: slides.length,
              effect: WormEffect(
                dotHeight: spacing.xs,
                dotWidth: spacing.xs,
                dotColor: Theme.of(context).colorScheme.outlineVariant,
                activeDotColor: Theme.of(context).colorScheme.primary,
              ),
            ),
          )
        : const SizedBox.shrink();

    final controls = showControls && slides.length > 1
        ? Padding(
            padding: _spacingOnly(context, top: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  tooltip: 'Previous slide',
                  onPressed: () {
                    if (!controller.hasClients) return;
                    final current = controller.page?.round() ?? 0;
                    final previous = loop
                        ? (current - 1 + slides.length) % slides.length
                        : math.max(current - 1, 0);
                    if (!loop && previous == current) return;
                    _animateCarousel(controller, previous);
                  },
                  icon: const Icon(Icons.chevron_left),
                ),
                IconButton(
                  tooltip: 'Next slide',
                  onPressed: () {
                    if (!controller.hasClients) return;
                    final current = controller.page?.round() ?? 0;
                    final next = loop
                        ? (current + 1) % slides.length
                        : math.min(current + 1, slides.length - 1);
                    if (!loop && next == current) return;
                    _animateCarousel(controller, next);
                  },
                  icon: const Icon(Icons.chevron_right),
                ),
              ],
            ),
          )
        : const SizedBox.shrink();

    final column = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(height: height, child: pageView),
        indicator,
        controls,
      ],
    );

    final focus = Focus(
      focusNode: focusNode,
      onKeyEvent: (node, event) =>
          _handleCarouselKey(event, controller, slides.length, loop),
      child: column,
    );

    return Semantics(
      label: semanticsLabel,
      container: true,
      child: focus,
    );
  }

  Widget _buildVideo(Map<String, Object?> component, BuildContext context) {
    final url = component['src'] as String? ?? component['url'] as String?;
    if (url == null) {
      return const SizedBox.shrink();
    }
    final aspect = (component['aspectRatio'] as num?)?.toDouble();
    final autoplay = component['autoplay'] as bool? ?? false;
    return ChatKitVideoPlayer(
      url: url,
      aspectRatio: aspect,
      autoplay: autoplay,
    );
  }

  Widget _buildAudio(Map<String, Object?> component, BuildContext context) {
    final url = component['src'] as String? ?? component['url'] as String?;
    if (url == null) {
      return const SizedBox.shrink();
    }
    return ChatKitAudioPlayer(url: url);
  }

  Widget _buildMap(Map<String, Object?> component, BuildContext context) {
    final chatTheme = _chatThemeOf(context);
    final centerData = castMap(component['center']);
    final lat = (centerData['lat'] as num?)?.toDouble();
    final lng = (centerData['lng'] as num?)?.toDouble() ??
        (centerData['lon'] as num?)?.toDouble();
    final markersJson =
        (component['markers'] as List?)?.cast<Map<String, Object?>>() ??
            const [];
    LatLng? center = lat != null && lng != null ? LatLng(lat, lng) : null;
    if (center == null && markersJson.isNotEmpty) {
      final first = markersJson.first;
      final markerLat = (first['lat'] as num?)?.toDouble();
      final markerLng = (first['lng'] as num?)?.toDouble() ??
          (first['lon'] as num?)?.toDouble();
      if (markerLat != null && markerLng != null) {
        center = LatLng(markerLat, markerLng);
      }
    }
    center ??= const LatLng(37.7749, -122.4194);

    final zoom = (component['zoom'] as num?)?.toDouble() ??
        (component['initialZoom'] as num?)?.toDouble() ??
        13.0;
    final tileUrl = component['tileUrl'] as String? ??
        'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    final showControls = component['interactive'] as bool? ?? true;
    final height = (component['height'] as num?)?.toDouble() ?? 220;

    final markers = [
      for (final marker in markersJson) _buildMarker(marker, context),
    ].whereType<Marker>().toList();

    final title = component['title'] as String?;
    final description = component['description'] as String?;

    return Container(
      height: height,
      decoration: BoxDecoration(
        borderRadius: _circularRadius(context, 12),
        border: Border.all(color: Theme.of(context).colorScheme.outlineVariant),
      ),
      clipBehavior: Clip.antiAlias,
      child: Stack(
        children: [
          FlutterMap(
            options: MapOptions(
              initialCenter: center,
              initialZoom: zoom,
              interactionOptions: showControls
                  ? const InteractionOptions()
                  : const InteractionOptions(
                      flags: InteractiveFlag.none,
                    ),
            ),
            children: [
              TileLayer(
                urlTemplate: tileUrl,
                userAgentPackageName: 'chatkit_flutter',
              ),
              if (markers.isNotEmpty)
                MarkerLayer(
                  markers: markers,
                ),
            ],
          ),
          if (title != null || description != null)
            Positioned(
              left: _resolveSpacingValue(context, 12),
              right: _resolveSpacingValue(context, 12),
              bottom: _resolveSpacingValue(context, 12),
              child: Container(
                padding: _spacingAll(context, 12),
                decoration: BoxDecoration(
                  color: chatTheme.palette.overlayStrong.withValues(
                    alpha: 0.6,
                  ),
                  borderRadius: _circularRadius(context, 12),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (title != null)
                      Text(
                        title,
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                              color: Theme.of(context).colorScheme.onPrimary,
                              fontWeight: FontWeight.bold,
                            ),
                      ),
                    if (description != null)
                      Text(
                        description,
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                              color: Theme.of(context)
                                  .colorScheme
                                  .onPrimary
                                  .withValues(alpha: 0.7),
                            ),
                      ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }

  Marker? _buildMarker(
    Map<String, Object?> marker,
    BuildContext context,
  ) {
    final lat = (marker['lat'] as num?)?.toDouble();
    final lng = (marker['lng'] as num?)?.toDouble() ??
        (marker['lon'] as num?)?.toDouble();
    if (lat == null || lng == null) {
      return null;
    }
    final label = marker['label'] as String?;
    final action = marker['onTapAction'] as Map<String, Object?>?;
    final color = _colorFromToken(context, marker['color']) ??
        Theme.of(context).colorScheme.primary;

    final chatTheme = _chatThemeOf(context);
    final spacing = chatTheme.spacing;
    return Marker(
      point: LatLng(lat, lng),
      width: 44,
      height: 44,
      child: GestureDetector(
        onTap: action != null
            ? () => _dispatchAction(
                  action,
                  context,
                  payloadOverride: {
                    'marker': marker,
                  },
                  preference: _ActionLoadingPreference.none,
                )
            : null,
        child: Column(
          children: [
            Icon(
              Icons.location_on,
              size: 28,
              color: _chatThemeOf(context)
                  .palette
                  .overlayStrong
                  .withValues(alpha: 0.9),
            ),
            Icon(Icons.circle, size: 12, color: color),
            if (label != null)
              Container(
                margin: _spacingOnly(context, top: 4),
                padding: EdgeInsets.symmetric(
                  horizontal: spacing.xs - spacing.xxxs,
                  vertical: spacing.xxxs,
                ),
                decoration: BoxDecoration(
                  color: chatTheme.palette.overlayStrong.withValues(
                    alpha: 0.9,
                  ),
                  borderRadius: _circularRadius(context, 8),
                ),
                child: Text(
                  label,
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.onPrimary,
                        fontSize: 10,
                      ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildForm(Map<String, Object?> component, BuildContext context) {
    final children = component['children'];
    final submitAction = component['onSubmitAction'] as Map<String, Object?>?;
    final fieldNames = _collectFieldNames(children);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ..._buildChildren(children, context),
        if (submitAction != null)
          Align(
            alignment: Alignment.centerRight,
            child: Padding(
              padding: _spacingOnly(context, top: 12),
              child: FilledButton(
                onPressed: _pendingSelfActions.contains(submitAction)
                    ? null
                    : () => _submitForm(
                          submitAction,
                          context,
                          fieldNames: fieldNames,
                        ),
                child: _pendingSelfActions.contains(submitAction)
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : Text(submitAction['label'] as String? ?? 'Submit'),
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildFormControl(
      Map<String, Object?> component, BuildContext context) {
    final type = (component['type'] as String? ?? '').toLowerCase();
    final name =
        component['name'] as String? ?? component['id'] as String? ?? '';
    if (name.isNotEmpty) {
      _formComponents[name] = component;
    }
    final disabled = component['disabled'] as bool? ?? false;
    final readOnly = component['readonly'] as bool? ??
        component['readOnly'] as bool? ??
        false;
    final helperText = component['helperText'] as String?;
    final errorText = component['errorText'] as String?;
    final placeholder = component['placeholder'] as String?;
    final required = component['required'] as bool? ?? false;
    final prefixIconData = _iconFromName(component['iconStart'] as String?);
    final suffixIconData = _iconFromName(component['iconEnd'] as String?);
    final prefixIcon =
        prefixIconData != null ? Icon(prefixIconData, size: 18) : null;
    final suffixIcon =
        suffixIconData != null ? Icon(suffixIconData, size: 18) : null;
    final maxLength = (component['maxLength'] as num?)?.toInt();
    final fieldError = name.isNotEmpty ? _fieldErrors[name] : null;
    final variantToken =
        (component['variant'] as String? ?? '').trim().toLowerCase();
    final decoration = ChatKitStyles.inputDecoration(
      context,
      label: component['label'] as String?,
      hint: placeholder,
      helper: fieldError == null ? helperText : null,
      error: fieldError ?? errorText,
      prefixIcon: prefixIcon,
      suffixIcon: suffixIcon,
      withBorder: variantToken == 'outline' || variantToken == 'bordered',
    ).copyWith(
      counterText: maxLength != null ? '' : null,
      floatingLabelBehavior:
          required ? FloatingLabelBehavior.always : FloatingLabelBehavior.auto,
    );

    switch (type) {
      case 'input':
      case 'text':
        final controller = _textControllers.putIfAbsent(
          name,
          () => TextEditingController(
            text: (component['defaultValue'] ?? '') as String,
          ),
        );
        final inputKind =
            (component['inputType'] as String? ?? 'text').toLowerCase();
        final obscure = inputKind == 'password';
        final keyboardType = switch (inputKind) {
          'number' || 'numeric' => TextInputType.number,
          'email' => TextInputType.emailAddress,
          'phone' => TextInputType.phone,
          'url' => TextInputType.url,
          _ => TextInputType.text,
        };
        return TextField(
          controller: controller,
          readOnly: readOnly,
          enabled: !disabled,
          obscureText: obscure,
          keyboardType: keyboardType,
          maxLength: maxLength,
          decoration: decoration,
          onChanged: (value) {
            _setFieldValue(name, value);
            _handleFieldInteraction(name, markTouched: true, validate: true);
          },
        );
      case 'textarea':
        final controller = _textControllers.putIfAbsent(
          name,
          () => TextEditingController(
            text: (component['defaultValue'] ?? '') as String,
          ),
        );
        final rows = (component['rows'] as num?)?.toInt() ?? 4;
        final autoResize = component['autoResize'] as bool? ?? false;
        return TextField(
          controller: controller,
          readOnly: readOnly,
          enabled: !disabled,
          minLines: rows,
          maxLines: autoResize ? null : rows,
          decoration: decoration,
          onChanged: (value) {
            _setFieldValue(name, value);
            _handleFieldInteraction(name, markTouched: true, validate: true);
          },
        );
      case 'select':
      case 'select.single':
      case 'select.native':
        return _buildSelectControl(
          component: component,
          context: context,
          name: name,
          decoration: decoration,
          disabled: disabled || readOnly,
          multi: false,
        );
      case 'select.multi':
        return _buildSelectControl(
          component: component,
          context: context,
          name: name,
          decoration: decoration,
          disabled: disabled || readOnly,
          multi: true,
        );
      case 'chips':
        final options =
            (component['options'] as List?)?.cast<Map<String, Object?>>() ??
                const [];
        final selected = _multiSelectValues.putIfAbsent(name, () {
          final initial = <Object?>[];
          final existing = _formState[name];
          if (existing is List) {
            initial.addAll(existing);
          }
          final defaults = component['defaultValue'];
          if (defaults is List) {
            initial.addAll(defaults);
          }
          return initial.toSet();
        });
        return Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            for (final option in options)
              FilterChip(
                avatar: option['avatar'] != null
                    ? CircleAvatar(
                        backgroundImage: CachedNetworkImageProvider(
                          option['avatar'] as String,
                        ),
                      )
                    : null,
                label: Text(
                  option['label'] as String? ??
                      option['value']?.toString() ??
                      '',
                ),
                selected: selected.contains(option['value']),
                onSelected: disabled
                    ? null
                    : (value) {
                        final optionValue = option['value'];
                        setState(() {
                          if (value) {
                            selected.add(optionValue);
                          } else {
                            selected.remove(optionValue);
                          }
                        });
                        _setFieldValue(name, selected.toList());
                        _handleFieldInteraction(
                          name,
                          markTouched: true,
                          validate: true,
                        );
                      },
              ),
          ],
        );
      case 'radio.group':
        final options =
            (component['options'] as List?)?.cast<Map<String, Object?>>() ??
                const [];
        final defaultValue = component['defaultValue'];
        final selectedValue =
            _formState.containsKey(name) ? _formState[name] : defaultValue;
        _setFieldValue(name, selectedValue);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (component['label'] != null)
              Padding(
                padding: _spacingOnly(context, bottom: 8),
                child: Text(
                  component['label'] as String,
                  style: Theme.of(context).textTheme.labelLarge,
                ),
              ),
            for (final option in options)
              RadioListTile<Object?>(
                value: option['value'],
                dense: true,
                groupValue: selectedValue,
                title: Text(option['label'] as String? ??
                    option['value']?.toString() ??
                    ''),
                onChanged: disabled
                    ? null
                    : (value) {
                        setState(() => _setFieldValue(name, value));
                        _handleFieldInteraction(
                          name,
                          markTouched: true,
                          validate: true,
                        );
                        final action = component['onChangeAction']
                            as Map<String, Object?>?;
                        if (action != null) {
                          _dispatchAction(
                            action,
                            context,
                            payloadOverride: {'value': value},
                            preference: _ActionLoadingPreference.none,
                          );
                        }
                      },
              ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingFromLTRB(context, 16, 4, 0, 0),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'checkbox':
        final checked = component['defaultValue'] as bool? ?? false;
        _boolValues.putIfAbsent(name, () => checked);
        return CheckboxListTile(
          value: _boolValues[name] ?? checked,
          title: Text(component['label'] as String? ?? name),
          subtitle: fieldError != null || helperText != null
              ? Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                )
              : null,
          onChanged: disabled
              ? null
              : (value) {
                  if (value == null) return;
                  setState(() {
                    _boolValues[name] = value;
                  });
                  _setFieldValue(name, value);
                  _handleFieldInteraction(
                    name,
                    markTouched: true,
                    validate: true,
                  );
                },
        );
      case 'checkbox.group':
        final options =
            (component['options'] as List?)?.cast<Map<String, Object?>>() ??
                const [];
        final selected = _multiSelectValues.putIfAbsent(name, () {
          final initial = <Object?>[];
          final existing = _formState[name];
          if (existing is List) {
            initial.addAll(existing);
          }
          final defaults = component['defaultValue'];
          if (defaults is List) {
            initial.addAll(defaults);
          }
          return initial.toSet();
        });
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            for (final option in options)
              CheckboxListTile(
                value: selected.contains(option['value']),
                title: Text(option['label'] as String? ??
                    option['value']?.toString() ??
                    ''),
                subtitle: option['description'] != null
                    ? Text(option['description'] as String)
                    : null,
                onChanged: disabled
                    ? null
                    : (value) {
                        final checked = value ?? false;
                        setState(() {
                          if (checked) {
                            selected.add(option['value']);
                          } else {
                            selected.remove(option['value']);
                          }
                        });
                        _setFieldValue(name, selected.toList());
                        _handleFieldInteraction(
                          name,
                          markTouched: true,
                          validate: true,
                        );
                      },
              ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingFromLTRB(context, 16, 4, 0, 0),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'toggle':
        final checked = component['defaultValue'] as bool? ?? false;
        _boolValues.putIfAbsent(name, () => checked);
        return SwitchListTile(
          value: _boolValues[name] ?? checked,
          title: Text(component['label'] as String? ?? name),
          subtitle: fieldError != null || helperText != null
              ? Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                )
              : null,
          onChanged: disabled
              ? null
              : (value) {
                  setState(() => _boolValues[name] = value);
                  _setFieldValue(name, value);
                  _handleFieldInteraction(
                    name,
                    markTouched: true,
                    validate: true,
                  );
                },
        );
      case 'date.picker':
        final defaultValue = component['defaultValue'] as String?;
        final mode = (component['mode'] as String? ?? 'date').toLowerCase();
        final minDate = DateTime.tryParse(component['min'] as String? ?? '');
        final maxDate = DateTime.tryParse(component['max'] as String? ?? '');
        if (!_formState.containsKey(name) && defaultValue != null) {
          _setFieldValue(name, defaultValue);
        }
        final currentValue = (_formState.containsKey(name)
            ? _formState[name]
            : defaultValue) as String?;
        final displayValue = _formatDateDisplay(currentValue, mode);
        final timeMin = _tryParseTimeOfDay(component['min'] as String?);
        final timeMax = _tryParseTimeOfDay(component['max'] as String?);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ListTile(
              title: Text(component['label'] as String? ?? 'Select date'),
              subtitle: displayValue != null ? Text(displayValue) : null,
              trailing: Icon(
                mode == 'time' ? Icons.schedule : Icons.calendar_today,
              ),
              onTap: disabled
                  ? null
                  : () async {
                      final now = DateTime.now();
                      if (mode == 'time') {
                        final initialTime = currentValue != null
                            ? _tryParseTimeOfDay(currentValue) ??
                                TimeOfDay.fromDateTime(now)
                            : TimeOfDay.fromDateTime(now);
                        final picked = await showTimePicker(
                          context: context,
                          initialTime: initialTime,
                        );
                        if (picked == null) return;
                        if (timeMin != null &&
                            _compareTimeOfDay(picked, timeMin) < 0) {
                          if (mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text(
                                  'Time must be after '
                                  '${_formatTimeOfDay(timeMin)}.',
                                ),
                              ),
                            );
                          }
                          _handleFieldInteraction(
                            name,
                            markTouched: true,
                            validate: true,
                          );
                          return;
                        }
                        if (timeMax != null &&
                            _compareTimeOfDay(picked, timeMax) > 0) {
                          if (mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: Text(
                                  'Time must be before '
                                  '${_formatTimeOfDay(timeMax)}.',
                                ),
                              ),
                            );
                          }
                          _handleFieldInteraction(
                            name,
                            markTouched: true,
                            validate: true,
                          );
                          return;
                        }
                        final value =
                            '${picked.hour.toString().padLeft(2, '0')}:${picked.minute.toString().padLeft(2, '0')}';
                        setState(() {
                          _setFieldValue(name, value);
                        });
                        _handleFieldInteraction(
                          name,
                          markTouched: true,
                          validate: true,
                        );
                        return;
                      }
                      final initialDate = currentValue != null
                          ? DateTime.tryParse(currentValue) ?? now
                          : now;
                      final selectedDate = await showDatePicker(
                        context: context,
                        initialDate: initialDate,
                        firstDate: minDate ?? DateTime(2000),
                        lastDate: maxDate ?? DateTime(2100),
                      );
                      if (selectedDate == null) {
                        return;
                      }
                      DateTime result = selectedDate;
                      if (mode == 'datetime') {
                        final initialTime = currentValue != null
                            ? _tryParseTimeOfDay(currentValue) ??
                                TimeOfDay.fromDateTime(now)
                            : TimeOfDay.fromDateTime(now);
                        final time = await showTimePicker(
                          context: context,
                          initialTime: initialTime,
                        );
                        if (time != null) {
                          result = DateTime(
                            selectedDate.year,
                            selectedDate.month,
                            selectedDate.day,
                            time.hour,
                            time.minute,
                          );
                        }
                      }
                      final iso = result.toIso8601String();
                      setState(() {
                        _setFieldValue(name, iso);
                      });
                      _handleFieldInteraction(
                        name,
                        markTouched: true,
                        validate: true,
                      );
                    },
            ),
            if (fieldError != null || helperText != null)
              Padding(
                padding:
                    _spacingSymmetric(context, horizontal: 16, vertical: 4),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'slider':
        final min = (component['min'] as num?)?.toDouble() ?? 0;
        final max = (component['max'] as num?)?.toDouble() ?? 100;
        final step = (component['step'] as num?)?.toDouble() ?? 1;
        final defaultValue =
            (component['defaultValue'] as num?)?.toDouble() ?? min;
        final value = _sliderValues.putIfAbsent(name, () => defaultValue);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (component['label'] != null)
              Padding(
                padding: _spacingOnly(context, bottom: 4),
                child: Text(component['label'] as String),
              ),
            Slider(
              value: value.clamp(min, max),
              min: min,
              max: max,
              divisions: ((max - min) / step).round().clamp(1, 1000),
              label: value.toStringAsFixed(0),
              onChanged: disabled
                  ? null
                  : (newValue) {
                      setState(() {
                        _sliderValues[name] = newValue;
                      });
                      _setFieldValue(name, newValue);
                      _handleFieldInteraction(
                        name,
                        markTouched: true,
                        validate: true,
                      );
                    },
            ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingOnly(context, top: 4),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'stepper':
      case 'number.stepper':
        final min = (component['min'] as num?)?.toInt() ?? 0;
        final max = (component['max'] as num?)?.toInt() ?? 100;
        final step = (component['step'] as num?)?.toInt() ?? 1;
        final defaultValue =
            (component['defaultValue'] as num?)?.toInt() ?? min;
        final value = _stepperValues.putIfAbsent(name, () => defaultValue);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: disabled || value <= min
                      ? null
                      : () {
                          setState(() {
                            final next = (value - step).clamp(min, max);
                            _stepperValues[name] = next;
                            _setFieldValue(name, next);
                          });
                          _handleFieldInteraction(
                            name,
                            markTouched: true,
                            validate: true,
                          );
                        },
                ),
                SizedBox(
                  width: 48,
                  child: Text(
                    '${_stepperValues[name]}',
                    textAlign: TextAlign.center,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: disabled || value >= max
                      ? null
                      : () {
                          setState(() {
                            final next = (value + step).clamp(min, max);
                            _stepperValues[name] = next;
                            _setFieldValue(name, next);
                          });
                          _handleFieldInteraction(
                            name,
                            markTouched: true,
                            validate: true,
                          );
                        },
                ),
              ],
            ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingOnly(context, top: 4),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'otp':
        final length = (component['length'] as num?)?.toInt() ?? 6;
        final controllers = _otpControllers.putIfAbsent(
          name,
          () => List.generate(
            length,
            (_) => TextEditingController(),
          ),
        );
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                for (var i = 0; i < controllers.length; i++)
                  SizedBox(
                    width: 40,
                    child: TextField(
                      controller: controllers[i],
                      readOnly: readOnly,
                      enabled: !disabled,
                      textAlign: TextAlign.center,
                      maxLength: 1,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(counterText: ''),
                      onChanged: (value) {
                        final code = controllers.map((c) => c.text).join();
                        _setFieldValue(name, code);
                        if (value.isNotEmpty && i < controllers.length - 1) {
                          FocusScope.of(context).nextFocus();
                        }
                        _handleFieldInteraction(
                          name,
                          markTouched: true,
                          validate: true,
                        );
                      },
                    ),
                  ),
              ],
            ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingOnly(context, top: 4),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'signature':
        final controller = _signatureControllerFor(context, name);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            SizedBox(
              height: 160,
              child: DecoratedBox(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: Theme.of(context).colorScheme.outlineVariant,
                  ),
                  borderRadius: _circularRadius(context, 12),
                ),
                child: Signature(
                  controller: controller,
                  backgroundColor:
                      Theme.of(context).colorScheme.surfaceContainerLowest,
                ),
              ),
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                FilledButton.tonal(
                  onPressed: controller.isEmpty
                      ? null
                      : () {
                          controller.clear();
                          _setFieldValue(name, null);
                          _handleFieldInteraction(
                            name,
                            markTouched: true,
                            validate: true,
                          );
                        },
                  child: const Text('Clear'),
                ),
                const SizedBox(width: 8),
                FilledButton(
                  onPressed: () async {
                    final bytes = await controller.toPngBytes();
                    _setFieldValue(name, bytes);
                    _handleFieldInteraction(
                      name,
                      markTouched: true,
                      validate: true,
                    );
                  },
                  child: const Text('Save'),
                ),
              ],
            ),
            if (fieldError != null || helperText != null)
              Padding(
                padding: _spacingOnly(context, top: 8),
                child: Text(
                  fieldError ?? helperText ?? '',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: fieldError != null
                            ? Theme.of(context).colorScheme.error
                            : null,
                      ),
                ),
              ),
          ],
        );
      case 'file.upload':
        final action = component['onUploadAction'] as Map<String, Object?>?;
        return FilledButton.icon(
          onPressed: disabled
              ? null
              : () {
                  if (action != null) {
                    _dispatchAction(
                      action,
                      context,
                      preference: _ActionLoadingPreference.none,
                    );
                  }
                },
          icon: const Icon(Icons.upload_file),
          label: Text(component['label'] as String? ?? 'Upload'),
        );
      case 'captcha':
        final description =
            component['description'] as String? ?? 'Complete verification';
        final action = component['onVerifyAction'] as Map<String, Object?>?;
        return Card(
          child: Padding(
            padding: _spacingAll(context, 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(description),
                const SizedBox(height: 12),
                FilledButton(
                  onPressed: action == null
                      ? null
                      : () => _dispatchAction(
                            action,
                            context,
                            preference: _ActionLoadingPreference.none,
                          ),
                  child: Text(component['buttonLabel'] as String? ?? 'Verify'),
                ),
              ],
            ),
          ),
        );
      default:
        return Text('Unsupported form control ${component['type']}');
    }
  }

  Widget _buildSelectControl({
    required Map<String, Object?> component,
    required BuildContext context,
    required String name,
    required InputDecoration decoration,
    required bool disabled,
    required bool multi,
  }) {
    final focusNode = _selectFocusNodes.putIfAbsent(name, () => FocusNode());
    final options = _normalizeSelectOptions(component);
    final totalOptions =
        options.fold<int>(0, (count, group) => count + group.options.length);
    final placeholder = component['placeholder'] as String?;
    final clearable = component['clearable'] as bool? ?? false;
    final loading = component['loading'] as bool? ?? false;
    final searchableOverride =
        component['searchable'] as bool? ?? component['enableSearch'] as bool?;
    final searchPlaceholder =
        component['searchPlaceholder'] as String? ?? 'Search';
    final emptyText = component['emptyText'] as String? ??
        component['emptyState'] as String? ??
        'No options available';
    final onSearchAction = component['onSearchAction'] as Map<String, Object?>?;
    final onChangeAction = component['onChangeAction'] as Map<String, Object?>?;

    Object? currentValue;
    _SelectOption? currentOption;
    if (!multi) {
      currentValue = _formState.containsKey(name)
          ? _formState[name]
          : component['defaultValue'];
      currentOption = _findSelectOption(options, currentValue);
      if (currentOption == null) {
        currentValue = null;
      } else {
        currentValue = currentOption.value;
      }
      if (!_formState.containsKey(name) || _formState[name] != currentValue) {
        _setFieldValue(name, currentValue);
      }
    }

    final selectedSet = multi
        ? _multiSelectValues.putIfAbsent(name, () {
            final initial = <Object?>[];
            final existing = _formState[name];
            if (existing is List) {
              initial.addAll(existing);
            }
            final defaults = component['defaultValue'];
            if (defaults is List) {
              initial.addAll(defaults);
            }
            return initial.toSet();
          })
        : null;
    if (multi && selectedSet != null) {
      _setFieldValue(name, selectedSet.toList());
    }

    final bool isEmpty =
        multi ? (selectedSet?.isEmpty ?? true) : currentValue == null;

    final theme = Theme.of(context);
    final hintStyle = theme.textTheme.bodyMedium?.copyWith(
      color: theme.hintColor,
    );

    Widget valueWidget;
    if (multi) {
      final chips = <Widget>[];
      if (selectedSet != null) {
        for (final value in selectedSet) {
          final option = _findSelectOption(options, value);
          final label = option?.label ?? value?.toString() ?? '';
          chips.add(
            InputChip(
              label: Text(label),
              onDeleted: disabled
                  ? null
                  : () {
                      setState(() {
                        selectedSet.remove(value);
                        _setFieldValue(name, selectedSet.toList());
                      });
                      _handleFieldInteraction(
                        name,
                        markTouched: true,
                        validate: true,
                      );
                      if (onChangeAction != null) {
                        _dispatchAction(
                          onChangeAction,
                          context,
                          payloadOverride: {
                            'name': name,
                            'values': selectedSet.toList(),
                          },
                          preference: _ActionLoadingPreference.none,
                        );
                      }
                    },
            ),
          );
        }
      }
      valueWidget = chips.isEmpty
          ? Text(placeholder ?? 'Select options', style: hintStyle)
          : Wrap(
              spacing: 8,
              runSpacing: 8,
              children: chips,
            );
    } else {
      if (currentOption != null) {
        valueWidget = Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(currentOption.label),
            if (currentOption.description != null &&
                currentOption.description!.isNotEmpty)
              Padding(
                padding: _spacingOnly(context, top: 2),
                child: Text(
                  currentOption.description!,
                  style: theme.textTheme.bodySmall,
                ),
              ),
          ],
        );
      } else {
        valueWidget = Text(
          placeholder ?? 'Select an option',
          style: hintStyle,
        );
      }
    }

    final suffixChildren = <Widget>[];
    if (!disabled && clearable && !isEmpty) {
      suffixChildren.add(
        IconButton(
          icon: const Icon(Icons.clear),
          tooltip: 'Clear selection',
          onPressed: () {
            if (multi) {
              final target = selectedSet ?? <Object?>{};
              if (target.isEmpty) return;
              setState(() {
                target.clear();
                _setFieldValue(name, const <Object?>[]);
              });
              _handleFieldInteraction(
                name,
                markTouched: true,
                validate: true,
              );
              if (onChangeAction != null) {
                _dispatchAction(
                  onChangeAction,
                  context,
                  payloadOverride: {
                    'name': name,
                    'values': const <Object?>[],
                  },
                  preference: _ActionLoadingPreference.none,
                );
              }
            } else {
              if (_formState[name] == null) return;
              setState(() {
                _setFieldValue(name, null);
              });
              _handleFieldInteraction(
                name,
                markTouched: true,
                validate: true,
              );
              if (onChangeAction != null) {
                _dispatchAction(
                  onChangeAction,
                  context,
                  payloadOverride: {'name': name, 'value': null},
                  preference: _ActionLoadingPreference.none,
                );
              }
            }
          },
        ),
      );
    }
    suffixChildren.add(const Icon(Icons.arrow_drop_down));

    final effectiveDecoration = decoration.copyWith(
      enabled: !disabled,
      suffixIcon: SizedBox(
        width: suffixChildren.length * 40,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          mainAxisSize: MainAxisSize.min,
          children: suffixChildren,
        ),
      ),
      suffixIconConstraints: BoxConstraints(
        minHeight: 40,
        minWidth: suffixChildren.length * 32.0,
      ),
    );

    final bool searchable = searchableOverride ?? totalOptions > 8;

    Future<void> handleTap() async {
      if (disabled) return;
      focusNode.requestFocus();
      if (multi) {
        final result = await _showMultiSelectSheet(
          context: context,
          name: name,
          groups: options,
          selectedValues: selectedSet ?? <Object?>{},
          searchable: searchable,
          loading: loading,
          clearable: clearable,
          searchPlaceholder: searchPlaceholder,
          emptyText: emptyText,
          onSearchAction: onSearchAction,
        );
        focusNode.unfocus();
        if (result == null) return;
        setState(() {
          final target = selectedSet ?? <Object?>{};
          target
            ..clear()
            ..addAll(result.values);
          _multiSelectValues[name] = target;
          _setFieldValue(name, target.toList());
        });
        _handleFieldInteraction(
          name,
          markTouched: true,
          validate: true,
        );
        if (onChangeAction != null) {
          _dispatchAction(
            onChangeAction,
            context,
            payloadOverride: {
              'name': name,
              'values': result.values.toList(),
            },
            preference: _ActionLoadingPreference.none,
          );
        }
      } else {
        final result = await _showSingleSelectSheet(
          context: context,
          name: name,
          groups: options,
          selectedValue: currentValue,
          searchable: searchable,
          loading: loading,
          clearable: clearable,
          searchPlaceholder: searchPlaceholder,
          emptyText: emptyText,
          onSearchAction: onSearchAction,
        );
        focusNode.unfocus();
        if (result == null) return;
        if (result.cleared) {
          if (_formState[name] != null) {
            setState(() {
              _setFieldValue(name, null);
            });
            _handleFieldInteraction(
              name,
              markTouched: true,
              validate: true,
            );
            if (onChangeAction != null) {
              _dispatchAction(
                onChangeAction,
                context,
                payloadOverride: {'name': name, 'value': null},
                preference: _ActionLoadingPreference.none,
              );
            }
          }
        } else {
          final newValue = result.value;
          if (_formState[name] != newValue) {
            setState(() {
              _setFieldValue(name, newValue);
            });
            _handleFieldInteraction(
              name,
              markTouched: true,
              validate: true,
            );
            if (onChangeAction != null) {
              _dispatchAction(
                onChangeAction,
                context,
                payloadOverride: {'name': name, 'value': newValue},
                preference: _ActionLoadingPreference.none,
              );
            }
          }
        }
      }
    }

    return Focus(
      focusNode: focusNode,
      child: Material(
        color: _chatThemeOf(context).palette.transparent,
        child: InkWell(
          onTap: disabled ? null : handleTap,
          borderRadius: const BorderRadius.all(Radius.circular(8)),
          child: InputDecorator(
            decoration: effectiveDecoration,
            isFocused: focusNode.hasFocus,
            isEmpty: isEmpty,
            child: valueWidget,
          ),
        ),
      ),
    );
  }

  Future<_SingleSelectResult?> _showSingleSelectSheet({
    required BuildContext context,
    required String name,
    required List<_SelectOptionGroup> groups,
    required Object? selectedValue,
    required bool searchable,
    required bool loading,
    required bool clearable,
    required String searchPlaceholder,
    required String emptyText,
    required Map<String, Object?>? onSearchAction,
  }) {
    final initialQuery = _selectSearchQuery[name] ?? '';
    final inheritedTheme = ChatKitTheme.of(context);
    return showModalBottomSheet<_SingleSelectResult>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (sheetContext) {
        return ChatKitTheme(
          data: inheritedTheme,
          child: _SingleSelectSheet(
            initialQuery: initialQuery,
            selectedValue: selectedValue,
            searchable: searchable,
            loading: loading,
            clearable: clearable,
            searchPlaceholder: searchPlaceholder,
            emptyText: emptyText,
            optionGroupsResolver: (query) =>
                _filterSelectOptions(groups, query),
            onQueryChanged: (query) => _handleSelectSearch(
              name,
              query,
              onSearchAction,
              context,
            ),
            spacingFromLTRB: (ctx, left, top, right, bottom) =>
                _spacingFromLTRB(ctx, left, top, right, bottom),
            spacingAll: (ctx, value) => _spacingAll(ctx, value),
            iconResolver: _iconFromName,
          ),
        );
      },
    );
  }

  Future<_MultiSelectResult?> _showMultiSelectSheet({
    required BuildContext context,
    required String name,
    required List<_SelectOptionGroup> groups,
    required Set<Object?> selectedValues,
    required bool searchable,
    required bool loading,
    required bool clearable,
    required String searchPlaceholder,
    required String emptyText,
    required Map<String, Object?>? onSearchAction,
  }) {
    final initialQuery = _selectSearchQuery[name] ?? '';
    final inheritedTheme = ChatKitTheme.of(context);
    return showModalBottomSheet<_MultiSelectResult>(
      context: context,
      isScrollControlled: true,
      showDragHandle: true,
      builder: (sheetContext) {
        return ChatKitTheme(
          data: inheritedTheme,
          child: _MultiSelectSheet(
            initialQuery: initialQuery,
            initialSelection: selectedValues,
            searchable: searchable,
            loading: loading,
            clearable: clearable,
            searchPlaceholder: searchPlaceholder,
            emptyText: emptyText,
            optionGroupsResolver: (query) =>
                _filterSelectOptions(groups, query),
            onQueryChanged: (query) => _handleSelectSearch(
              name,
              query,
              onSearchAction,
              context,
            ),
            spacingFromLTRB: (ctx, left, top, right, bottom) =>
                _spacingFromLTRB(ctx, left, top, right, bottom),
            spacingAll: (ctx, value) => _spacingAll(ctx, value),
            iconResolver: _iconFromName,
          ),
        );
      },
    );
  }

  void _handleSelectSearch(
    String name,
    String query,
    Map<String, Object?>? action,
    BuildContext context,
  ) {
    _selectSearchQuery[name] = query;
    _selectSearchDebounce[name]?.cancel();
    if (action == null) {
      return;
    }
    _selectSearchDebounce[name] = Timer(
      const Duration(milliseconds: 300),
      () {
        _dispatchAction(
          action,
          context,
          payloadOverride: {
            'name': name,
            'query': query,
          },
          preference: _ActionLoadingPreference.none,
        );
      },
    );
  }

  _ActionLoadingPreference _resolveActionLoadingBehavior(
    Object? raw,
    _ActionLoadingPreference preference,
  ) {
    final normalized = (raw as String?)?.toLowerCase().trim();
    switch (normalized) {
      case 'none':
        return _ActionLoadingPreference.none;
      case 'self':
        return _ActionLoadingPreference.self;
      case 'container':
        return _ActionLoadingPreference.container;
      case 'auto':
      case null:
        if (preference == _ActionLoadingPreference.auto) {
          return _ActionLoadingPreference.self;
        }
        return preference;
      default:
        return preference == _ActionLoadingPreference.auto
            ? _ActionLoadingPreference.self
            : preference;
    }
  }

  List<_SelectOptionGroup> _normalizeSelectOptions(
    Map<String, Object?> component,
  ) {
    final result = <_SelectOptionGroup>[];
    final groupsData = component['groups'];
    if (groupsData is List) {
      for (final entry in groupsData) {
        final map = castMap(entry);
        final groupOptions =
            (map['options'] as List?)?.map(castMap).toList() ?? const [];
        if (groupOptions.isEmpty) continue;
        result.add(
          _SelectOptionGroup(
            label: map['label'] as String? ?? map['title'] as String?,
            options: [
              for (final option in groupOptions) _SelectOption.fromMap(option),
            ],
          ),
        );
      }
    }

    final optionsData = component['options'];
    if (optionsData is List) {
      bool hasNested = false;
      for (final entry in optionsData) {
        if (entry is Map<String, Object?> && entry['options'] is List) {
          hasNested = true;
          final nested = (entry['options'] as List)
              .whereType<Map<String, Object?>>()
              .toList();
          if (nested.isEmpty) continue;
          result.add(
            _SelectOptionGroup(
              label: entry['label'] as String? ??
                  entry['group'] as String? ??
                  entry['title'] as String?,
              options: [
                for (final option in nested) _SelectOption.fromMap(option),
              ],
            ),
          );
        }
      }

      if (!hasNested) {
        final grouped = <String?, List<_SelectOption>>{};
        for (final entry in optionsData) {
          if (entry is Map<String, Object?>) {
            final option = _SelectOption.fromMap(entry);
            final groupLabel =
                entry['group'] as String? ?? entry['section'] as String?;
            grouped.putIfAbsent(groupLabel, () => []).add(option);
          }
        }
        if (grouped.isEmpty) {
          result.add(
            _SelectOptionGroup(
              label: null,
              options: [
                for (final entry in optionsData)
                  if (entry is Map<String, Object?>)
                    _SelectOption.fromMap(entry),
              ],
            ),
          );
        } else {
          for (final entry in grouped.entries) {
            result.add(
              _SelectOptionGroup(
                label: entry.key,
                options: entry.value,
              ),
            );
          }
        }
      }
    }

    return result;
  }

  List<_SelectOptionGroup> _filterSelectOptions(
    List<_SelectOptionGroup> groups,
    String query,
  ) {
    final trimmed = query.trim();
    if (trimmed.isEmpty) {
      return groups;
    }
    final lower = trimmed.toLowerCase();
    final result = <_SelectOptionGroup>[];
    for (final group in groups) {
      final matches = <_SelectOption>[];
      for (final option in group.options) {
        final label = option.label.toLowerCase();
        final description = option.description?.toLowerCase() ?? '';
        if (label.contains(lower) || description.contains(lower)) {
          matches.add(option);
        }
      }
      if (matches.isNotEmpty) {
        result.add(_SelectOptionGroup(label: group.label, options: matches));
      } else if ((group.label ?? '').toLowerCase().contains(lower)) {
        result.add(group);
      }
    }
    return result;
  }

  _SelectOption? _findSelectOption(
    List<_SelectOptionGroup> groups,
    Object? value,
  ) {
    for (final group in groups) {
      for (final option in group.options) {
        if (option.value == value) {
          return option;
        }
      }
    }
    return null;
  }

  Widget _buildMetadata(Map<String, Object?> component, BuildContext context) {
    final entries =
        (component['entries'] as List?)?.cast<Map<String, Object?>>() ??
            const [];
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        for (final entry in entries)
          Padding(
            padding: _spacingSymmetric(context, vertical: 2),
            child: Row(
              children: [
                Text('${entry['label']}: ',
                    style: const TextStyle(fontWeight: FontWeight.bold)),
                Expanded(child: Text(entry['value'] as String? ?? '')),
              ],
            ),
          ),
      ],
    );
  }

  Widget _buildProgress(Map<String, Object?> component, BuildContext context) {
    final value = (component['value'] as num?)?.toDouble() ?? 0;
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        LinearProgressIndicator(value: value == 0 ? null : value.clamp(0, 1)),
        if (component['label'] != null)
          Padding(
            padding: _spacingOnly(context, top: 4),
            child: Text(component['label'] as String),
          ),
      ],
    );
  }

  Widget _buildIcon(
    Map<String, Object?> component,
    BuildContext context, {
    bool iconOnly = false,
  }) {
    final iconName =
        (component['name'] as String?) ?? (component['icon'] as String?);
    final iconData = _iconFromName(iconName);
    if (iconData == null) {
      return const SizedBox.shrink();
    }

    final size = (component['size'] as num?)?.toDouble();
    final color = _colorFromToken(context, component['color']) ??
        Theme.of(context).iconTheme.color;
    final padding = _edgeInsets(component['padding'], context);
    final margin = _edgeInsets(component['margin'], context);
    final tooltip = component['tooltip'] as String?;
    final label = component['label'] as String?;

    Widget result = Icon(iconData, size: size ?? 20, color: color);
    if (!iconOnly && label != null && label.isNotEmpty) {
      result = Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          result,
          const SizedBox(width: 8),
          Flexible(
            child: Text(
              label,
              style: Theme.of(context).textTheme.labelLarge,
            ),
          ),
        ],
      );
    }
    if (padding != null) {
      result = Padding(padding: padding, child: result);
    }
    if (tooltip != null && tooltip.isNotEmpty) {
      result = Tooltip(message: tooltip, child: result);
    }
    if (margin != null) {
      result = Container(margin: margin, child: result);
    }
    return result;
  }

  Widget _buildBadge(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final label = component['label'] as String? ?? '';
    final variant =
        (component['variant'] as String? ?? 'solid').toLowerCase().trim();
    final sizeToken = (component['size'] as String? ?? 'md').toLowerCase();
    final pill = component['pill'] as bool? ?? false;

    final padding = switch (sizeToken) {
      'sm' => _spacingSymmetric(context, horizontal: 8, vertical: 2),
      'lg' => _spacingSymmetric(context, horizontal: 12, vertical: 6),
      _ => _spacingSymmetric(context, horizontal: 10, vertical: 4),
    };

    final theme = Theme.of(context);
    final palette = _chatThemeOf(context).palette;
    final color = _colorFromToken(context, component['color']) ??
        theme.colorScheme.primary;
    final Color background;
    final Color border;
    final Color foreground;
    switch (variant) {
      case 'soft':
        background = color.withValues(alpha: 0.15);
        border = color.withValues(alpha: 0.3);
        foreground = color;
        break;
      case 'outline':
        background = palette.transparent;
        border = color.withValues(alpha: 0.6);
        foreground = color;
        break;
      default:
        background = color;
        border = palette.transparent;
        foreground = theme.colorScheme.onPrimary;
        break;
    }

    return Container(
      padding: padding,
      decoration: BoxDecoration(
        color: background,
        border: Border.all(color: border),
        borderRadius: BorderRadius.circular(pill ? 999 : 8),
      ),
      child: Text(
        label,
        style: theme.textTheme.labelSmall?.copyWith(
          color: foreground,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Widget _buildSpacer(Map<String, Object?> component) {
    final minSize = (component['minSize'] as num?)?.toDouble();
    final size = (component['size'] as num?)?.toDouble();
    final height = (component['height'] as num?)?.toDouble() ?? size ?? minSize;
    final width = (component['width'] as num?)?.toDouble() ?? size;
    return SizedBox(
      height: height ?? 16,
      width: width,
    );
  }

  Widget _buildDefinitionList(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final entries =
        (component['entries'] as List?)?.cast<Map<String, Object?>>() ??
            const [];
    if (entries.isEmpty) {
      return const SizedBox.shrink();
    }
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        for (final entry in entries)
          Padding(
            padding: _spacingSymmetric(context, vertical: 6),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  flex: 1,
                  child: Text(
                    (entry['term'] ?? entry['label'] ?? '') as String,
                    style: Theme.of(context)
                        .textTheme
                        .labelLarge
                        ?.copyWith(fontWeight: FontWeight.w600),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  flex: 2,
                  child: entry['description'] is Map<String, Object?>
                      ? _buildComponent(
                          entry['description']! as Map<String, Object?>,
                          context,
                        )
                      : Text(
                          (entry['description'] ?? entry['value'] ?? '')
                              as String,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                ),
              ],
            ),
          ),
      ],
    );
  }

  Widget _buildPagination(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final current = (component['page'] as num?)?.toInt() ??
        (component['currentPage'] as num?)?.toInt() ??
        1;
    final total = (component['totalPages'] as num?)?.toInt() ??
        (component['pages'] as num?)?.toInt() ??
        1;
    final action = component['onChangeAction'] as Map<String, Object?>?;
    final allowPrev = current > 1;
    final allowNext = current < total;

    Future<void> changePage(int newPage) async {
      if (action == null) return;
      await _dispatchAction(
        action,
        context,
        payloadOverride: {
          'page': newPage,
        },
        preference: _ActionLoadingPreference.none,
      );
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        IconButton(
          icon: const Icon(Icons.chevron_left),
          onPressed: allowPrev ? () => changePage(current - 1) : null,
        ),
        Text('$current / $total'),
        IconButton(
          icon: const Icon(Icons.chevron_right),
          onPressed: allowNext ? () => changePage(current + 1) : null,
        ),
      ],
    );
  }

  Widget _buildAccordion(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final id = component['id'] as String? ?? widget.item.id;
    final items =
        (component['items'] as List?)?.cast<Map<String, Object?>>() ?? const [];
    if (items.isEmpty) {
      return const SizedBox.shrink();
    }
    final allowMultiple = component['allowMultiple'] as bool? ?? true;

    return ExpansionPanelList(
      expansionCallback: (index, isExpanded) {
        setState(() {
          final key = '$id::$index';
          if (!allowMultiple) {
            for (final entry in items.indexed) {
              _accordionExpanded['$id::${entry.$1}'] =
                  entry.$1 == index ? !isExpanded : false;
            }
          } else {
            _accordionExpanded[key] = !isExpanded;
          }
        });
      },
      children: [
        for (final entry in items.indexed)
          _accordionPanel(entry.$2, context, id, entry.$1),
      ],
    );
  }

  Widget _buildAccordionItem(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    return _buildAccordion(
      {
        'id': component['id'] ?? widget.item.id,
        'items': [component],
      },
      context,
    );
  }

  ExpansionPanel _accordionPanel(
    Map<String, Object?> item,
    BuildContext context,
    String accordionId,
    int index,
  ) {
    final title = item['title'] as String? ?? '';
    final subtitle = item['subtitle'] as String?;
    final defaultExpanded = item['expanded'] as bool? ?? false;
    final key = '$accordionId::$index';
    final isExpanded =
        _accordionExpanded.putIfAbsent(key, () => defaultExpanded);

    return ExpansionPanel(
      canTapOnHeader: true,
      isExpanded: isExpanded,
      headerBuilder: (context, isOpen) {
        return ListTile(
          title: Text(title),
          subtitle: subtitle != null ? Text(subtitle) : null,
        );
      },
      body: Padding(
        padding: _spacingSymmetric(context, horizontal: 12, vertical: 8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: _buildChildren(item['children'], context),
        ),
      ),
    );
  }

  Widget _buildModal(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final trigger = castMap(component['trigger']);
    final title = component['title'] as String?;
    final placement =
        (component['placement'] as String? ?? 'dialog').toLowerCase();
    final actions =
        (component['actions'] as List?)?.cast<Map<String, Object?>>() ??
            const [];

    Future<void> show() async {
      if (placement == 'sheet') {
        await showModalBottomSheet<void>(
          context: context,
          showDragHandle: true,
          builder: (context) {
            return Padding(
              padding: _spacingAll(context, 16),
              child: _buildModalContent(
                context,
                title,
                actions,
                component['children'],
              ),
            );
          },
        );
      } else {
        await showDialog<void>(
          context: context,
          builder: (context) {
            return AlertDialog(
              title: title != null ? Text(title) : null,
              content: SingleChildScrollView(
                child: _buildModalBody(context, component['children']),
              ),
              actions: [
                for (final action in actions)
                  TextButton(
                    onPressed: () async {
                      Navigator.of(context).pop();
                      await _dispatchAction(
                        action,
                        context,
                        preference: _ActionLoadingPreference.none,
                      );
                    },
                    child: Text(action['label'] as String? ?? 'OK'),
                  ),
              ],
            );
          },
        );
      }
    }

    final triggerLabel =
        trigger['label'] as String? ?? component['label'] as String? ?? 'Open';
    return FilledButton(
      onPressed: show,
      child: Text(triggerLabel),
    );
  }

  Widget _buildModalContent(
    BuildContext context,
    String? title,
    List<Map<String, Object?>> actions,
    Object? children,
  ) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (title != null)
          Padding(
            padding: _spacingOnly(context, bottom: 12),
            child: Text(
              title,
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ),
        _buildModalBody(context, children),
        if (actions.isNotEmpty)
          Padding(
            padding: _spacingOnly(context, top: 16),
            child: Wrap(
              spacing: 8,
              children: actions
                  .map(
                    (action) => FilledButton.tonal(
                      onPressed: () => _dispatchAction(
                        action,
                        context,
                        preference: _ActionLoadingPreference.none,
                      ),
                      child: Text(action['label'] as String? ?? 'Action'),
                    ),
                  )
                  .toList(),
            ),
          ),
      ],
    );
  }

  Widget _buildModalBody(BuildContext context, Object? children) {
    final nodes = _buildChildren(children, context);
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: nodes,
    );
  }

  Widget _buildWizard(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final steps =
        (component['steps'] as List?)?.cast<Map<String, Object?>>() ?? const [];
    if (steps.isEmpty) {
      return const SizedBox.shrink();
    }
    final id = component['id'] as String? ?? widget.item.id;
    final current =
        _wizardStepIndex.putIfAbsent(id, () => 0).clamp(0, steps.length - 1);

    Future<void> goTo(int target) async {
      setState(() {
        _wizardStepIndex[id] = target;
      });
      final onChange = component['onStepChangeAction'] as Map<String, Object?>?;
      if (onChange != null) {
        await _dispatchAction(
          onChange,
          context,
          payloadOverride: {'step': target},
          preference: _ActionLoadingPreference.container,
        );
      }
    }

    Future<void> finish() async {
      final action = component['onFinishAction'] as Map<String, Object?>?;
      if (action != null) {
        await _dispatchAction(
          action,
          context,
          preference: _ActionLoadingPreference.container,
        );
      }
    }

    return Stepper(
      currentStep: current,
      onStepTapped: (index) => goTo(index),
      controlsBuilder: (context, details) {
        final isLast = current == steps.length - 1;
        return Row(
          children: [
            FilledButton(
              onPressed: () async {
                if (isLast) {
                  await finish();
                } else {
                  await goTo(current + 1);
                }
              },
              child: Text(isLast
                  ? (component['finishLabel'] as String? ?? 'Finish')
                  : (component['nextLabel'] as String? ?? 'Next')),
            ),
            const SizedBox(width: 8),
            TextButton(
              onPressed: current > 0 ? () => goTo(current - 1) : null,
              child: Text(component['previousLabel'] as String? ?? 'Previous'),
            ),
          ],
        );
      },
      steps: [
        for (final entry in steps.indexed)
          Step(
            isActive: current >= entry.$1,
            title: Text(entry.$2['title'] as String? ?? 'Step ${entry.$1 + 1}'),
            subtitle: entry.$2['subtitle'] != null
                ? Text(entry.$2['subtitle'] as String)
                : null,
            content: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: _buildChildren(entry.$2['children'], context),
            ),
          ),
      ],
    );
  }

  Widget _buildWizardStep(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    return _buildWizard(
      {
        'steps': [component],
        'id': component['id'] ?? widget.item.id,
      },
      context,
    );
  }

  Widget _buildSegmentedControl(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final name =
        component['name'] as String? ?? component['id'] as String? ?? '';
    final options =
        (component['options'] as List?)?.cast<Map<String, Object?>>() ??
            const [];
    final disabled = component['disabled'] as bool? ?? false;
    final defaultValue =
        component['defaultValue'] ?? options.firstOrNull?['value'];
    final currentValue =
        _formState.containsKey(name) ? _formState[name] : defaultValue;
    if (!_formState.containsKey(name)) {
      _setFieldValue(name, currentValue);
    }

    return SegmentedButton<Object?>(
      segments: options
          .map(
            (option) => ButtonSegment<Object?>(
              value: option['value'],
              label: Text(option['label'] as String? ??
                  option['value']?.toString() ??
                  ''),
              icon: option['icon'] != null
                  ? Icon(_iconFromName(option['icon'] as String?))
                  : null,
            ),
          )
          .toList(),
      selected: {currentValue},
      onSelectionChanged: disabled
          ? null
          : (values) {
              final selected = values.firstOrNull;
              setState(() {
                _setFieldValue(name, selected);
              });
              final onChange =
                  component['onChangeAction'] as Map<String, Object?>?;
              if (onChange != null && selected != null) {
                _dispatchAction(
                  onChange,
                  context,
                  payloadOverride: {'value': selected},
                  preference: _ActionLoadingPreference.none,
                );
              }
            },
    );
  }

  Widget _buildFileViewer(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final url = component['url'] as String? ?? component['src'] as String?;
    final title = component['title'] as String? ??
        component['name'] as String? ??
        'Attachment';
    final subtitle = component['subtitle'] as String? ??
        component['description'] as String? ??
        component['mimeType'] as String?;
    final previewType = (component['preview'] as String? ?? '').toLowerCase();
    final actions =
        (component['actions'] as List?)?.cast<Map<String, Object?>>() ??
            const [];

    Widget leading;
    if (previewType == 'image' && url != null) {
      leading = ClipRRect(
        borderRadius: _circularRadius(context, 8),
        child: CachedNetworkImage(
          imageUrl: url,
          width: 48,
          height: 48,
          fit: BoxFit.cover,
        ),
      );
    } else {
      leading = const Icon(Icons.insert_drive_file);
    }

    return Card(
      child: ListTile(
        leading: leading,
        title: Text(title),
        subtitle: subtitle != null ? Text(subtitle) : null,
        trailing: actions.isEmpty
            ? (url != null
                ? IconButton(
                    icon: const Icon(Icons.download),
                    onPressed: () => _dispatchAction(
                      {
                        'type': 'open_url',
                        'payload': {'url': url},
                      },
                      context,
                      preference: _ActionLoadingPreference.none,
                    ),
                  )
                : null)
            : Wrap(
                spacing: 4,
                children: actions
                    .map(
                      (action) => IconButton(
                        icon: Icon(
                          _iconFromName(action['icon'] as String?) ??
                              Icons.open_in_new,
                        ),
                        tooltip: action['label'] as String?,
                        onPressed: () => _dispatchAction(
                          action,
                          context,
                          preference: _ActionLoadingPreference.none,
                        ),
                      ),
                    )
                    .toList(),
              ),
        onTap: url != null
            ? () => _dispatchAction(
                  {
                    'type': 'open_url',
                    'payload': {'url': url},
                  },
                  context,
                  preference: _ActionLoadingPreference.none,
                )
            : null,
      ),
    );
  }

  Widget _buildStatus(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final level = (component['level'] as String? ?? 'info').toLowerCase();
    final message =
        component['message'] as String? ?? component['text'] as String? ?? '';
    final iconData = switch (level) {
      'success' => Icons.check_circle,
      'warning' => Icons.warning_amber,
      'danger' || 'error' => Icons.error,
      _ => Icons.info,
    };
    final color = ChatKitStyles.statusColor(context, level);
    return Container(
      margin: _spacingSymmetric(context, vertical: 8),
      padding: _spacingAll(context, 12),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: _circularRadius(context, 12),
        border: Border.all(color: color.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          Icon(iconData, color: color),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              message,
              style: Theme.of(context)
                  .textTheme
                  .bodyMedium
                  ?.copyWith(color: color),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildCode(Map<String, Object?> component, BuildContext context) {
    final value = component['value'] as String? ?? '';
    final typography = widget.controller.options.resolvedTheme?.typography;
    final monospace = typography?.monospaceFontFamily ?? 'monospace';
    final style = Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontFamily: monospace,
            ) ??
        TextStyle(fontFamily: monospace);
    return Container(
      width: double.infinity,
      padding: _spacingAll(context, 12),
      margin: _spacingSymmetric(context, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: _circularRadius(context, 8),
      ),
      child: Text(value, style: style),
    );
  }

  Widget _buildBlockquote(
      Map<String, Object?> component, BuildContext context) {
    final value = component['value'] as String? ?? '';
    return Container(
      padding: _spacingAll(context, 12),
      margin: _spacingSymmetric(context, vertical: 4),
      decoration: BoxDecoration(
        border: Border(
            left: BorderSide(
                color: Theme.of(context).colorScheme.primary, width: 4)),
      ),
      child: Text(value),
    );
  }

  Widget _buildPill(Map<String, Object?> component, BuildContext context) {
    final label = component['label'] as String? ?? '';
    return Container(
      padding: _spacingSymmetric(context, horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.secondaryContainer,
        borderRadius: _circularRadius(context, 999),
      ),
      child: Text(label),
    );
  }

  Widget _buildTable(Map<String, Object?> component, BuildContext context) {
    final columnData =
        (component['columns'] as List?)?.map((e) => castMap(e)).toList() ??
            const <Map<String, Object?>>[];
    if (columnData.isEmpty) {
      return const SizedBox.shrink();
    }

    final rowData = (component['rows'] as List?)?.toList() ?? const [];
    final tableId =
        component['id'] as String? ?? component['key'] as String? ?? 'table';
    final sortState =
        _tableSortStates.putIfAbsent(tableId, _TableSortState.new);

    final columns = columnData.indexed
        .map((entry) => _TableColumnConfig.fromJson(entry.$1, entry.$2))
        .toList(growable: false);
    if (columns.isEmpty) {
      return const SizedBox.shrink();
    }

    final rows = _buildTableRows(rowData, columns, context);
    if (sortState.columnIndex != null &&
        sortState.columnIndex! >= 0 &&
        sortState.columnIndex! < columns.length) {
      final column = columns[sortState.columnIndex!];
      rows.sort(
        (a, b) => _compareSortValues(
          a.cells[column.index].sortValue,
          b.cells[column.index].sortValue,
          sortState.ascending,
        ),
      );
    }

    final theme = Theme.of(context);
    final striped = component['striped'] as bool? ?? false;
    final dense =
        (component['density'] as String?)?.toLowerCase().trim() == 'compact';
    final columnSpacing =
        (component['columnSpacing'] as num?)?.toDouble() ?? (dense ? 20 : 32);
    final horizontalMargin =
        (component['horizontalMargin'] as num?)?.toDouble() ?? 24;
    final caption = component['caption'] as String?;
    final emptyText =
        component['emptyText'] as String? ?? component['emptyState'] as String?;

    final dataColumns = [
      for (final column in columns)
        DataColumn(
          label: column.buildHeader(context),
          numeric: column.numeric,
          tooltip: column.tooltip,
          onSort: column.sortable
              ? (columnIndex, ascending) {
                  setState(() {
                    sortState
                      ..columnIndex = columnIndex
                      ..ascending = ascending;
                  });
                }
              : null,
        ),
    ];

    final dataRows = [
      for (final entry in rows.indexed)
        DataRow.byIndex(
          index: entry.$1,
          color: striped
              ? MaterialStateProperty.resolveWith<Color?>(
                  (states) {
                    if (states.contains(MaterialState.selected)) {
                      return theme.colorScheme.primary.withValues(alpha: 0.12);
                    }
                    return entry.$1.isEven
                        ? theme.colorScheme.surfaceContainerHighest
                            .withValues(alpha: 0.35)
                        : null;
                  },
                )
              : null,
          cells: [
            for (final cell in entry.$2.cells) DataCell(cell.child),
          ],
        ),
    ];

    final dataTable = DataTable(
      columns: dataColumns,
      rows: dataRows,
      sortColumnIndex: sortState.columnIndex,
      sortAscending: sortState.ascending,
      columnSpacing: columnSpacing,
      horizontalMargin: horizontalMargin,
      showCheckboxColumn: false,
      dataRowMinHeight: dense ? 40 : null,
      dataRowMaxHeight: dense ? 64 : null,
    );

    final tableWidget = SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: dataTable,
    );

    final bodyChildren = <Widget>[
      tableWidget,
      if (rows.isEmpty && emptyText != null && emptyText.isNotEmpty)
        Padding(
          padding: _spacingSymmetric(context, horizontal: 16, vertical: 20),
          child: Text(
            emptyText,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.hintColor,
            ),
          ),
        ),
      if (caption != null && caption.isNotEmpty)
        Padding(
          padding: _spacingOnly(context, top: 12),
          child: Text(
            caption,
            style: theme.textTheme.bodySmall,
          ),
        ),
    ];

    final decorated = _decorateBox(
      context: context,
      component: component,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: bodyChildren,
      ),
    );

    Widget result = decorated.child;
    if (decorated.flex != null) {
      result = _FlexMaybe(flex: decorated.flex!, child: result);
    }
    return result;
  }

  Widget _buildTabs(Map<String, Object?> component, BuildContext context) {
    final tabs =
        (component['tabs'] as List?)?.cast<Map<String, Object?>>() ?? const [];
    if (tabs.isEmpty) {
      return const SizedBox.shrink();
    }
    return DefaultTabController(
      length: tabs.length,
      child: Column(
        children: [
          TabBar(
            tabs: [
              for (final tab in tabs)
                Tab(text: tab['label'] as String? ?? 'Tab'),
            ],
          ),
          SizedBox(
            height: 200,
            child: TabBarView(
              children: [
                for (final tab in tabs)
                  SingleChildScrollView(
                    padding: _spacingAll(context, 12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: _buildChildren(tab['children'], context),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildChart(Map<String, Object?> component, BuildContext context) {
    var data =
        (component['data'] as List?)?.map((row) => castMap(row)).toList() ??
            <Map<String, Object?>>[];
    var series =
        (component['series'] as List?)?.map((row) => castMap(row)).toList() ??
            <Map<String, Object?>>[];
    final datasets =
        (component['datasets'] as List?)?.map((row) => castMap(row)).toList() ??
            <Map<String, Object?>>[];

    if (series.isEmpty && datasets.isNotEmpty) {
      final categorySet = <String>{};
      for (final dataset in datasets) {
        final points =
            (dataset['data'] as List?)?.map((point) => castMap(point)) ??
                const Iterable<Map<String, Object?>>.empty();
        for (final point in points) {
          categorySet.add('${point['x']}');
        }
      }
      final categories = categorySet.toList();
      data = [
        for (final category in categories) {'x': category},
      ];

      series = [];
      for (final entry in datasets.indexed) {
        final dataset = entry.$2;
        final label = dataset['label'] as String? ??
            dataset['name'] as String? ??
            'Series ${entry.$1 + 1}';
        final key =
            dataset['dataKey'] as String? ?? dataset['key'] as String? ?? label;
        final type = (dataset['type'] as String? ?? 'bar').toLowerCase();
        series.add({
          'type': type,
          'dataKey': key,
          'label': label,
          'color': dataset['color'],
        });

        final points =
            (dataset['data'] as List?)?.map((point) => castMap(point)) ??
                const Iterable<Map<String, Object?>>.empty();
        for (final row in data) {
          final category = row['x'];
          final match = points.firstWhereOrNull(
            (point) => '${point['x']}' == '$category',
          );
          row[key] = match?['y'];
        }
      }

      if (!component.containsKey('xAxis')) {
        component = {
          ...component,
          'xAxis': 'x',
        };
      }
    }

    if (data.isEmpty || series.isEmpty) {
      return const Text('No chart data available.');
    }

    final xAxisConfig = component['xAxis'];
    String xKey = 'x';
    final Map<Object?, String> xLabels = {};
    bool showXAxis = true;
    if (xAxisConfig is String) {
      xKey = xAxisConfig;
    } else if (xAxisConfig is Map<String, Object?>) {
      xKey = (xAxisConfig['dataKey'] as String?) ?? xKey;
      showXAxis = !(xAxisConfig['hide'] as bool? ?? false);
      final labels = castMap(xAxisConfig['labels']);
      for (final entry in labels.entries) {
        xLabels[entry.key] = entry.value?.toString() ?? '';
      }
    }

    final categories = <String>[];
    final seen = <String>{};
    for (final row in data) {
      final raw = row[xKey];
      final label = (raw ?? '').toString();
      if (seen.add(label)) {
        categories.add(label);
      }
    }
    if (categories.isEmpty) {
      for (var i = 0; i < data.length; i++) {
        categories.add('Row ${i + 1}');
      }
    }

    final palette = ChatKitStyles.chartPalette(context);

    final showLegend = component['showLegend'] as bool? ?? true;
    final showTooltip = component['showTooltip'] as bool? ?? true;
    var showYAxisFlag = component['showYAxis'] as bool? ?? true;

    final seriesConfigs = <_SeriesConfig>[];
    var globalMax = 0.0;
    var globalMin = 0.0;
    for (final entry in series.indexed) {
      final config = entry.$2;
      final type = (config['type'] as String? ?? 'line').toLowerCase();
      final key = config['dataKey'] as String? ??
          config['key'] as String? ??
          config['label'] as String? ??
          'series_${entry.$1}';
      final label = config['label'] as String? ?? key;
      final color = _colorFromToken(context, config['color']) ??
          palette[entry.$1 % palette.length];
      final values = <double?>[];
      for (final row in data) {
        final value = row[key];
        values.add((value is num) ? value.toDouble() : null);
      }
      final iterable = values.whereType<double>().toList();
      final maxValue = iterable.isEmpty ? 0.0 : iterable.reduce(math.max);
      final minValue = iterable.isEmpty ? 0.0 : iterable.reduce(math.min);
      globalMax = math.max(globalMax, maxValue);
      globalMin = math.min(globalMin, minValue);

      seriesConfigs.add(
        _SeriesConfig(
          type: type,
          key: key,
          label: label,
          color: color,
          values: values,
          stackId: (config['stackId'] ?? config['stack']) as String?,
          curved: config['smooth'] == true ||
              ((config['curve'] as String?)?.toLowerCase().contains('smooth') ??
                  false) ||
              ((config['curve'] as String?)
                      ?.toLowerCase()
                      .contains('monotone') ??
                  false),
          fillOpacity: (config['fillOpacity'] as num?)?.toDouble(),
          strokeWidth: (config['strokeWidth'] as num?)?.toDouble(),
        ),
      );
    }

    final allBar = seriesConfigs.every((config) => config.type == 'bar');
    final chartHeight = (component['height'] as num?)?.toDouble() ?? 260;
    final showGrid = component['showGrid'] as bool? ?? true;

    final yAxisConfig = component['yAxis'];
    double? minYOverride;
    double? maxYOverride;
    showYAxisFlag = component['showYAxis'] as bool? ?? true;
    if (yAxisConfig is Map<String, Object?>) {
      showYAxisFlag = !(yAxisConfig['hide'] as bool? ?? false);
      minYOverride = (yAxisConfig['min'] as num?)?.toDouble();
      maxYOverride = (yAxisConfig['max'] as num?)?.toDouble();
    } else if (yAxisConfig is String) {
      showYAxisFlag = true;
    }
    if (minYOverride == null && globalMin < 0) {
      minYOverride = globalMin * 1.1;
    }
    if (maxYOverride == null) {
      maxYOverride = globalMax == 0 ? 10 : globalMax * 1.1;
    }

    Widget chart;
    if (allBar) {
      chart = _buildBarChart(
        context: context,
        categories: categories,
        configs: seriesConfigs,
        showYAxis: showYAxisFlag,
        showXAxis: showXAxis,
        showTooltip: showTooltip,
        xLabels: xLabels,
        minY: minYOverride,
        maxY: maxYOverride,
        showGrid: showGrid,
      );
    } else {
      chart = _buildLineChart(
        context: context,
        categories: categories,
        configs: seriesConfigs,
        showYAxis: showYAxisFlag,
        showXAxis: showXAxis,
        showTooltip: showTooltip,
        xLabels: xLabels,
        minY: minYOverride,
        maxY: maxYOverride,
        showGrid: showGrid,
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(height: chartHeight, child: chart),
        if (showLegend)
          Padding(
            padding: _spacingOnly(context, top: 12),
            child: Wrap(
              spacing: 12,
              runSpacing: 8,
              children: [
                for (final config in seriesConfigs)
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Container(
                        width: 12,
                        height: 12,
                        decoration: BoxDecoration(
                          color: config.color,
                          shape: BoxShape.circle,
                        ),
                      ),
                      const SizedBox(width: 6),
                      Text(config.label,
                          style: Theme.of(context).textTheme.bodySmall),
                    ],
                  ),
              ],
            ),
          ),
      ],
    );
  }

  Widget _buildLineChart({
    required BuildContext context,
    required List<String> categories,
    required List<_SeriesConfig> configs,
    required bool showYAxis,
    required bool showXAxis,
    required bool showTooltip,
    required Map<Object?, String> xLabels,
    double? minY,
    double? maxY,
    required bool showGrid,
  }) {
    final lineBars = <LineChartBarData>[];
    double computedMax = 0;
    double computedMin = 0;
    for (final config in configs) {
      if (config.type == 'bar') continue;
      final spots = <FlSpot>[];
      for (var i = 0; i < config.values.length; i++) {
        final value = config.values[i];
        if (value != null) {
          spots.add(FlSpot(i.toDouble(), value));
          computedMax = math.max(computedMax, value);
          computedMin = math.min(computedMin, value);
        }
      }
      if (spots.isEmpty) {
        continue;
      }
      lineBars.add(
        LineChartBarData(
          spots: spots,
          color: config.color,
          isCurved: config.curved,
          barWidth: config.strokeWidth ?? 3,
          preventCurveOverShooting: true,
          dotData: FlDotData(show: configs.length <= 2),
          belowBarData: BarAreaData(
            show: config.type == 'area' || (config.fillOpacity ?? 0) > 0,
            color: config.color.withValues(
              alpha: config.fillOpacity ?? (config.type == 'area' ? 0.25 : 0.0),
            ),
          ),
        ),
      );
    }

    final bottomTitles = SideTitles(
      showTitles: showXAxis,
      interval: 1,
      getTitlesWidget: (value, meta) {
        final index = value.toInt();
        if (index < 0 || index >= categories.length) {
          return const SizedBox.shrink();
        }
        final raw = categories[index];
        final label = xLabels[raw] ?? raw;
        return Padding(
          padding: _spacingOnly(context, top: 8),
          child: Text(
            label,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        );
      },
    );

    final leftTitles = SideTitles(
      showTitles: showYAxis,
      reservedSize: 40,
      getTitlesWidget: (value, meta) {
        return Text(
          value.toStringAsFixed(0),
          style: Theme.of(context).textTheme.bodySmall,
        );
      },
    );

    final effectiveMin = minY ?? (computedMin < 0 ? computedMin * 1.1 : 0);
    final effectiveMax = maxY ??
        ((computedMax == 0 && computedMin == 0)
            ? 10
            : (computedMax == 0 ? 10 : computedMax * 1.1));

    return LineChart(
      LineChartData(
        lineTouchData: LineTouchData(
          enabled: showTooltip,
          handleBuiltInTouches: true,
        ),
        titlesData: FlTitlesData(
          topTitles: const AxisTitles(),
          rightTitles: const AxisTitles(),
          bottomTitles: AxisTitles(sideTitles: bottomTitles),
          leftTitles: AxisTitles(sideTitles: leftTitles),
        ),
        gridData: FlGridData(show: showGrid, drawVerticalLine: false),
        lineBarsData: lineBars,
        minX: 0,
        maxX: (categories.length - 1).toDouble(),
        minY: effectiveMin,
        maxY: effectiveMax,
      ),
    );
  }

  Widget _buildBarChart({
    required BuildContext context,
    required List<String> categories,
    required List<_SeriesConfig> configs,
    required bool showYAxis,
    required bool showXAxis,
    required bool showTooltip,
    required Map<Object?, String> xLabels,
    double? minY,
    double? maxY,
    required bool showGrid,
  }) {
    final groups = <BarChartGroupData>[];
    double computedMax = 0;
    double computedMin = 0;
    for (var index = 0; index < categories.length; index++) {
      final rods = <BarChartRodData>[];
      final grouped = <String?, List<_SeriesConfig>>{};
      for (final config in configs) {
        grouped.putIfAbsent(config.stackId, () => []).add(config);
      }

      for (final entry in grouped.entries) {
        final stackId = entry.key;
        final members = entry.value;
        if (stackId == null || members.length == 1) {
          final config = members.first;
          final value = config.values[index]?.toDouble() ?? 0;
          computedMax = math.max(computedMax, value);
          computedMin = math.min(computedMin, value);
          rods.add(
            BarChartRodData(
              toY: value,
              width: config.strokeWidth ?? 16,
              borderRadius: _circularRadius(context, 6),
              color: config.color,
            ),
          );
          continue;
        }

        double cursor = 0;
        final stackItems = <BarChartRodStackItem>[];
        for (final member in members) {
          final value = member.values[index]?.toDouble() ?? 0;
          final start = cursor;
          final end = cursor + value;
          stackItems.add(BarChartRodStackItem(start, end, member.color));
          cursor = end;
          computedMax = math.max(computedMax, end);
        }
        rods.add(
          BarChartRodData(
            toY: cursor,
            width: members.first.strokeWidth ?? 16,
            borderRadius: _circularRadius(context, 4),
            rodStackItems: stackItems,
            color: members.last.color,
          ),
        );
      }

      groups.add(
        BarChartGroupData(
          x: index,
          barRods: rods,
          barsSpace: 8,
        ),
      );
    }

    final bottomTitles = SideTitles(
      showTitles: showXAxis,
      getTitlesWidget: (value, meta) {
        final index = value.toInt();
        if (index < 0 || index >= categories.length) {
          return const SizedBox.shrink();
        }
        final raw = categories[index];
        final label = xLabels[raw] ?? raw;
        return Padding(
          padding: _spacingOnly(context, top: 8),
          child: Text(
            label,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        );
      },
      interval: 1,
    );

    final leftTitles = SideTitles(
      showTitles: showYAxis,
      reservedSize: 40,
      getTitlesWidget: (value, meta) {
        return Text(
          value.toStringAsFixed(0),
          style: Theme.of(context).textTheme.bodySmall,
        );
      },
    );

    final effectiveMin = minY ?? (computedMin < 0 ? computedMin * 1.1 : 0);
    final effectiveMax = maxY ??
        ((computedMax == 0 && computedMin == 0)
            ? 10
            : (computedMax == 0 ? 10 : computedMax * 1.1));

    return BarChart(
      BarChartData(
        barTouchData: BarTouchData(enabled: showTooltip),
        titlesData: FlTitlesData(
          topTitles: const AxisTitles(),
          rightTitles: const AxisTitles(),
          bottomTitles: AxisTitles(sideTitles: bottomTitles),
          leftTitles: AxisTitles(sideTitles: leftTitles),
        ),
        barGroups: groups,
        gridData: FlGridData(show: showGrid, drawVerticalLine: false),
        minY: effectiveMin,
        maxY: effectiveMax,
      ),
    );
  }

  Widget? _buildListStatus(Object? status, BuildContext context) {
    final widget = _buildWidgetStatus(status, context);
    if (widget != null) {
      return widget;
    }
    if (status is String && status.isNotEmpty) {
      return Text(
        status,
        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
      );
    }
    return null;
  }

  EdgeInsets _cardPaddingForSize(
    String size, {
    required ChatKitSpacing spacing,
  }) {
    switch (size) {
      case 'sm':
        return EdgeInsets.all(spacing.sm);
      case 'lg':
        return EdgeInsets.all(spacing.xl);
      case 'full':
        return EdgeInsets.symmetric(
          horizontal: spacing.xl,
          vertical: spacing.xl + (spacing.sm - spacing.xxxs),
        );
      default:
        return EdgeInsets.all(spacing.md);
    }
  }

  Widget? _buildWidgetStatus(Object? status, BuildContext context) {
    if (status == null) return null;
    final chatTheme = _chatThemeOf(context);
    final spacing = chatTheme.spacing;
    if (status is String) {
      if (status.isEmpty) return null;
      return Container(
        padding: _spacingSymmetric(context, horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: Theme.of(context)
              .colorScheme
              .surfaceContainerHighest
              .withValues(alpha: 0.6),
          borderRadius: _circularRadius(context, 12),
        ),
        child: Text(
          status,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
        ),
      );
    }
    if (status is Map<String, Object?>) {
      final text = status['text'] as String? ?? '';
      if (text.isEmpty) return null;
      final iconName = status['icon'] as String?;
      final faviconUrl = status['favicon'] as String?;
      final frame = status['frame'] as bool? ?? false;
      final theme = Theme.of(context);
      final badgeColor =
          theme.colorScheme.surfaceContainerHighest.withValues(alpha: 0.85);
      final outline = theme.colorScheme.outlineVariant.withValues(alpha: 0.6);

      Widget? leading;
      if (faviconUrl != null && faviconUrl.isNotEmpty) {
        leading = Container(
          width: spacing.lg,
          height: spacing.lg,
          padding: frame ? _spacingAll(context, 2) : EdgeInsets.zero,
          decoration: frame
              ? BoxDecoration(
                  border: Border.all(color: outline),
                  borderRadius: _circularRadius(context, 6),
                )
              : null,
          child: ClipRRect(
            borderRadius: _circularRadius(context, 4),
            child: CachedNetworkImage(imageUrl: faviconUrl, fit: BoxFit.cover),
          ),
        );
      } else if (iconName != null && iconName.isNotEmpty) {
        final icon = _iconFromName(iconName);
        if (icon != null) {
          leading = Icon(
            icon,
            size: spacing.md + spacing.xxxs,
            color: theme.colorScheme.primary,
          );
        }
      }

      return Container(
        padding: EdgeInsets.symmetric(
          horizontal: spacing.sm + spacing.xxxs,
          vertical: spacing.sm - spacing.xxxs,
        ),
        decoration: BoxDecoration(
          color: badgeColor,
          borderRadius: _circularRadius(context, 14),
          border: Border.all(color: outline),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (leading != null) ...[
              leading,
              SizedBox(width: spacing.xs),
            ],
            Flexible(
              child: Text(
                text,
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      );
    }
    return null;
  }

  Widget _buildCardActionButton({
    required BuildContext context,
    required String label,
    required Map<String, Object?> action,
    required bool includeForm,
    required bool isPrimary,
    required String actionKey,
  }) {
    final hasAction = action.isNotEmpty;
    final isLoading = _cardActionPendingKey == actionKey;
    final onPressed = hasAction && !isLoading
        ? () => _handleCardAction(
              action,
              context,
              includeForm: includeForm,
              pendingKey: actionKey,
            )
        : null;

    final buttonChild = isLoading
        ? SizedBox(
            width: 18,
            height: 18,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              valueColor: AlwaysStoppedAnimation<Color>(
                isPrimary
                    ? Theme.of(context).colorScheme.onPrimary
                    : Theme.of(context).colorScheme.primary,
              ),
            ),
          )
        : Text(label);

    if (isPrimary) {
      return FilledButton(
        onPressed: onPressed,
        child: buttonChild,
      );
    }
    return OutlinedButton(
      onPressed: onPressed,
      child: buttonChild,
    );
  }

  Future<void> _handleCardAction(
    Map<String, Object?> action,
    BuildContext context, {
    required bool includeForm,
    required String pendingKey,
  }) async {
    setState(() => _cardActionPendingKey = pendingKey);
    try {
      await _dispatchAction(
        action,
        context,
        includeFormState: includeForm,
        preference: _ActionLoadingPreference.container,
      );
    } finally {
      if (mounted && _cardActionPendingKey == pendingKey) {
        setState(() => _cardActionPendingKey = null);
      }
    }
  }

  Alignment _alignmentFromTextAlign(TextAlign align) {
    switch (align) {
      case TextAlign.center:
        return Alignment.center;
      case TextAlign.right:
        return Alignment.centerRight;
      case TextAlign.justify:
      case TextAlign.start:
        return Alignment.centerLeft;
      case TextAlign.end:
        return Alignment.centerRight;
      case TextAlign.left:
        return Alignment.centerLeft;
    }
  }

  FocusNode _carouselFocusNodeFor(String key) {
    return _carouselFocusNodes.putIfAbsent(
      key,
      () => FocusNode(debugLabel: 'carousel:$key'),
    );
  }

  List<_CarouselSlide> _resolveCarouselSlides(
    Map<String, Object?> component,
    BuildContext context,
  ) {
    final items = (component['items'] as List?)
        ?.map((item) => castMap(item))
        .toList(growable: false);
    if (items != null && items.isNotEmpty) {
      return [
        for (final item in items)
          _CarouselSlide(
            identifier: item['key'] as String?,
            child: _buildCarouselSlideContent(item, context),
            title: item['title'] as String?,
            subtitle: item['subtitle'] as String?,
            description:
                item['description'] as String? ?? item['caption'] as String?,
            badge: item['badge'] as String?,
            tags: (item['tags'] as List?)
                    ?.whereType<String>()
                    .toList(growable: false) ??
                const [],
          ),
      ];
    }

    final children = _buildChildren(component['children'], context);
    return [
      for (final child in children) _CarouselSlide(child: child),
    ];
  }

  Widget _buildCarouselSlide({
    required BuildContext context,
    required _CarouselSlide slide,
    required int index,
    required int count,
  }) {
    Widget content = FocusTraversalGroup(
      child: Card(
        clipBehavior: Clip.antiAlias,
        elevation: 1,
        child: slide.child,
      ),
    );

    if (slide.hasMeta) {
      content = Stack(
        fit: StackFit.expand,
        children: [
          content,
          Positioned(
            left: 16,
            right: 16,
            bottom: 16,
            child: _buildCarouselMeta(slide, context),
          ),
        ],
      );
    }

    return Semantics(
      label: slide.title ?? 'Slide ${index + 1}',
      value: slide.subtitle ?? slide.description,
      hint: 'Slide ${index + 1} of $count',
      child: content,
    );
  }

  Widget _buildCarouselMeta(
    _CarouselSlide slide,
    BuildContext context,
  ) {
    if (!slide.hasMeta) {
      return const SizedBox.shrink();
    }
    final theme = Theme.of(context);
    final palette = _chatThemeOf(context).palette;
    final textTheme = theme.textTheme;
    final onOverlay = theme.colorScheme.onPrimary;
    final subtle = onOverlay.withValues(alpha: 0.7);

    final content = <Widget>[];
    if (slide.badge != null && slide.badge!.isNotEmpty) {
      content.add(
        Container(
          padding: _spacingSymmetric(context, horizontal: 10, vertical: 4),
          decoration: BoxDecoration(
            color: theme.colorScheme.primary.withValues(alpha: 0.14),
            borderRadius: _circularRadius(context, 999),
          ),
          child: Text(
            slide.badge!,
            style: textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onPrimaryContainer,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      );
      content.add(const SizedBox(height: 8));
    }

    if (slide.title != null && slide.title!.isNotEmpty) {
      content.add(
        Text(
          slide.title!,
          style: textTheme.titleMedium?.copyWith(
            color: onOverlay,
            fontWeight: FontWeight.w600,
          ),
        ),
      );
    }

    if (slide.subtitle != null && slide.subtitle!.isNotEmpty) {
      content.add(
        Padding(
          padding: _spacingOnly(context, top: 4),
          child: Text(
            slide.subtitle!,
            style: textTheme.bodyMedium?.copyWith(color: subtle),
          ),
        ),
      );
    }

    if (slide.description != null && slide.description!.isNotEmpty) {
      content.add(
        Padding(
          padding: _spacingOnly(context, top: 8),
          child: Text(
            slide.description!,
            style: textTheme.bodySmall?.copyWith(color: subtle),
          ),
        ),
      );
    }

    if (slide.tags.isNotEmpty) {
      content.add(
        Padding(
          padding: _spacingOnly(context, top: 12),
          child: Wrap(
            spacing: 8,
            runSpacing: 6,
            children: [
              for (final tag in slide.tags)
                Container(
                  padding:
                      _spacingSymmetric(context, horizontal: 10, vertical: 4),
                  decoration: BoxDecoration(
                    color: onOverlay.withValues(alpha: 0.12),
                    borderRadius: _circularRadius(context, 999),
                  ),
                  child: Text(
                    tag,
                    style: textTheme.labelSmall?.copyWith(
                      color: onOverlay,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
            ],
          ),
        ),
      );
    }

    return Container(
      padding: _spacingAll(context, 16),
      decoration: BoxDecoration(
        color: palette.overlayStrong.withValues(alpha: 0.75),
        borderRadius: _circularRadius(context, 16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: content,
      ),
    );
  }

  Widget _buildCarouselSlideContent(
    Map<String, Object?> item,
    BuildContext context,
  ) {
    final children = _buildChildren(item['children'], context);
    if (children.isNotEmpty) {
      if (children.length == 1) {
        return children.first;
      }
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: children,
      );
    }
    final child = item['child'];
    if (child is Map<String, Object?>) {
      return _buildComponent(child, context);
    }
    final imageUrl = item['image'] as String? ?? item['src'] as String?;
    if (imageUrl != null && imageUrl.isNotEmpty) {
      return CachedNetworkImage(imageUrl: imageUrl, fit: BoxFit.cover);
    }
    final text = item['text'] as String?;
    if (text != null && text.isNotEmpty) {
      return Center(
        child: Padding(
          padding: _spacingAll(context, 24),
          child: Text(
            text,
            textAlign: TextAlign.center,
            style: Theme.of(context).textTheme.titleMedium,
          ),
        ),
      );
    }
    return const SizedBox.shrink();
  }

  KeyEventResult _handleCarouselKey(
    KeyEvent event,
    PageController controller,
    int slideCount,
    bool loop,
  ) {
    if (slideCount <= 1 || !controller.hasClients) {
      return KeyEventResult.ignored;
    }
    if (event is! KeyDownEvent) {
      return KeyEventResult.ignored;
    }
    final current = controller.page?.round() ?? controller.initialPage;
    if (event.logicalKey == LogicalKeyboardKey.arrowRight) {
      final next = loop
          ? (current + 1) % slideCount
          : math.min(current + 1, slideCount - 1);
      if (!loop && next == current) return KeyEventResult.ignored;
      _animateCarousel(controller, next);
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.arrowLeft) {
      final previous = loop
          ? (current - 1 + slideCount) % slideCount
          : math.max(current - 1, 0);
      if (!loop && previous == current) return KeyEventResult.ignored;
      _animateCarousel(controller, previous);
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.home) {
      _animateCarousel(controller, 0);
      return KeyEventResult.handled;
    }
    if (event.logicalKey == LogicalKeyboardKey.end) {
      _animateCarousel(controller, slideCount - 1);
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  void _animateCarousel(PageController controller, int page) {
    if (!controller.hasClients) return;
    controller.animateToPage(
      page,
      duration: const Duration(milliseconds: 400),
      curve: Curves.easeOut,
    );
  }

  _TimelineAlignment _resolveTimelineAlignment(
    String? token,
    _TimelineAlignment fallback,
  ) {
    final normalized = token?.toLowerCase().trim();
    switch (normalized) {
      case 'start':
      case 'left':
        return _TimelineAlignment.start;
      case 'alternate':
      case 'center':
        return _TimelineAlignment.alternate;
      case 'end':
      case 'right':
        return _TimelineAlignment.end;
      default:
        return fallback;
    }
  }

  _TimelineLineStyle _resolveTimelineLineStyle(
    String? token,
    _TimelineLineStyle fallback,
  ) {
    final normalized = token?.toLowerCase().trim();
    switch (normalized) {
      case 'dashed':
      case 'dotted':
        return _TimelineLineStyle.dashed;
      default:
        return fallback;
    }
  }

  List<_TableRowModel> _buildTableRows(
    List<Object?> rows,
    List<_TableColumnConfig> columns,
    BuildContext context,
  ) {
    final results = <_TableRowModel>[];
    for (final row in rows) {
      final cells = <_TableCellData>[];
      for (final column in columns) {
        final value = _resolveTableCellValue(row, column);
        cells.add(
          _TableCellData(
            child: _buildTableCellWidget(value, column, context),
            sortValue: _extractTableSortValue(value),
          ),
        );
      }
      results.add(_TableRowModel(cells: cells));
    }
    return results;
  }

  Object? _resolveTableCellValue(Object? row, _TableColumnConfig column) {
    if (row is Map<String, Object?>) {
      final cells = row['cells'];
      if (cells is List && column.index < cells.length) {
        final value = cells[column.index];
        return value is Map<String, Object?> ? value : value;
      }
      final values = row['values'];
      if (values is Map<String, Object?> && column.dataKey != null) {
        final key = column.dataKey!;
        if (values.containsKey(key)) {
          return values[key];
        }
      }
      if (column.dataKey != null && row.containsKey(column.dataKey)) {
        return row[column.dataKey!];
      }
      if (row.containsKey(column.label)) {
        return row[column.label];
      }
      if (row.containsKey('value')) {
        return row['value'];
      }
      return null;
    }
    if (row is List) {
      if (column.index < row.length) {
        final value = row[column.index];
        return value is Map<String, Object?> ? value : value;
      }
      return null;
    }
    return row;
  }

  Object? _extractTableSortValue(Object? value) {
    if (value is Map<String, Object?>) {
      final map = value;
      if (map['sortValue'] != null) return map['sortValue'];
      if (map['value'] != null) return map['value'];
      if (map['text'] != null) return map['text'];
      if (map['label'] != null) return map['label'];
    }
    return value;
  }

  Widget _buildTableCellWidget(
    Object? value,
    _TableColumnConfig column,
    BuildContext context,
  ) {
    if (value is Map) {
      final map = castMap(value);
      if (map.containsKey('type')) {
        return _buildComponent(map, context);
      }
      final status = _buildWidgetStatus(map['status'], context);
      if (status != null) {
        return status;
      }
      final text = map['text'] as String? ??
          map['label'] as String? ??
          map['value']?.toString() ??
          '';
      final iconName = map['icon'] as String?;
      final icon = _iconFromName(iconName);
      final iconColor = _colorFromToken(context, map['iconColor']);
      final alignToken =
          (map['align'] as String? ?? map['textAlign'] as String?)
              ?.toLowerCase()
              .trim();
      final textAlign = switch (alignToken) {
        'center' => TextAlign.center,
        'end' || 'right' => TextAlign.right,
        'start' || 'left' => TextAlign.left,
        _ => column.textAlign ??
            (column.numeric ? TextAlign.right : TextAlign.left),
      };
      final alignment = _alignmentFromTextAlign(textAlign);
      Widget labelWidget = Text(
        text,
        textAlign: textAlign,
        style: Theme.of(context).textTheme.bodyMedium,
      );
      if (icon != null) {
        labelWidget = Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: textAlign == TextAlign.right
              ? MainAxisAlignment.end
              : MainAxisAlignment.start,
          children: [
            Icon(
              icon,
              size: 16,
              color: iconColor ?? Theme.of(context).iconTheme.color,
            ),
            const SizedBox(width: 6),
            Flexible(child: labelWidget),
          ],
        );
      }
      return Align(
        alignment: alignment,
        child: labelWidget,
      );
    }

    if (value is Widget) {
      return value;
    }

    final textAlign =
        column.textAlign ?? (column.numeric ? TextAlign.right : TextAlign.left);
    return Align(
      alignment: _alignmentFromTextAlign(textAlign),
      child: Text(
        value?.toString() ?? '',
        textAlign: textAlign,
        style: Theme.of(context).textTheme.bodyMedium,
      ),
    );
  }

  int _compareSortValues(Object? a, Object? b, bool ascending) {
    if (a == null && b == null) return 0;
    if (a == null) return 1;
    if (b == null) return -1;

    int result;
    if (a is num && b is num) {
      result = a.compareTo(b);
    } else if (a is DateTime && b is DateTime) {
      result = a.compareTo(b);
    } else if (a is bool && b is bool) {
      result = (a ? 1 : 0).compareTo(b ? 1 : 0);
    } else if (a is String && b is String) {
      result = a.toLowerCase().compareTo(b.toLowerCase());
    } else {
      final aString = a.toString().toLowerCase();
      final bString = b.toString().toLowerCase();
      result = aString.compareTo(bString);
    }

    return ascending ? result : -result;
  }

  Axis _resolveAxis(Map<String, Object?> component) {
    final type = (component['type'] as String? ?? '').toLowerCase();
    final direction = (component['direction'] as String?)?.toLowerCase().trim();
    if (type == 'row') {
      return Axis.horizontal;
    }
    if (type == 'column' || type == 'col') {
      return Axis.vertical;
    }
    if (direction == 'row' || direction == 'horizontal') {
      return Axis.horizontal;
    }
    if (direction == 'column' ||
        direction == 'col' ||
        direction == 'vertical') {
      return Axis.vertical;
    }
    return Axis.vertical;
  }

  CrossAxisAlignment _mapCrossAxisAlignment(String? align, Axis axis) {
    switch (align) {
      case 'center':
        return CrossAxisAlignment.center;
      case 'end':
        return CrossAxisAlignment.end;
      case 'stretch':
        return CrossAxisAlignment.stretch;
      case 'baseline':
        return axis == Axis.horizontal
            ? CrossAxisAlignment.baseline
            : CrossAxisAlignment.start;
      default:
        return CrossAxisAlignment.start;
    }
  }

  MainAxisAlignment _mapMainAxisAlignment(String? justify) {
    switch (justify) {
      case 'center':
        return MainAxisAlignment.center;
      case 'end':
        return MainAxisAlignment.end;
      case 'between':
        return MainAxisAlignment.spaceBetween;
      case 'around':
        return MainAxisAlignment.spaceAround;
      case 'evenly':
        return MainAxisAlignment.spaceEvenly;
      default:
        return MainAxisAlignment.start;
    }
  }

  WrapAlignment _mapWrapAlignment(String? value) {
    switch (value) {
      case 'center':
        return WrapAlignment.center;
      case 'end':
        return WrapAlignment.end;
      case 'between':
        return WrapAlignment.spaceBetween;
      case 'around':
        return WrapAlignment.spaceAround;
      case 'evenly':
        return WrapAlignment.spaceEvenly;
      default:
        return WrapAlignment.start;
    }
  }

  WrapCrossAlignment _mapWrapCrossAlignment(String? value) {
    switch (value) {
      case 'center':
        return WrapCrossAlignment.center;
      case 'end':
        return WrapCrossAlignment.end;
      default:
        return WrapCrossAlignment.start;
    }
  }

  List<Widget> _withGapBetween(
    List<Widget> children,
    double gap,
    Axis axis,
  ) {
    if (children.length <= 1 || gap <= 0) {
      return children;
    }
    final spaced = <Widget>[];
    for (var i = 0; i < children.length; i++) {
      if (i > 0) {
        spaced.add(
          axis == Axis.horizontal
              ? SizedBox(width: gap)
              : SizedBox(height: gap),
        );
      }
      spaced.add(children[i]);
    }
    return spaced;
  }

  EdgeInsets _spacingOnly(
    BuildContext context, {
    double left = 0,
    double top = 0,
    double right = 0,
    double bottom = 0,
  }) {
    return EdgeInsets.only(
      left: _resolveSpacingValue(context, left),
      top: _resolveSpacingValue(context, top),
      right: _resolveSpacingValue(context, right),
      bottom: _resolveSpacingValue(context, bottom),
    );
  }

  EdgeInsets _spacingSymmetric(
    BuildContext context, {
    double horizontal = 0,
    double vertical = 0,
  }) {
    return EdgeInsets.symmetric(
      horizontal: _resolveSpacingValue(context, horizontal),
      vertical: _resolveSpacingValue(context, vertical),
    );
  }

  EdgeInsets _spacingAll(BuildContext context, double value) {
    return EdgeInsets.all(_resolveSpacingValue(context, value));
  }

  EdgeInsets _spacingFromLTRB(
    BuildContext context,
    double left,
    double top,
    double right,
    double bottom,
  ) {
    return EdgeInsets.fromLTRB(
      _resolveSpacingValue(context, left),
      _resolveSpacingValue(context, top),
      _resolveSpacingValue(context, right),
      _resolveSpacingValue(context, bottom),
    );
  }

  double _resolveSpacingValue(BuildContext context, double value) {
    if (value == 0) return 0;
    final spacing = ChatKitTheme.of(context).spacing;
    final resolver = _spacingTokenResolvers[value.round()];
    if (resolver != null) {
      return resolver(spacing);
    }
    return value;
  }

  double _resolveRadiusValue(ChatKitThemeData theme, double value) {
    if (value == 0) return 0;
    final resolver = _radiusTokenResolvers[value.round()];
    if (resolver != null) {
      return resolver(theme.radii);
    }
    return value;
  }

  BorderRadius _circularRadius(BuildContext context, double value) {
    final theme = ChatKitTheme.of(context);
    return BorderRadius.circular(_resolveRadiusValue(theme, value));
  }

  static final Map<int, double Function(ChatKitSpacing)>
      _spacingTokenResolvers = <int, double Function(ChatKitSpacing)>{
    2: (s) => s.xxxs,
    4: (s) => s.xxs,
    6: (s) => s.xs - s.xxxs,
    8: (s) => s.xs,
    10: (s) => s.sm - s.xxxs,
    12: (s) => s.sm,
    14: (s) => s.sm + s.xxxs,
    16: (s) => s.md,
    18: (s) => s.md + s.xxxs,
    20: (s) => s.lg,
    24: (s) => s.xl,
    28: (s) => s.xl + (s.sm - s.xxxs),
    32: (s) => s.xxl,
    36: (s) => s.xxxl - s.sm,
    40: (s) => s.xxxl,
  };

  static final Map<int, double Function(ChatKitRadii)> _radiusTokenResolvers =
      <int, double Function(ChatKitRadii)>{
    4: (r) => r.sm,
    6: (r) => r.md,
    8: (r) => r.lg,
    10: (r) => r.button,
    12: (r) => r.card,
    14: (r) => r.card + (r.sm / 2),
    16: (r) => r.card + (r.md / 2),
    20: (r) => r.icon,
    999: (r) => r.full,
  };

  double? _spacingToDouble(Object? raw) {
    if (raw == null) return null;
    if (raw is num) {
      return raw.toDouble();
    }
    if (raw is String) {
      final normalized = raw.trim().toLowerCase();
      if (normalized.isEmpty ||
          normalized == 'auto' ||
          normalized == 'fit-content') {
        return null;
      }
      final scaleValue = _spacingScale[normalized];
      if (scaleValue != null) {
        return scaleValue;
      }
      if (normalized.endsWith('rem')) {
        final number = double.tryParse(
          normalized.substring(0, normalized.length - 3).trim(),
        );
        if (number != null) {
          return number * 16;
        }
      }
      if (normalized.endsWith('px')) {
        final number = double.tryParse(
          normalized.substring(0, normalized.length - 2).trim(),
        );
        if (number != null) {
          return number;
        }
      }
      final number = double.tryParse(normalized);
      if (number != null) {
        return number;
      }
      final match = RegExp(r'(-?\d+(\.\d+)?)').firstMatch(normalized);
      if (match != null) {
        return double.tryParse(match.group(1)!);
      }
    }
    return null;
  }

  double? _parseDimension(Object? raw) {
    if (raw == null) return null;
    if (raw is num) {
      return raw.toDouble();
    }
    if (raw is String) {
      final normalized = raw.trim().toLowerCase();
      if (normalized.isEmpty ||
          normalized == 'auto' ||
          normalized == 'fit-content') {
        return null;
      }
      if (normalized == 'full' || normalized == '100%') {
        return double.infinity;
      }
      if (normalized.endsWith('%')) {
        final number = double.tryParse(
          normalized.substring(0, normalized.length - 1).trim(),
        );
        if (number != null && number >= 100) {
          return double.infinity;
        }
        return null;
      }
      final scaleValue = _spacingScale[normalized];
      if (scaleValue != null) {
        return scaleValue;
      }
      if (normalized.endsWith('rem')) {
        final number = double.tryParse(
          normalized.substring(0, normalized.length - 3).trim(),
        );
        if (number != null) {
          return number * 16;
        }
      }
      if (normalized.endsWith('px')) {
        final number = double.tryParse(
          normalized.substring(0, normalized.length - 2).trim(),
        );
        if (number != null) {
          return number;
        }
      }
      final explicit = double.tryParse(normalized);
      if (explicit != null) {
        return explicit;
      }
      final match = RegExp(r'(-?\d+(\.\d+)?)').firstMatch(normalized);
      if (match != null) {
        return double.tryParse(match.group(1)!);
      }
      return null;
    }
    return _spacingToDouble(raw);
  }

  double? _parseAspectRatio(Object? raw) {
    if (raw == null) return null;
    if (raw is num) {
      return raw.toDouble();
    }
    if (raw is String) {
      final normalized = raw.trim();
      if (normalized.contains('/')) {
        final parts = normalized.split('/');
        if (parts.length == 2) {
          final left = double.tryParse(parts[0]);
          final right = double.tryParse(parts[1]);
          if (left != null && right != null && right != 0) {
            return left / right;
          }
        }
      }
      return double.tryParse(normalized);
    }
    return null;
  }

  BorderRadius? _borderRadiusFrom(Object? raw) {
    if (raw == null) return null;
    if (raw is num) {
      return BorderRadius.circular(raw.toDouble());
    }
    if (raw is String) {
      final normalized = raw.trim().toLowerCase();
      if (normalized == 'none') {
        return BorderRadius.zero;
      }
      if (normalized == 'full' || normalized == '100%') {
        return _circularRadius(context, 999);
      }
      final value = _spacingToDouble(raw);
      if (value != null) {
        return BorderRadius.circular(value);
      }
    }
    if (raw is Map<String, Object?>) {
      double? resolve(Object? value) => _spacingToDouble(value);
      final topLeft = resolve(raw['topLeft']) ?? resolve(raw['tl']);
      final topRight = resolve(raw['topRight']) ?? resolve(raw['tr']);
      final bottomLeft = resolve(raw['bottomLeft']) ?? resolve(raw['bl']);
      final bottomRight = resolve(raw['bottomRight']) ?? resolve(raw['br']);
      if (topLeft == null &&
          topRight == null &&
          bottomLeft == null &&
          bottomRight == null) {
        return null;
      }
      return BorderRadius.only(
        topLeft: Radius.circular(topLeft ?? 0),
        topRight: Radius.circular(topRight ?? 0),
        bottomLeft: Radius.circular(bottomLeft ?? 0),
        bottomRight: Radius.circular(bottomRight ?? 0),
      );
    }
    return null;
  }

  BoxBorder? _borderFrom(BuildContext context, Object? raw) {
    if (raw == null) return null;
    BorderSide? parseSide(Object? value) {
      if (value == null) return null;
      if (value is num || value is String) {
        final width = _spacingToDouble(value) ?? 1;
        final color = Theme.of(context).dividerColor;
        return BorderSide(width: width, color: color);
      }
      if (value is Map<String, Object?>) {
        final width = _spacingToDouble(value['size']) ?? 1;
        final color = _colorFromToken(context, value['color']) ??
            Theme.of(context).dividerColor;
        return BorderSide(width: width, color: color);
      }
      return null;
    }

    if (raw is num || raw is String) {
      final side = parseSide(raw) ?? BorderSide.none;
      return side == BorderSide.none
          ? null
          : Border.all(width: side.width, color: side.color);
    }

    if (raw is Map<String, Object?>) {
      if (raw.containsKey('size') || raw.containsKey('color')) {
        final side = parseSide(raw);
        if (side == null || side == BorderSide.none) {
          return null;
        }
        return Border.all(width: side.width, color: side.color);
      }

      final horizontal = parseSide(raw['x']);
      final vertical = parseSide(raw['y']);

      final top = parseSide(raw['top']) ?? vertical ?? BorderSide.none;
      final bottom = parseSide(raw['bottom']) ?? vertical ?? BorderSide.none;
      final left = parseSide(raw['left']) ?? horizontal ?? BorderSide.none;
      final right = parseSide(raw['right']) ?? horizontal ?? BorderSide.none;

      if (top == BorderSide.none &&
          bottom == BorderSide.none &&
          left == BorderSide.none &&
          right == BorderSide.none) {
        return null;
      }

      return Border(
        top: top,
        bottom: bottom,
        left: left,
        right: right,
      );
    }

    return null;
  }

  BoxConstraints? _boxConstraintsFrom(Map<String, Object?> component) {
    double? minWidth = _parseDimension(component['minWidth']);
    double? minHeight = _parseDimension(component['minHeight']);
    double? maxWidth = _parseDimension(component['maxWidth']);
    double? maxHeight = _parseDimension(component['maxHeight']);

    final minSize = _parseDimension(component['minSize']);
    final maxSize = _parseDimension(component['maxSize']);

    if (minSize != null) {
      minWidth ??= minSize;
      minHeight ??= minSize;
    }
    if (maxSize != null) {
      maxWidth ??= maxSize;
      maxHeight ??= maxSize;
    }

    if (minWidth == null &&
        minHeight == null &&
        maxWidth == null &&
        maxHeight == null) {
      return null;
    }

    return BoxConstraints(
      minWidth: minWidth ?? 0,
      minHeight: minHeight ?? 0,
      maxWidth: maxWidth ?? double.infinity,
      maxHeight: maxHeight ?? double.infinity,
    );
  }

  _DecoratedBoxResult _decorateBox({
    required BuildContext context,
    required Map<String, Object?> component,
    required Widget child,
    bool applyMargin = true,
  }) {
    final padding = _edgeInsets(component['padding'], context);
    final marginValue = _edgeInsets(component['margin'], context);
    final background = _colorFromToken(context, component['background']);
    final border = _borderFrom(context, component['border']);
    final borderRadius = _borderRadiusFrom(component['radius']);
    final width = _parseDimension(component['width'] ?? component['size']);
    final height = _parseDimension(component['height'] ?? component['size']);
    final constraints = _boxConstraintsFrom(component);
    final aspectRatio = _parseAspectRatio(component['aspectRatio']);
    final flex = _parseFlex(component['flex']);

    final decoration =
        (background != null || border != null || borderRadius != null)
            ? BoxDecoration(
                color: background,
                border: border,
                borderRadius: borderRadius,
              )
            : null;

    final needsContainer = padding != null ||
        decoration != null ||
        width != null ||
        height != null ||
        constraints != null ||
        (applyMargin && marginValue != null);

    Widget result = child;
    if (needsContainer) {
      result = Container(
        margin: applyMargin ? marginValue : null,
        padding: padding,
        decoration: decoration,
        width: width,
        height: height,
        constraints: constraints,
        clipBehavior: borderRadius != null ? Clip.antiAlias : Clip.none,
        child: result,
      );
    }

    if (aspectRatio != null) {
      result = AspectRatio(aspectRatio: aspectRatio, child: result);
    }

    return _DecoratedBoxResult(
      child: result,
      flex: flex,
      margin: applyMargin ? null : marginValue,
      borderRadius: borderRadius,
    );
  }

  int? _parseFlex(Object? raw) {
    if (raw == null) return null;
    if (raw is num) {
      final value = raw.toInt();
      return value > 0 ? value : null;
    }
    if (raw is String) {
      final normalized = raw.trim().toLowerCase();
      if (normalized.isEmpty || normalized == 'auto') {
        return null;
      }
      final number = int.tryParse(normalized);
      if (number != null) {
        return number > 0 ? number : null;
      }
      final match = RegExp(r'(\d+)').firstMatch(normalized);
      if (match != null) {
        final value = int.tryParse(match.group(1)!);
        if (value != null && value > 0) {
          return value;
        }
      }
    }
    return null;
  }

  List<Widget> _buildChildren(Object? children, BuildContext context) {
    if (children is List) {
      return [
        for (final child in children)
          if (child is Map<String, Object?>) _buildComponent(child, context),
      ];
    }
    return const [];
  }

  EdgeInsetsGeometry? _edgeInsets(Object? value, BuildContext context) {
    final uniform = _spacingToDouble(value);
    if (uniform != null) {
      return _spacingAll(context, uniform);
    }
    if (value is Map<String, Object?>) {
      final horizontal = _spacingToDouble(value['x']);
      final vertical = _spacingToDouble(value['y']);
      final top = _spacingToDouble(value['top']) ?? vertical ?? 0;
      final bottom = _spacingToDouble(value['bottom']) ?? vertical ?? 0;
      final left = _spacingToDouble(value['left']) ?? horizontal ?? 0;
      final right = _spacingToDouble(value['right']) ?? horizontal ?? 0;
      return _spacingFromLTRB(context, left, top, right, bottom);
    }
    return null;
  }

  Key _resolveComponentKey(Map<String, Object?> component) {
    final key = component['key'];
    if (key is String && key.isNotEmpty) {
      return ValueKey<String>('widget.key.$key');
    }
    final id = component['id'];
    if (id is String && id.isNotEmpty) {
      return ValueKey<String>('widget.id.$id');
    }
    return ValueKey<String>(jsonEncode(component));
  }

  void _setFieldValue(String name, Object? value) {
    if (name.isEmpty) return;
    _formState[name] = value;
  }

  Map<String, Object?> _buildFormPayload() {
    final result = <String, Object?>{};
    for (final entry in _formState.entries) {
      if (entry.key.isEmpty) continue;
      _applyFormValue(result, entry.key, entry.value);
    }
    return result;
  }

  void _applyFormValue(
    Map<String, Object?> target,
    String key,
    Object? value,
  ) {
    final path = _parseFormFieldPath(key);
    if (path.isEmpty) {
      target[key] = value;
      return;
    }
    _assignFormValue(target, path, 0, value);
  }

  void _assignFormValue(
    Object? container,
    List<_FormFieldPathSegment> path,
    int index,
    Object? value,
  ) {
    if (index >= path.length) {
      return;
    }
    final segment = path[index];
    final isLast = index == path.length - 1;
    final _FormFieldPathSegment? nextSegment = isLast ? null : path[index + 1];

    if (container is Map<String, Object?>) {
      if (!segment.isProperty) {
        return;
      }
      final key = segment.key!;
      if (isLast) {
        container[key] = value;
        return;
      }
      final wantsList = nextSegment?.isList ?? false;
      final existing = container[key];
      if (wantsList) {
        final list = existing is List<Object?> ? existing : <Object?>[];
        container[key] = list;
        _assignFormValue(list, path, index + 1, value);
      } else {
        final map =
            existing is Map<String, Object?> ? existing : <String, Object?>{};
        container[key] = map;
        _assignFormValue(map, path, index + 1, value);
      }
      return;
    }

    if (container is List<Object?>) {
      if (!segment.isList) {
        return;
      }

      if (segment.isAppend) {
        if (isLast) {
          container.add(value);
          return;
        }
        final wantsList = nextSegment?.isList ?? false;
        final newContainer = wantsList ? <Object?>[] : <String, Object?>{};
        container.add(newContainer);
        _assignFormValue(newContainer, path, index + 1, value);
        return;
      }

      final targetIndex = segment.index!;
      while (container.length <= targetIndex) {
        container.add(null);
      }
      if (isLast) {
        container[targetIndex] = value;
        return;
      }
      final wantsList = nextSegment?.isList ?? false;
      var nextContainer = container[targetIndex];
      if (wantsList) {
        if (nextContainer is! List<Object?>) {
          nextContainer = <Object?>[];
          container[targetIndex] = nextContainer;
        }
      } else {
        if (nextContainer is! Map<String, Object?>) {
          nextContainer = <String, Object?>{};
          container[targetIndex] = nextContainer;
        }
      }
      _assignFormValue(nextContainer, path, index + 1, value);
    }
  }

  List<_FormFieldPathSegment> _parseFormFieldPath(String key) {
    if (key.isEmpty) {
      return const <_FormFieldPathSegment>[];
    }
    final segments = <_FormFieldPathSegment>[];
    final buffer = StringBuffer();
    var index = 0;
    while (index < key.length) {
      final char = key[index];
      if (char == '.') {
        if (buffer.isNotEmpty) {
          segments.add(
            _FormFieldPathSegment.property(buffer.toString()),
          );
          buffer.clear();
        }
        index += 1;
        continue;
      }
      if (char == '[') {
        if (buffer.isNotEmpty) {
          segments.add(
            _FormFieldPathSegment.property(buffer.toString()),
          );
          buffer.clear();
        }
        final close = key.indexOf(']', index + 1);
        if (close == -1) {
          buffer.write(key.substring(index));
          break;
        }
        final inside = key.substring(index + 1, close);
        if (inside.isEmpty) {
          segments.add(const _FormFieldPathSegment.append());
        } else {
          final numeric = int.tryParse(inside);
          if (numeric != null) {
            segments.add(_FormFieldPathSegment.index(numeric));
          } else {
            segments.add(_FormFieldPathSegment.property(inside));
          }
        }
        index = close + 1;
        continue;
      }
      buffer.write(char);
      index += 1;
    }
    if (buffer.isNotEmpty) {
      segments.add(_FormFieldPathSegment.property(buffer.toString()));
    }
    return segments;
  }

  void _handleFieldInteraction(
    String name, {
    bool markTouched = false,
    bool validate = false,
  }) {
    if (name.isEmpty) return;
    if (markTouched) {
      _touchedFields.add(name);
    }
    if (!(validate || _touchedFields.contains(name))) {
      return;
    }
    final value = _formState[name];
    final error = _computeFieldError(name, value);
    final previousError = _fieldErrors[name];
    if (previousError == error || (previousError == null && error == null)) {
      return;
    }
    if (mounted) {
      setState(() {
        if (error != null && error.isNotEmpty) {
          _fieldErrors[name] = error;
        } else {
          _fieldErrors.remove(name);
        }
      });
    } else {
      if (error != null && error.isNotEmpty) {
        _fieldErrors[name] = error;
      } else {
        _fieldErrors.remove(name);
      }
    }
  }

  bool _validateFields(
    Iterable<String> fieldNames, {
    bool markTouched = false,
  }) {
    bool hasError = false;
    final nextErrors = <String, String>{};
    for (final name in fieldNames) {
      if (name.isEmpty) continue;
      if (markTouched) {
        _touchedFields.add(name);
      }
      final value = _formState[name];
      final error = _computeFieldError(name, value);
      if (error != null && error.isNotEmpty) {
        hasError = true;
        nextErrors[name] = error;
      }
    }

    if (mounted) {
      setState(() {
        for (final name in fieldNames) {
          if (nextErrors.containsKey(name)) {
            _fieldErrors[name] = nextErrors[name]!;
          } else {
            _fieldErrors.remove(name);
          }
        }
      });
    } else {
      for (final entry in nextErrors.entries) {
        _fieldErrors[entry.key] = entry.value;
      }
      for (final name in fieldNames) {
        if (!nextErrors.containsKey(name)) {
          _fieldErrors.remove(name);
        }
      }
    }

    return !hasError;
  }

  String? _computeFieldError(String name, Object? value) {
    final component = _formComponents[name];
    if (component == null) {
      return null;
    }
    final type = (component['type'] as String? ?? '').toLowerCase();
    final required = component['required'] as bool? ?? false;
    final errorText = component['errorText'] as String?;

    String requiredMessage(String fallback) =>
        errorText ?? component['requiredErrorText'] as String? ?? fallback;

    switch (type) {
      case 'checkbox':
      case 'toggle':
        final checked = value as bool? ?? false;
        if (required && !checked) {
          return requiredMessage('This option must be selected.');
        }
        return null;
    }

    if (_isValueEmpty(value)) {
      return required ? requiredMessage('This field is required.') : null;
    }

    switch (type) {
      case 'input':
      case 'text':
      case 'textarea':
        final stringValue = value?.toString() ?? '';
        final pattern = component['pattern'] as String?;
        if (pattern != null && pattern.isNotEmpty) {
          try {
            final regexp = RegExp(pattern);
            if (!regexp.hasMatch(stringValue)) {
              return component['patternErrorText'] as String? ??
                  'Value does not match the required pattern.';
            }
          } catch (_) {
            // ignore invalid regex.
          }
        }
        final minLength = (component['minLength'] as num?)?.toInt();
        if (minLength != null && stringValue.length < minLength) {
          return component['minLengthErrorText'] as String? ??
              'Must be at least $minLength characters.';
        }
        final maxLength = (component['maxLength'] as num?)?.toInt();
        if (maxLength != null && stringValue.length > maxLength) {
          return component['maxLengthErrorText'] as String? ??
              'Must be at most $maxLength characters.';
        }
        final inputType =
            (component['inputType'] as String? ?? '').toLowerCase();
        if (inputType == 'number' || inputType == 'numeric') {
          final number = num.tryParse(stringValue);
          if (number == null) {
            return 'Enter a valid number.';
          }
          final min = (component['min'] as num?)?.toDouble();
          if (min != null && number < min) {
            return component['minErrorText'] as String? ??
                'Must be at least ${min.toStringAsFixed(0)}.';
          }
          final max = (component['max'] as num?)?.toDouble();
          if (max != null && number > max) {
            return component['maxErrorText'] as String? ??
                'Must be less than or equal to ${max.toStringAsFixed(0)}.';
          }
        }
        return null;
      case 'select':
      case 'select.single':
      case 'select.native':
      case 'radio.group':
        if (value == null || (value is String && value.trim().isEmpty)) {
          return requiredMessage('Please make a selection.');
        }
        return null;
      case 'select.multi':
      case 'chips':
      case 'checkbox.group':
        final listValue =
            value is List ? value : (value is Iterable ? value.toList() : null);
        if (listValue == null || listValue.isEmpty) {
          return requiredMessage('Select at least one option.');
        }
        return null;
      case 'otp':
        final stringValue = value?.toString() ?? '';
        final length = (component['length'] as num?)?.toInt();
        if (length != null && stringValue.length != length) {
          return 'Enter the $length-digit code.';
        }
        return null;
      case 'date.picker':
        final mode = (component['mode'] as String? ?? 'date').toLowerCase();
        final minRaw = component['min'] as String?;
        final maxRaw = component['max'] as String?;
        if (mode == 'time') {
          final time = _tryParseTimeOfDay(value?.toString());
          if (time == null) {
            return 'Enter a valid time.';
          }
          final minTime = _tryParseTimeOfDay(minRaw);
          if (minTime != null && _compareTimeOfDay(time, minTime) < 0) {
            return 'Time must be after ${_formatTimeOfDay(minTime)}.';
          }
          final maxTime = _tryParseTimeOfDay(maxRaw);
          if (maxTime != null && _compareTimeOfDay(time, maxTime) > 0) {
            return 'Time must be before ${_formatTimeOfDay(maxTime)}.';
          }
          return null;
        } else {
          final date = DateTime.tryParse(value?.toString() ?? '');
          if (date == null) {
            return 'Enter a valid date.';
          }
          final minDate = DateTime.tryParse(minRaw ?? '');
          if (minDate != null && date.isBefore(minDate)) {
            return 'Date must be on or after '
                '${DateFormat.yMMMd().format(minDate)}.';
          }
          final maxDate = DateTime.tryParse(maxRaw ?? '');
          if (maxDate != null && date.isAfter(maxDate)) {
            return 'Date must be on or before '
                '${DateFormat.yMMMd().format(maxDate)}.';
          }
          return null;
        }
      case 'slider':
        final number = (value as num?)?.toDouble();
        final min = (component['min'] as num?)?.toDouble();
        final max = (component['max'] as num?)?.toDouble();
        if (number == null) {
          return requiredMessage('Select a value.');
        }
        if (min != null && number < min) {
          return component['minErrorText'] as String? ??
              'Value must be at least $min.';
        }
        if (max != null && number > max) {
          return component['maxErrorText'] as String? ??
              'Value must be at most $max.';
        }
        return null;
      case 'stepper':
      case 'number.stepper':
        final number = (value as num?)?.toInt();
        final min = (component['min'] as num?)?.toInt();
        final max = (component['max'] as num?)?.toInt();
        if (number == null) {
          return requiredMessage('Select a value.');
        }
        if (min != null && number < min) {
          return component['minErrorText'] as String? ??
              'Value must be at least $min.';
        }
        if (max != null && number > max) {
          return component['maxErrorText'] as String? ??
              'Value must be at most $max.';
        }
        return null;
      case 'signature':
        final hasBytes = value is List && value.isNotEmpty;
        if (required && !hasBytes) {
          return requiredMessage('Signature required.');
        }
        return null;
      default:
        return null;
    }
  }

  bool _isValueEmpty(Object? value) {
    if (value == null) return true;
    if (value is String) return value.trim().isEmpty;
    if (value is Iterable) return value.isEmpty;
    if (value is Map) return value.isEmpty;
    return false;
  }

  Set<String> _collectFieldNames(Object? node) {
    final result = <String>{};
    void walk(Object? value) {
      if (value is Map<String, Object?>) {
        final name = value['name'];
        if (name is String && name.isNotEmpty) {
          result.add(name);
        }
        for (final key in [
          'children',
          'items',
          'rows',
          'columns',
          'steps',
          'sections',
          'panels',
          'tabs',
          'content',
          'fields',
        ]) {
          final child = value[key];
          if (child != null) {
            walk(child);
          }
        }
      } else if (value is List) {
        for (final entry in value) {
          walk(entry);
        }
      }
    }

    walk(node);
    return result;
  }

  String? _formatDateDisplay(String? value, String mode) {
    if (value == null || value.isEmpty) {
      return null;
    }
    if (mode == 'time') {
      final time = _tryParseTimeOfDay(value);
      if (time == null) return value;
      return _formatTimeOfDay(time);
    }
    final date = DateTime.tryParse(value);
    if (date == null) {
      return value;
    }
    final local = date.toLocal();
    if (mode == 'datetime') {
      return DateFormat.yMMMd().add_jm().format(local);
    }
    return DateFormat.yMMMd().format(local);
  }

  TimeOfDay? _tryParseTimeOfDay(String? value) {
    if (value == null || value.isEmpty) {
      return null;
    }
    final iso = DateTime.tryParse(value);
    if (iso != null) {
      return TimeOfDay(hour: iso.hour, minute: iso.minute);
    }
    final match = RegExp(r'^(\d{1,2}):(\d{2})(?::(\d{2}))?$').firstMatch(value);
    if (match != null) {
      final hour = int.parse(match.group(1)!);
      final minute = int.parse(match.group(2)!);
      return TimeOfDay(hour: hour % 24, minute: minute % 60);
    }
    return null;
  }

  int _compareTimeOfDay(TimeOfDay a, TimeOfDay b) {
    final minutesA = a.hour * 60 + a.minute;
    final minutesB = b.hour * 60 + b.minute;
    return minutesA.compareTo(minutesB);
  }

  String _formatTimeOfDay(TimeOfDay time) {
    final dateTime = DateTime(
      1970,
      1,
      1,
      time.hour,
      time.minute,
    );
    return DateFormat.jm().format(dateTime);
  }

  Future<void> _submitForm(
    Map<String, Object?> action,
    BuildContext context, {
    required Iterable<String> fieldNames,
  }) async {
    final isValid = _validateFields(fieldNames, markTouched: true);
    if (!isValid) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Please fix the highlighted fields.'),
          ),
        );
      }
      return;
    }

    final formPayload = _buildFormPayload();
    await _dispatchAction(
      action,
      context,
      payloadOverride: {
        'form': formPayload,
        'formFlat': Map<String, Object?>.from(_formState),
      },
      preference: _ActionLoadingPreference.auto,
      actionSource: action,
    );
  }

  Future<void> _dispatchAction(
    Map<String, Object?> action,
    BuildContext context, {
    Map<String, Object?>? payloadOverride,
    bool includeFormState = false,
    _ActionLoadingPreference preference = _ActionLoadingPreference.auto,
    Map<String, Object?>? actionSource,
  }) async {
    final payload = <String, Object?>{
      ...castMap(action['payload']),
    };
    if (payloadOverride != null && payloadOverride.isNotEmpty) {
      payload.addAll(payloadOverride);
    }
    if (includeFormState) {
      Map<String, Object?>? cachedFormPayload;
      Map<String, Object?> ensureFormPayload() {
        return cachedFormPayload ??= _buildFormPayload();
      }

      payload.putIfAbsent('form', ensureFormPayload);
      payload.putIfAbsent(
        'formFlat',
        () => Map<String, Object?>.from(_formState),
      );
    }

    final includePayload =
        payload.isNotEmpty || action.containsKey('payload') || includeFormState;

    final normalizedAction = {
      ...action,
      if (includePayload) 'payload': payload,
    };
    final resolvedBehavior = _resolveActionLoadingBehavior(
      action['loadingBehavior'],
      preference,
    );
    final handler = (action['handler'] as String?)?.toLowerCase().trim();
    final isClientHandler = handler == 'client';
    final shouldSelf = resolvedBehavior == _ActionLoadingPreference.self &&
        actionSource != null;
    final shouldContainer =
        resolvedBehavior == _ActionLoadingPreference.container;

    final source = actionSource;

    if ((shouldSelf || shouldContainer) && mounted) {
      setState(() {
        if (shouldSelf && source != null) {
          _pendingSelfActions.add(source);
        }
        if (shouldContainer) {
          _containerLoadingDepth += 1;
        }
      });
    } else {
      if (shouldSelf && source != null) {
        _pendingSelfActions.add(source);
      }
      if (shouldContainer) {
        _containerLoadingDepth += 1;
      }
    }

    try {
      final widgetsOptions = widget.controller.options.widgets;
      final onWidgetAction = widgetsOptions?.onAction;
      if (onWidgetAction != null) {
        final widgetAction = WidgetAction(
          type: normalizedAction['type'] as String? ?? '',
          payload: castMap(normalizedAction['payload']),
        );
        await Future<void>.value(
          onWidgetAction(
            widgetAction,
            WidgetItemContext(id: widget.item.id, widget: widget.widgetJson),
          ),
        );
      }
      if (!isClientHandler) {
        await widget.controller.sendCustomAction(
          normalizedAction,
          itemId: widget.item.id,
        );
      } else if (widgetsOptions?.onAction == null) {
        debugPrint(
          'ChatKit: received client-handled action '
          '"${normalizedAction['type'] ?? ''}" but no widgets.onAction handler is registered.',
        );
      }
    } catch (error) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Action failed: $error')),
        );
      }
    } finally {
      if (shouldSelf || shouldContainer) {
        if (mounted) {
          setState(() {
            if (shouldSelf && source != null) {
              _pendingSelfActions.remove(source);
            }
            if (shouldContainer) {
              _containerLoadingDepth = math.max(0, _containerLoadingDepth - 1);
            }
          });
        } else {
          if (shouldSelf && source != null) {
            _pendingSelfActions.remove(source);
          }
          if (shouldContainer) {
            _containerLoadingDepth = math.max(0, _containerLoadingDepth - 1);
          }
        }
      }
    }
  }

  Color? _colorFromToken(BuildContext context, Object? token) {
    if (token == null) {
      return null;
    }
    if (token is Map<String, Object?>) {
      final brightness = Theme.of(context).brightness;
      final preferredKey = brightness == Brightness.dark ? 'dark' : 'light';
      final candidate =
          token[preferredKey] ?? token['default'] ?? token.values.firstOrNull;
      return _colorFromToken(context, candidate);
    }
    if (token is String) {
      final normalized = token.trim().toLowerCase();
      if (normalized.isEmpty) return null;
      if (normalized.startsWith('#')) {
        return _parseHexColor(normalized);
      }

      final theme = Theme.of(context);
      final palette = _chatThemeOf(context).palette;

      switch (normalized) {
        case 'primary':
          return theme.colorScheme.primary;
        case 'onprimary':
          return theme.colorScheme.onPrimary;
        case 'secondary':
          return theme.colorScheme.secondary;
        case 'onsecondary':
          return theme.colorScheme.onSecondary;
        case 'surface':
          return theme.colorScheme.surface;
        case 'onsurface':
          return theme.colorScheme.onSurface;
        case 'background':
          return theme.colorScheme.background;
        case 'onsurfacevariant':
        case 'muted':
          return palette.onSurfaceMuted;
        case 'success':
          return ChatKitStyles.statusColor(context, 'success');
        case 'danger':
        case 'error':
          return ChatKitStyles.statusColor(context, 'danger');
        case 'warning':
        case 'caution':
          return ChatKitStyles.statusColor(context, 'warning');
        case 'info':
          return ChatKitStyles.statusColor(context, 'info');
        case 'discovery':
          return theme.colorScheme.secondary;
      }

      final shadeMatch =
          RegExp(r'([a-z]+)[-_](\d{2,3})').firstMatch(normalized);
      if (shadeMatch != null) {
        final base = shadeMatch.group(1)!;
        final named = _namedColor(base);
        if (named != null) {
          return named;
        }
      }

      final named = _namedColor(normalized);
      if (named != null) {
        return named;
      }

      return _parseHexColor(normalized);
    }
    return null;
  }

  @visibleForTesting
  PageController? debugCarouselController(String carouselId) {
    return _pageControllers['carousel::$carouselId'];
  }

  @visibleForTesting
  void debugRequestFocusForCarousel(String carouselId) {
    _carouselFocusNodes['carousel::$carouselId']?.requestFocus();
  }

  Color? _parseHexColor(String value) {
    var hex = value.replaceFirst('#', '');
    if (hex.length == 6) {
      hex = 'ff$hex';
    }
    final intValue = int.tryParse(hex, radix: 16);
    if (intValue == null) {
      return null;
    }
    return Color(intValue);
  }

  Color? _namedColor(String name) {
    final hex = _namedColorHex[name];
    if (hex == null) {
      return null;
    }
    return Color(hex);
  }

  static const Map<String, int> _namedColorHex = {
    'red': 0xFFE5484D,
    'pink': 0xFFEA4AAA,
    'purple': 0xFF7A5AF8,
    'deep-purple': 0xFF6941C6,
    'deeppurple': 0xFF6941C6,
    'indigo': 0xFF444CE7,
    'blue': 0xFF1570EF,
    'light-blue': 0xFF2E90FA,
    'lightblue': 0xFF2E90FA,
    'cyan': 0xFF0BA5EC,
    'teal': 0xFF12A594,
    'green': 0xFF12B76A,
    'light-green': 0xFF32D583,
    'lightgreen': 0xFF32D583,
    'lime': 0xFFA6F4C5,
    'yellow': 0xFFFEC84B,
    'amber': 0xFFF79009,
    'orange': 0xFFF97066,
    'deep-orange': 0xFFEF6820,
    'deeporange': 0xFFEF6820,
    'brown': 0xFF9B8A7B,
    'blue-grey': 0xFF5F6C7B,
    'bluegray': 0xFF5F6C7B,
    'bluegrey': 0xFF5F6C7B,
    'grey': 0xFF98A2B3,
    'gray': 0xFF98A2B3,
    'black': 0xFF101828,
    'white': 0xFFFFFFFF,
  };

  IconData? _iconFromName(String? name) {
    if (name == null || name.isEmpty) return null;
    final icon = ChatKitIcons.forHeader(name) ?? ChatKitIcons.forWidget(name);
    if (icon != null) {
      return icon;
    }
    switch (name) {
      case 'bell':
        return Icons.notifications_outlined;
      case 'book-clock':
        return Icons.auto_stories_outlined;
      case 'check':
        return Icons.check;
      case 'check-circle':
        return Icons.check_circle_outline;
      case 'check-circle-filled':
        return Icons.check_circle;
      case 'copy':
        return Icons.copy;
      case 'delete':
        return Icons.delete_outline;
      case 'desktop':
        return Icons.desktop_windows;
      case 'document':
        return Icons.description_outlined;
      case 'dot':
        return Icons.circle;
      case 'external-link':
        return Icons.open_in_new;
      case 'globe':
        return Icons.public;
      case 'mail':
        return Icons.mail_outline;
      case 'maps':
        return Icons.map_outlined;
      case 'mobile':
        return Icons.smartphone;
      case 'phone':
        return Icons.phone_outlined;
      case 'share':
        return Icons.share_outlined;
      case 'play':
        return Icons.play_arrow;
      case 'plus':
        return Icons.add;
      case 'reload':
        return Icons.refresh;
      case 'settings-slider':
        return Icons.tune;
      case 'user':
        return Icons.person_outline;
    }
    return Icons.extension_outlined;
  }

  PageController _pageControllerFor(
    String key, {
    double viewportFraction = 1.0,
  }) {
    final existing = _pageControllers[key];
    if (existing != null &&
        (existing.viewportFraction - viewportFraction).abs() > 0.001) {
      existing.dispose();
      final controller = PageController(viewportFraction: viewportFraction);
      _pageControllers[key] = controller;
      return controller;
    }
    return _pageControllers.putIfAbsent(
      key,
      () => PageController(viewportFraction: viewportFraction),
    );
  }

  SignatureController _signatureControllerFor(
    BuildContext context,
    String name,
  ) {
    final existing = _signatureControllers[name];
    if (existing != null) {
      return existing;
    }
    final palette = _chatThemeOf(context).palette;
    final controller = SignatureController(
      penStrokeWidth: 2,
      penColor: palette.onSurface,
      exportBackgroundColor: palette.surface,
    );
    _signatureControllers[name] = controller;
    return controller;
  }

  Map<String, Object?> castMap(Object? value) {
    if (value is Map<String, Object?>) return value;
    if (value is Map) {
      return value
          .map((key, value) => MapEntry(key.toString(), value as Object?));
    }
    return {};
  }
}

class _FormFieldPathSegment {
  const _FormFieldPathSegment.property(this.key)
      : index = null,
        isAppend = false;

  const _FormFieldPathSegment.index(this.index)
      : key = null,
        isAppend = false;

  const _FormFieldPathSegment.append()
      : key = null,
        index = null,
        isAppend = true;

  final String? key;
  final int? index;
  final bool isAppend;

  bool get isProperty => key != null;
  bool get isList => index != null || isAppend;
}

enum _TimelineAlignment { start, end, alternate }

enum _TimelineLineStyle { solid, dashed }

class _SingleSelectResult {
  const _SingleSelectResult({this.value, this.cleared = false});

  final Object? value;
  final bool cleared;
}

class _MultiSelectResult {
  const _MultiSelectResult({required this.values, this.cleared = false});

  final Set<Object?> values;
  final bool cleared;
}

class _SelectOptionGroup {
  const _SelectOptionGroup({this.label, required this.options});

  final String? label;
  final List<_SelectOption> options;
}

class _SingleSelectSheet extends StatefulWidget {
  const _SingleSelectSheet({
    required this.initialQuery,
    required this.optionGroupsResolver,
    required this.selectedValue,
    required this.searchable,
    required this.loading,
    required this.clearable,
    required this.searchPlaceholder,
    required this.emptyText,
    required this.onQueryChanged,
    required this.spacingFromLTRB,
    required this.spacingAll,
    required this.iconResolver,
  });

  final String initialQuery;
  final List<_SelectOptionGroup> Function(String query) optionGroupsResolver;
  final Object? selectedValue;
  final bool searchable;
  final bool loading;
  final bool clearable;
  final String searchPlaceholder;
  final String emptyText;
  final ValueChanged<String> onQueryChanged;
  final EdgeInsets Function(
    BuildContext context,
    double left,
    double top,
    double right,
    double bottom,
  ) spacingFromLTRB;
  final EdgeInsets Function(BuildContext context, double value) spacingAll;
  final IconData? Function(String? name) iconResolver;

  @override
  State<_SingleSelectSheet> createState() => _SingleSelectSheetState();
}

class _SingleSelectSheetState extends State<_SingleSelectSheet> {
  late String _query;
  TextEditingController? _controller;

  @override
  void initState() {
    super.initState();
    _query = widget.initialQuery;
    if (widget.searchable) {
      _controller = TextEditingController(text: _query);
    }
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  void _handleQueryChanged(String value) {
    setState(() {
      _query = value;
    });
    widget.onQueryChanged(value);
  }

  @override
  Widget build(BuildContext context) {
    final filtered = widget.optionGroupsResolver(_query);
    return SafeArea(
      child: DraggableScrollableSheet(
        expand: false,
        initialChildSize: 0.7,
        minChildSize: 0.4,
        maxChildSize: 0.9,
        builder: (context, scrollController) {
          return Column(
            children: [
              if (widget.searchable)
                Padding(
                  padding: widget.spacingFromLTRB(context, 16, 8, 16, 8),
                  child: TextField(
                    controller: _controller,
                    autofocus: true,
                    decoration: InputDecoration(
                      prefixIcon: const Icon(Icons.search),
                      hintText: widget.searchPlaceholder,
                      border: const OutlineInputBorder(),
                    ),
                    onChanged: _handleQueryChanged,
                  ),
                ),
              if (widget.loading) const LinearProgressIndicator(),
              Expanded(
                child: filtered.isEmpty && !widget.loading
                    ? Center(
                        child: Padding(
                          padding: widget.spacingAll(context, 24),
                          child: Text(
                            widget.emptyText,
                            textAlign: TextAlign.center,
                          ),
                        ),
                      )
                    : ListView(
                        controller: scrollController,
                        children: [
                          if (widget.clearable && widget.selectedValue != null)
                            ListTile(
                              leading: const Icon(Icons.clear),
                              title: const Text('Clear selection'),
                              onTap: () => Navigator.pop(
                                context,
                                const _SingleSelectResult(
                                  value: null,
                                  cleared: true,
                                ),
                              ),
                            ),
                          for (final group in filtered) ...[
                            if (group.label != null && group.label!.isNotEmpty)
                              Padding(
                                padding: widget.spacingFromLTRB(
                                  context,
                                  16,
                                  12,
                                  16,
                                  4,
                                ),
                                child: Text(
                                  group.label!,
                                  style: Theme.of(context)
                                      .textTheme
                                      .titleSmall
                                      ?.copyWith(fontWeight: FontWeight.w600),
                                ),
                              ),
                            for (final option in group.options)
                              RadioListTile<Object?>(
                                value: option.value,
                                groupValue: widget.selectedValue,
                                title: Text(option.label),
                                subtitle: option.description != null
                                    ? Text(option.description!)
                                    : null,
                                secondary: option.icon != null
                                    ? Icon(widget.iconResolver(option.icon))
                                    : null,
                                onChanged: option.disabled || widget.loading
                                    ? null
                                    : (_) => Navigator.pop(
                                          context,
                                          _SingleSelectResult(
                                            value: option.value,
                                          ),
                                        ),
                              ),
                          ],
                        ],
                      ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class _MultiSelectSheet extends StatefulWidget {
  const _MultiSelectSheet({
    required this.initialQuery,
    required this.initialSelection,
    required this.optionGroupsResolver,
    required this.searchable,
    required this.loading,
    required this.clearable,
    required this.searchPlaceholder,
    required this.emptyText,
    required this.onQueryChanged,
    required this.spacingFromLTRB,
    required this.spacingAll,
    required this.iconResolver,
  });

  final String initialQuery;
  final Set<Object?> initialSelection;
  final List<_SelectOptionGroup> Function(String query) optionGroupsResolver;
  final bool searchable;
  final bool loading;
  final bool clearable;
  final String searchPlaceholder;
  final String emptyText;
  final ValueChanged<String> onQueryChanged;
  final EdgeInsets Function(
    BuildContext context,
    double left,
    double top,
    double right,
    double bottom,
  ) spacingFromLTRB;
  final EdgeInsets Function(BuildContext context, double value) spacingAll;
  final IconData? Function(String? name) iconResolver;

  @override
  State<_MultiSelectSheet> createState() => _MultiSelectSheetState();
}

class _MultiSelectSheetState extends State<_MultiSelectSheet> {
  late String _query;
  late Set<Object?> _localSelection;
  TextEditingController? _controller;

  @override
  void initState() {
    super.initState();
    _query = widget.initialQuery;
    _localSelection = Set<Object?>.from(widget.initialSelection);
    if (widget.searchable) {
      _controller = TextEditingController(text: _query);
    }
  }

  @override
  void dispose() {
    _controller?.dispose();
    super.dispose();
  }

  void _handleQueryChanged(String value) {
    setState(() {
      _query = value;
    });
    widget.onQueryChanged(value);
  }

  @override
  Widget build(BuildContext context) {
    final filtered = widget.optionGroupsResolver(_query);
    final listChildren = <Widget>[];
    for (final group in filtered) {
      if (group.label != null && group.label!.isNotEmpty) {
        listChildren.add(
          Padding(
            padding: widget.spacingFromLTRB(context, 16, 12, 16, 4),
            child: Text(
              group.label!,
              style: Theme.of(context)
                  .textTheme
                  .titleSmall
                  ?.copyWith(fontWeight: FontWeight.w600),
            ),
          ),
        );
      }
      for (final option in group.options) {
        final checked = _localSelection.contains(option.value);
        listChildren.add(
          CheckboxListTile(
            value: checked,
            title: Text(option.label),
            subtitle:
                option.description != null ? Text(option.description!) : null,
            secondary: option.icon != null
                ? Icon(widget.iconResolver(option.icon))
                : null,
            onChanged: option.disabled || widget.loading
                ? null
                : (value) {
                    final next = value ?? false;
                    setState(() {
                      if (next) {
                        _localSelection.add(option.value);
                      } else {
                        _localSelection.remove(option.value);
                      }
                    });
                  },
          ),
        );
      }
    }

    return SafeArea(
      child: DraggableScrollableSheet(
        expand: false,
        initialChildSize: 0.8,
        minChildSize: 0.4,
        maxChildSize: 0.95,
        builder: (context, scrollController) {
          return Column(
            children: [
              if (widget.searchable)
                Padding(
                  padding: widget.spacingFromLTRB(context, 16, 8, 16, 8),
                  child: TextField(
                    controller: _controller,
                    decoration: InputDecoration(
                      prefixIcon: const Icon(Icons.search),
                      hintText: widget.searchPlaceholder,
                      border: const OutlineInputBorder(),
                    ),
                    onChanged: _handleQueryChanged,
                  ),
                ),
              if (widget.loading) const LinearProgressIndicator(),
              Expanded(
                child: filtered.isEmpty && !widget.loading
                    ? Center(
                        child: Padding(
                          padding: widget.spacingAll(context, 24),
                          child: Text(
                            widget.emptyText,
                            textAlign: TextAlign.center,
                          ),
                        ),
                      )
                    : ListView(
                        controller: scrollController,
                        children: listChildren,
                      ),
              ),
              Padding(
                padding: widget.spacingFromLTRB(context, 16, 8, 16, 16),
                child: Row(
                  children: [
                    TextButton(
                      onPressed: () => Navigator.pop(context, null),
                      child: const Text('Cancel'),
                    ),
                    if (widget.clearable)
                      TextButton(
                        onPressed: () => Navigator.pop(
                          context,
                          const _MultiSelectResult(
                            values: <Object?>{},
                            cleared: true,
                          ),
                        ),
                        child: const Text('Clear'),
                      ),
                    const Spacer(),
                    FilledButton(
                      onPressed: () => Navigator.pop(
                        context,
                        _MultiSelectResult(
                          values: Set<Object?>.from(_localSelection),
                          cleared: _localSelection.isEmpty,
                        ),
                      ),
                      child: const Text('Apply'),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class _SelectOption {
  const _SelectOption({
    required this.value,
    required this.label,
    this.description,
    this.icon,
    this.disabled = false,
  });

  factory _SelectOption.fromMap(Map<String, Object?> map) {
    final value = map.containsKey('value') ? map['value'] : map['id'];
    final label = map['label'] as String? ?? value?.toString() ?? '';
    return _SelectOption(
      value: value,
      label: label,
      description: map['description'] as String? ?? map['subtitle'] as String?,
      icon: map['icon'] as String?,
      disabled: map['disabled'] as bool? ?? false,
    );
  }

  final Object? value;
  final String label;
  final String? description;
  final String? icon;
  final bool disabled;
}

class _TableSortState {
  _TableSortState({this.columnIndex, this.ascending = true});

  int? columnIndex;
  bool ascending;
}

class _TableColumnConfig {
  _TableColumnConfig({
    required this.index,
    required this.label,
    this.dataKey,
    this.sortable = false,
    this.numeric = false,
    this.textAlign,
    this.tooltip,
  });

  factory _TableColumnConfig.fromJson(
    int index,
    Map<String, Object?> json,
  ) {
    final label = json['label'] as String? ??
        json['title'] as String? ??
        'Column ${index + 1}';
    final dataKey = json['dataKey'] as String? ?? json['key'] as String?;
    final sortable = json['sortable'] as bool? ?? false;
    final alignToken =
        (json['align'] as String? ?? json['textAlign'] as String?)
            ?.toLowerCase()
            .trim();
    final numeric = (json['numeric'] as bool?) ??
        (alignToken == 'end' || alignToken == 'right');
    final textAlign = switch (alignToken) {
      'center' => TextAlign.center,
      'end' || 'right' => TextAlign.right,
      'start' || 'left' => TextAlign.left,
      _ => null,
    };
    final tooltip = json['tooltip'] as String?;
    return _TableColumnConfig(
      index: index,
      label: label,
      dataKey: dataKey,
      sortable: sortable,
      numeric: numeric,
      textAlign: textAlign,
      tooltip: tooltip,
    );
  }

  final int index;
  final String label;
  final String? dataKey;
  final bool sortable;
  final bool numeric;
  final TextAlign? textAlign;
  final String? tooltip;

  Widget buildHeader(BuildContext context) {
    final textAlignValue =
        textAlign ?? (numeric ? TextAlign.right : TextAlign.left);
    final alignment = textAlignValue == TextAlign.right
        ? Alignment.centerRight
        : (textAlignValue == TextAlign.center
            ? Alignment.center
            : Alignment.centerLeft);
    return Align(
      alignment: alignment,
      child: Text(
        label,
        style: Theme.of(context).textTheme.labelMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }
}

class _TableRowModel {
  const _TableRowModel({required this.cells});

  final List<_TableCellData> cells;
}

class _TableCellData {
  const _TableCellData({
    required this.child,
    this.sortValue,
  });

  final Widget child;
  final Object? sortValue;
}

class _CarouselSlide {
  const _CarouselSlide({
    required this.child,
    this.identifier,
    this.title,
    this.subtitle,
    this.description,
    this.badge,
    this.tags = const [],
  });

  final Widget child;
  final String? identifier;
  final String? title;
  final String? subtitle;
  final String? description;
  final String? badge;
  final List<String> tags;

  bool get hasMeta =>
      (title != null && title!.isNotEmpty) ||
      (subtitle != null && subtitle!.isNotEmpty) ||
      (description != null && description!.isNotEmpty) ||
      (badge != null && badge!.isNotEmpty) ||
      tags.isNotEmpty;
}

class _TimelineConnectorPainter extends CustomPainter {
  const _TimelineConnectorPainter({
    required this.color,
    required this.style,
  });

  final Color color;
  final _TimelineLineStyle style;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    final x = size.width / 2;
    if (style == _TimelineLineStyle.dashed) {
      const dashLength = 6.0;
      const gap = 4.0;
      double y = 0;
      while (y < size.height) {
        final endY = math.min(y + dashLength, size.height);
        canvas.drawLine(Offset(x, y), Offset(x, endY), paint);
        y += dashLength + gap;
      }
    } else {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), paint);
    }
  }

  @override
  bool shouldRepaint(_TimelineConnectorPainter oldDelegate) {
    return oldDelegate.color != color || oldDelegate.style != style;
  }
}

enum _ActionLoadingPreference { auto, none, self, container }

class _DecoratedBoxResult {
  const _DecoratedBoxResult({
    required this.child,
    this.flex,
    this.margin,
    this.borderRadius,
  });

  final Widget child;
  final int? flex;
  final EdgeInsetsGeometry? margin;
  final BorderRadius? borderRadius;
}

class _FlexMaybe extends StatelessWidget {
  const _FlexMaybe({
    required this.flex,
    required this.child,
  });

  final int flex;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    final hasFlexAncestor =
        context.findAncestorWidgetOfExactType<Flex>() != null;
    if (!hasFlexAncestor) {
      return child;
    }
    return Flexible(
      flex: flex,
      fit: FlexFit.tight,
      child: child,
    );
  }
}

class _SeriesConfig {
  const _SeriesConfig({
    required this.type,
    required this.key,
    required this.label,
    required this.color,
    required this.values,
    this.stackId,
    this.curved = false,
    this.fillOpacity,
    this.strokeWidth,
  });

  final String type;
  final String key;
  final String label;
  final Color color;
  final List<double?> values;
  final String? stackId;
  final bool curved;
  final double? fillOpacity;
  final double? strokeWidth;
}
</file>

<file path="packages/chatkit_core/lib/src/chatkit_controller.dart">
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io' show SocketException;
import 'dart:math' as math;

import 'package:meta/meta.dart';
import 'package:http/http.dart' as http;
import 'package:http_parser/http_parser.dart';
import 'package:collection/collection.dart';

import 'actions/client_tools.dart';
import 'api/api_client.dart';
import 'errors.dart';
import 'events/events.dart';
import 'models/attachments.dart';
import 'models/composer_state.dart';
import 'models/entities.dart';
import 'models/request.dart';
import 'models/response.dart';
import 'models/page.dart';
import 'models/thread.dart';
import 'options.dart';
import 'utils/json.dart';
import 'utils/thread_item_mutations.dart';

class ChatKitController {
  ChatKitController(
    ChatKitOptions options, {
    ChatKitApiClient? apiClient,
    http.Client? uploadClient,
  })  : _options = options,
        _apiClient = apiClient ?? ChatKitApiClient(apiConfig: options.api),
        _uploadClient = uploadClient ?? http.Client() {
    _apiClient.acceptLanguage = options.locale;
  }

  final ChatKitApiClient _apiClient;
  ChatKitOptions _options;
  final http.Client _uploadClient;
  final StreamController<ChatKitEvent> _eventController =
      StreamController<ChatKitEvent>.broadcast();

  String? _currentThreadId;
  Thread? _activeThread;
  final Map<String, ThreadItem> _items = {};
  final Queue<String> _pendingUserMessages = Queue<String>();
  final Queue<_QueuedStreamingRequest> _offlineQueue =
      Queue<_QueuedStreamingRequest>();
  Timer? _offlineRetryTimer;
  Duration _offlineBackoff = const Duration(seconds: 2);
  bool _isStreaming = false;
  bool _isAppActive = true;
  bool _isLoadingThread = false;
  final Map<String, _StreamingTextBuffer> _streamingTextBuffers = {};
  Timer? _streamingDeltaTimer;
  final math.Random _random = math.Random();
  ChatComposerState _composerState = const ChatComposerState();
  bool _composerAvailable = true;
  String? _composerUnavailableReason;
  Timer? _composerAvailabilityTimer;
  bool _handshakeInProgress = false;
  Timer? _resumeFetchTimer;
  DateTime? _lastForegroundFetch;

  Stream<ChatKitEvent> get events => _eventController.stream;

  ChatKitOptions get options => _options;

  set options(ChatKitOptions value) {
    _options = value;
    _apiClient.acceptLanguage = value.locale;
  }

  String? get currentThreadId => _currentThreadId;
  Thread? get activeThread => _activeThread;
  List<ThreadItem> get threadItems => _items.values.toList()
    ..sort((a, b) => a.createdAt.compareTo(b.createdAt));

  ThreadItem? threadItemById(String id) => _items[id];

  ChatComposerState get composerState => _composerState;

  void _emitLog(String name, [Map<String, Object?> data = const {}]) {
    final payload = data.isEmpty
        ? const <String, Object?>{}
        : Map<String, Object?>.unmodifiable(Map<String, Object?>.from(data));
    _eventController.add(
      ChatKitLogEvent(name: name, data: payload),
    );
    _options.onLog?.call(name, payload);
  }

  Future<Map<String, Object?>> _sendRequest(
    ChatKitRequest request, {
    Map<String, Object?> bodyOverrides = const {},
  }) async {
    final response = await _apiClient.send(
      request,
      bodyOverrides: bodyOverrides,
    );
    _restoreComposerIfNeeded();
    return response;
  }

  void _restoreComposerIfNeeded() {
    if (!_composerAvailable && _composerUnavailableReason == 'auth') {
      _setComposerAvailability(available: true);
    }
  }

  void _ensureIdle({bool allowThreadLoad = false}) {
    if (!_isAppActive) {
      throw ChatKitBusyException(
        'Cannot perform this action while the app is backgrounded.',
      );
    }
    if (_isStreaming) {
      throw ChatKitStreamingInProgressException(
        'Cannot perform this action while a response is streaming.',
      );
    }
    if (!allowThreadLoad && _isLoadingThread) {
      throw ChatKitBusyException(
        'Cannot perform this action while a thread is loading.',
      );
    }
  }

  Future<void> focusComposer() async {
    _eventController.add(const ChatKitComposerFocusEvent());
  }

  void handleAppBackgrounded() {
    if (!_isAppActive) {
      return;
    }
    _isAppActive = false;
    _resumeFetchTimer?.cancel();
    _resumeFetchTimer = null;
    if (_isStreaming) {
      _emitLog(
        'transport.cancelled',
        const {'reason': 'background'},
      );
      _isStreaming = false;
    }
    _apiClient.cancelActiveStream();
    _emitLog(
      'app.lifecycle',
      const {'state': 'background'},
    );
  }

  void handleAppForegrounded({bool forceRefresh = false}) {
    if (_isAppActive) {
      return;
    }
    _isAppActive = true;
    _emitLog(
      'app.lifecycle',
      const {'state': 'foreground'},
    );
    if (_currentThreadId == null) {
      return;
    }
    final now = DateTime.now();
    final since = _lastForegroundFetch;
    final cooldown = const Duration(seconds: 3);
    if (forceRefresh || since == null || now.difference(since) >= cooldown) {
      _lastForegroundFetch = now;
      unawaited(fetchUpdates());
      return;
    }

    final remaining = cooldown - now.difference(since);
    _resumeFetchTimer?.cancel();
    _resumeFetchTimer = Timer(remaining, () {
      if (!_isAppActive) {
        return;
      }
      _lastForegroundFetch = DateTime.now();
      unawaited(fetchUpdates());
    });
  }

  Future<void> setThreadId(String? threadId) async {
    _ensureIdle();
    if (threadId == null) {
      if (_currentThreadId == null && _activeThread == null) {
        return;
      }
      _currentThreadId = null;
      _activeThread = null;
      _items.clear();
      _pendingUserMessages.clear();
      _eventController.add(
        ChatKitThreadChangeEvent(threadId: null, thread: null),
      );
      return;
    }

    final isSameThread = threadId == _currentThreadId;
    _currentThreadId = threadId;
    if (!isSameThread) {
      _pendingUserMessages.clear();
    }
    await _loadThread(
      threadId: threadId,
      emitThreadChange: true,
    );
  }

  Future<void> sendUserMessage({
    required String text,
    Object? reply,
    List<Map<String, Object?>>? attachments,
    bool newThread = false,
    Map<String, Object?> metadata = const {},
    List<Entity>? tags,
  }) async {
    _ensureIdle();

    final attachmentModels = (attachments ?? const [])
        .map((json) => ChatKitAttachment.fromJson(json))
        .toList(growable: false);

    final effectiveTags = tags ?? _composerState.tags;
    String? replyText;
    if (reply is String) {
      replyText = _quotedTextForItem(reply) ?? _composerState.replyPreviewText;
    } else if (reply is Map<String, Object?>) {
      final replyId = reply['id'] as String?;
      replyText = (reply['text'] as String?) ??
          (replyId != null ? _quotedTextForItem(replyId) : null) ??
          _composerState.replyPreviewText;
    } else {
      replyText = _composerState.replyPreviewText;
    }

    final contents = <UserMessageContent>[];
    for (final tag in effectiveTags) {
      contents.add(
        UserMessageContent.tag(
          id: tag.id,
          text: tag.title,
          data: tag.data,
          interactive: tag.interactive ?? true,
        ),
      );
    }
    if (text.isNotEmpty || contents.isEmpty) {
      contents.add(UserMessageContent.text(text));
    }

    final userMessage = UserMessageInput(
      content: contents,
      attachmentIds: attachmentIdsFrom(attachmentModels),
      quotedText: replyText,
      inferenceOptions: _buildInferenceOptions(),
    );

    ThreadItem? pendingItem;
    if (!newThread && _currentThreadId != null) {
      final pendingId = 'pending-${DateTime.now().microsecondsSinceEpoch}';
      pendingItem = ThreadItem(
        id: pendingId,
        threadId: _currentThreadId!,
        createdAt: DateTime.now(),
        type: 'user_message',
        role: 'user',
        content: contents.map((entry) => entry.toJson()).toList(),
        attachments: attachmentModels,
        metadata: const {'pending': true},
        raw: {
          'id': pendingId,
          'type': 'user_message',
          'content': contents.map((entry) => entry.toJson()).toList(),
          'pending': true,
        },
      );
      _items[pendingId] = pendingItem;
      _pendingUserMessages.add(pendingId);
      _eventController.add(
        ChatKitThreadEvent(
          streamEvent: ThreadItemAddedEvent(item: pendingItem),
        ),
      );
    }

    final request = _currentThreadId == null || newThread
        ? threadsCreate(input: userMessage, metadata: metadata)
        : threadsAddUserMessage(
            threadId: _currentThreadId!,
            input: userMessage,
            metadata: metadata,
          );

    await setComposerValue(
      text: '',
      reply: null,
      attachments: const [],
      tags: const <Entity>[],
    );

    try {
      await _runStreamingRequest(
        request,
        pendingRequestId: pendingItem?.id,
      );
    } catch (error) {
      if (pendingItem != null) {
        _removePendingPlaceholder(pendingItem.id);
      }
      rethrow;
    }
  }

  Future<void> setComposerValue({
    String? text,
    Object? reply,
    List<Map<String, Object?>>? attachments,
    List<Entity>? tags,
    String? selectedModelId,
    String? selectedToolId,
  }) async {
    String? replyId;
    String? replyText;
    if (reply is String) {
      replyId = reply;
      replyText = _quotedTextForItem(reply);
    } else if (reply is Map<String, Object?>) {
      replyId = reply['id'] as String?;
      replyText = (reply['text'] as String?) ??
          (replyId != null ? _quotedTextForItem(replyId) : null);
    } else {
      replyId = null;
      replyText = null;
    }

    _composerState = _composerState.copyWith(
      text: text ?? _composerState.text,
      replyToItemId: replyId,
      replyPreviewText: replyText,
      attachments: attachments == null
          ? _composerState.attachments
          : attachments.map(ChatKitAttachment.fromJson).toList(growable: false),
      tags: tags ?? _composerState.tags,
      selectedModelId: selectedModelId ?? _composerState.selectedModelId,
      selectedToolId: selectedToolId ?? _composerState.selectedToolId,
    );
    _eventController.add(
      ChatKitComposerUpdatedEvent(state: _composerState),
    );
  }

  Future<void> fetchUpdates() async {
    final threadId = _currentThreadId;
    if (threadId == null) {
      return;
    }
    _ensureIdle();
    await _loadThread(
      threadId: threadId,
      emitThreadChange: true,
    );
  }

  Future<void> _loadThread({
    required String threadId,
    required bool emitThreadChange,
  }) async {
    if (_isLoadingThread) {
      throw ChatKitBusyException(
        'A thread load operation is already in progress.',
      );
    }
    _isLoadingThread = true;
    _eventController.add(
      ChatKitThreadLoadStartEvent(threadId: threadId),
    );

    try {
      final response = await _sendRequest(
        threadsGetById(threadId: threadId),
      );
      final thread = Thread.fromJson(response);
      _activeThread = thread;
      _items
        ..clear()
        ..addEntries(
          thread.items.map(
            (item) => MapEntry(item.id, item),
          ),
        );
      _pendingUserMessages.clear();
      if (emitThreadChange) {
        _eventController.add(
          ChatKitThreadChangeEvent(threadId: threadId, thread: thread),
        );
      }
    } finally {
      _isLoadingThread = false;
      _eventController.add(
        ChatKitThreadLoadEndEvent(threadId: threadId),
      );
    }
  }

  Future<Page<ThreadMetadata>> listThreads({
    int limit = 20,
    String? after,
    String order = 'desc',
    String? section,
    String? query,
    bool? pinnedOnly,
    Map<String, Object?> metadata = const {},
  }) async {
    try {
      final requestMetadata = <String, Object?>{
        if (section != null && section.isNotEmpty) 'section': section,
        if (query != null && query.trim().isNotEmpty) 'query': query.trim(),
        if (pinnedOnly != null) 'pinned_only': pinnedOnly,
        ...metadata,
      };
      final response = await _sendRequest(
        threadsList(
          limit: limit,
          after: after,
          order: order,
          metadata: requestMetadata,
        ),
      );
      return Page.fromJson(
        response,
        ThreadMetadata.fromJson,
      );
    } on ChatKitServerException catch (error) {
      _handleCommonServerError(error);
      rethrow;
    }
  }

  Future<void> deleteThread(String threadId) async {
    try {
      await _sendRequest(threadsDelete(threadId: threadId));
    } on ChatKitServerException catch (error) {
      _handleCommonServerError(error);
      rethrow;
    }
    if (_currentThreadId == threadId) {
      _currentThreadId = null;
      _activeThread = null;
      _items.clear();
      _eventController.add(
        ChatKitThreadChangeEvent(threadId: null, thread: null),
      );
    }
  }

  Future<void> renameThread(String threadId, String title) async {
    try {
      final response = await _sendRequest(
        threadsUpdate(threadId: threadId, updates: {'title': title}),
      );
      if (_currentThreadId == threadId) {
        final thread = Thread.fromJson(response);
        _activeThread = thread;
        _eventController.add(
          ChatKitThreadChangeEvent(threadId: threadId, thread: thread),
        );
      }
    } on ChatKitServerException catch (error) {
      _handleCommonServerError(error);
      rethrow;
    }
  }

  Future<void> submitFeedback({
    required String threadId,
    required List<String> itemIds,
    required String kind,
  }) async {
    try {
      await _sendRequest(
        itemsFeedback(threadId: threadId, itemIds: itemIds, kind: kind),
      );
    } on ChatKitServerException catch (error) {
      _handleCommonServerError(error);
      rethrow;
    }
  }

  Future<void> retryAfterItem({
    required String threadId,
    required String itemId,
  }) async {
    _ensureIdle();
    final request = threadsRetryAfterItem(threadId: threadId, itemId: itemId);
    await _runStreamingRequest(request);
  }

  Future<void> sendCustomAction(
    Map<String, Object?> action, {
    String? itemId,
  }) async {
    _ensureIdle();
    if (_currentThreadId == null) {
      throw ChatKitConfigurationException(
        'Cannot send a custom action without an active thread.',
      );
    }
    _emitLog(
      'action.send',
      {
        'action_type': action['type'],
        if (itemId != null) 'item_id': itemId,
      },
    );
    final request = threadsCustomAction(
      threadId: _currentThreadId!,
      itemId: itemId,
      action: ChatKitAction.fromJson(action),
    );
    await _runStreamingRequest(request);
  }

  Future<void> sendAction(
    Map<String, Object?> action, {
    String? itemId,
  }) {
    return sendCustomAction(action, itemId: itemId);
  }

  void shareItem(String itemId) {
    final item = _items[itemId];
    if (item == null) {
      return;
    }
    _eventController.add(
      ChatKitShareEvent(
        threadId: item.threadId,
        itemId: item.id,
        content: item.content,
      ),
    );
  }

  Future<ChatKitAttachment> registerAttachment({
    required String name,
    required List<int> bytes,
    required String mimeType,
    int? size,
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
  }) async {
    final resolvedSize = size ?? bytes.length;
    onProgress?.call(0, resolvedSize);

    // Enforce client-side limits to align with backend policy (image files <= 10MB).
    if (!mimeType.toLowerCase().startsWith('image/')) {
      throw ChatKitException(
        'Only image attachments are supported at this time.',
      );
    }
    const maxBytes = 10 * 1024 * 1024; // 10MB
    if (resolvedSize > maxBytes) {
      throw ChatKitException(
        'Images larger than 10MB cannot be uploaded. Please choose a smaller file.',
      );
    }

    _emitLog(
      'attachments.upload.start',
      {
        'name': name,
        'mime_type': mimeType,
        'size': resolvedSize,
      },
    );

    ChatKitAttachment? attachment;
    try {
      if (_options.api is CustomApiConfig) {
        final config = _options.api as CustomApiConfig;
        if (config.uploadStrategy is DirectUploadStrategy) {
          attachment = await _performDirectUpload(
            config: config,
            strategy: config.uploadStrategy as DirectUploadStrategy,
            name: name,
            mimeType: mimeType,
            bytes: bytes,
            resolvedSize: resolvedSize,
            onProgress: onProgress,
            isCancelled: isCancelled,
          );
        }
      }

      if (attachment == null) {
        Map<String, Object?> response;
        try {
          response = await _sendRequest(
            attachmentsCreate(
              name: name,
              size: resolvedSize,
              mimeType: mimeType,
            ),
          );
        } on ChatKitServerException catch (error) {
          _handleCommonServerError(error);
          rethrow;
        }

        attachment = ChatKitAttachment.fromJson(response);
        if (attachment.uploadUrl != null) {
          final updated = await _performTwoPhaseUpload(
            attachment: attachment,
            name: name,
            mimeType: mimeType,
            bytes: bytes,
            resolvedSize: resolvedSize,
            onProgress: onProgress,
            isCancelled: isCancelled,
          );
          if (updated != null &&
              updated.isNotEmpty &&
              updated.containsKey('id')) {
            attachment = ChatKitAttachment.fromJson(updated);
          }
        }
      }

      onProgress?.call(resolvedSize, resolvedSize);
      _emitLog(
        'attachments.upload.complete',
        {
          'attachment_id': attachment.id,
          'name': attachment.name,
          'mime_type': attachment.mimeType,
          'size': attachment.size ?? resolvedSize,
        },
      );
      return attachment;
    } catch (error) {
      _emitLog(
        'attachments.upload.error',
        {
          'name': name,
          'mime_type': mimeType,
          'size': resolvedSize,
          'error': error.toString(),
        },
      );
      rethrow;
    }
  }

  Future<ChatKitAttachment> _performDirectUpload({
    required CustomApiConfig config,
    required DirectUploadStrategy strategy,
    required String name,
    required String mimeType,
    required List<int> bytes,
    required int resolvedSize,
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
  }) async {
    final request = http.MultipartRequest(
      'POST',
      Uri.parse(strategy.uploadUrl),
    );
    request.headers['x-chatkit-sdk'] = 'chatkit-dart';
    if (config.domainKey != null) {
      request.headers['x-chatkit-domain-key'] = config.domainKey!;
    }
    if (config.headersBuilder != null) {
      final additional = await Future.value(config.headersBuilder!(request));
      if (additional.isNotEmpty) {
        request.headers.addAll(additional);
      }
    }
    final progressStream = _trackedByteStream(
      bytes,
      isCancelled: isCancelled,
      onProgress: onProgress,
    );
    request.files.add(
      http.MultipartFile(
        'file',
        progressStream,
        resolvedSize,
        filename: name,
        contentType: MediaType.parse(mimeType),
      ),
    );
    request.fields['name'] = name;
    request.fields['mime_type'] = mimeType;
    request.fields['size'] = resolvedSize.toString();

    final response = await _uploadClient.send(request);
    final body = await response.stream.bytesToString();
    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw ChatKitServerException(
        'Direct upload failed with status ${response.statusCode}',
        statusCode: response.statusCode,
        error: body.isEmpty ? null : castMap(jsonDecode(body)),
      );
    }

    final payload =
        body.isEmpty ? <String, Object?>{} : castMap(jsonDecode(body));
    if (payload.isEmpty) {
      throw ChatKitException(
        'Direct upload endpoint must return attachment metadata.',
      );
    }
    return ChatKitAttachment.fromJson(payload);
  }

  Future<Map<String, Object?>?> _performTwoPhaseUpload({
    required ChatKitAttachment attachment,
    required String name,
    required String mimeType,
    required List<int> bytes,
    required int resolvedSize,
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
  }) async {
    final uploadUrl = attachment.uploadUrl;
    if (uploadUrl == null || uploadUrl.isEmpty) {
      return null;
    }
    final method = (attachment.uploadMethod ?? 'PUT').toUpperCase();
    final headers = attachment.uploadHeaders;
    final fields = attachment.uploadFields;

    if (method == 'POST') {
      final request = http.MultipartRequest('POST', Uri.parse(uploadUrl));
      if (headers != null && headers.isNotEmpty) {
        request.headers.addAll(headers);
      }
      final mutableFields = fields != null
          ? Map<String, String>.from(fields)
          : <String, String>{};
      final fileField = mutableFields.remove('file_field') ?? 'file';
      request.fields.addAll(mutableFields);
      final progressStream = _trackedByteStream(
        bytes,
        onProgress: onProgress,
        isCancelled: isCancelled,
      );
      request.files.add(
        http.MultipartFile(
          fileField,
          progressStream,
          resolvedSize,
          filename: name,
          contentType: MediaType.parse(mimeType),
        ),
      );
      final response = await _uploadClient.send(request);
      final body = await response.stream.bytesToString();
      if (response.statusCode < 200 || response.statusCode >= 300) {
        throw ChatKitServerException(
          'Failed to upload attachment to storage',
          statusCode: response.statusCode,
          error: body.isEmpty ? null : {'body': body},
        );
      }
      if (body.isEmpty) {
        return null;
      }
      return castMap(jsonDecode(body));
    }

    return await _uploadToUrl(
      uploadUrl,
      bytes,
      mimeType,
      method: method,
      headers: headers,
      onProgress: onProgress,
      isCancelled: isCancelled,
    );
  }

  Future<void> dispose() async {
    _offlineRetryTimer?.cancel();
    _composerAvailabilityTimer?.cancel();
    _resumeFetchTimer?.cancel();
    _streamingDeltaTimer?.cancel();
    await _apiClient.close();
    await _eventController.close();
    _uploadClient.close();
  }

  Future<_StreamingOutcome> _runStreamingRequest(
    ChatKitRequest request, {
    bool isFollowUp = false,
    bool allowQueue = true,
    String? pendingRequestId,
  }) async {
    if (_isStreaming && !isFollowUp) {
      throw ChatKitStreamingInProgressException(
        'Streaming request already in flight.',
      );
    }

    if (!_isAppActive) {
      if (allowQueue) {
        _enqueueOfflineRequest(
          request,
          pendingRequestId: pendingRequestId,
          isFollowUp: isFollowUp,
        );
        return _StreamingOutcome.queued;
      }
      throw ChatKitBusyException(
        'Cannot perform this action while the app is backgrounded.',
      );
    }

    if (!isFollowUp) {
      _isStreaming = true;
    }

    final transport = _options.transport;
    final keepAliveTimeout =
        transport?.keepAliveTimeout ?? const Duration(seconds: 45);
    final initialBackoff =
        transport?.initialBackoff ?? const Duration(milliseconds: 500);
    final maxBackoff = transport?.maxBackoff ?? const Duration(seconds: 10);
    const maxAttempts = 5;
    var retryCount = 0;
    Duration? serverRetryHint;

    Object? capturedError;
    StackTrace? capturedStack;
    Object? finalError;
    final stopwatch = Stopwatch()..start();
    Duration? firstEventLatency;
    var streamedEventCount = 0;
    var completionStatus = 'unknown';
    final baseLog = <String, Object?>{
      'request_type': request.type,
      if (_currentThreadId != null) 'thread_id': _currentThreadId,
      if (pendingRequestId != null) 'pending_item_id': pendingRequestId,
      if (isFollowUp) 'follow_up': true,
    };
    _emitLog('transport.streaming.start', {
      ...baseLog,
      'allow_queue': allowQueue,
    });

    try {
      while (true) {
        final completer = Completer<void>();
        capturedError = null;
        capturedStack = null;
        final currentAttempt = retryCount + 1;

        try {
          await _apiClient.sendStreaming(
            request,
            onEvent: (event) async {
              if (firstEventLatency == null) {
                firstEventLatency = stopwatch.elapsed;
                _emitLog(
                  'transport.streaming.first_event',
                  {
                    ...baseLog,
                    'attempt': currentAttempt,
                    'latency_ms': firstEventLatency!.inMilliseconds,
                  },
                );
              }
              streamedEventCount += 1;
              await _handleStreamEvent(event);
            },
            onError: (error, stackTrace) {
              if (error is ChatKitServerException) {
                _handleCommonServerError(error);
              }
              final message = error.toString();
              _eventController.add(
                ChatKitErrorEvent(
                  error: message,
                  allowRetry: true,
                ),
              );
              capturedError = error;
              capturedStack = stackTrace;
              if (!completer.isCompleted) {
                completer.completeError(error, stackTrace);
              }
            },
            onDone: () {
              if (!completer.isCompleted) {
                completer.complete();
              }
            },
            keepAliveTimeout: keepAliveTimeout,
            onKeepAliveTimeout: () {
              _emitLog(
                'transport.keepalive.timeout',
                {
                  ...baseLog,
                },
              );
            },
            onRetrySuggested: (duration) {
              if (duration.inMilliseconds > 0) {
                serverRetryHint = duration;
              }
            },
          );
        } on Object catch (error, stackTrace) {
          capturedError = error;
          capturedStack = stackTrace;
          if (error is ChatKitServerException) {
            _handleCommonServerError(error);
          }
          if (!completer.isCompleted) {
            completer.completeError(error, stackTrace);
          }
        }

        try {
          await completer.future;
          capturedError = null;
          completionStatus = 'success';
          break;
        } catch (error, stackTrace) {
          capturedError = error;
          capturedStack = stackTrace;
        }

        if (!_shouldRetryStreamingError(capturedError) ||
            retryCount >= maxAttempts) {
          if (!isFollowUp) {
            _isStreaming = false;
          }
          if (capturedError != null) {
            if (allowQueue && _shouldRetryStreamingError(capturedError)) {
              completionStatus = 'queued';
              _enqueueOfflineRequest(
                request,
                pendingRequestId: pendingRequestId,
                isFollowUp: isFollowUp,
              );
              return _StreamingOutcome.queued;
            }
            finalError = capturedError;
            Error.throwWithStackTrace(
              capturedError as Object,
              capturedStack ?? StackTrace.current,
            );
          }
          completionStatus = 'success';
          break;
        }

        retryCount += 1;
        final hint = serverRetryHint;
        final delay = _computeBackoffDelay(
          retryCount: retryCount,
          initialBackoff: initialBackoff,
          maxBackoff: maxBackoff,
          serverHint: hint,
        );
        serverRetryHint = null;
        _emitLog(
          'transport.retry',
          {
            ...baseLog,
            'attempt': retryCount,
            'delay_ms': delay.inMilliseconds,
            if (hint != null) 'server_hint_ms': hint.inMilliseconds,
          },
        );
        await Future.delayed(delay);
      }

      if (!isFollowUp) {
        _isStreaming = false;
      }

      _restoreComposerIfNeeded();
      completionStatus = completionStatus == 'unknown' ? 'success' : completionStatus;
      return _StreamingOutcome.completed;
    } catch (error) {
      finalError = error;
      completionStatus = completionStatus == 'queued' ? completionStatus : 'error';
      rethrow;
    } finally {
      stopwatch.stop();
      final logData = <String, Object?>{
        ...baseLog,
        'status': completionStatus,
        'duration_ms': stopwatch.elapsedMilliseconds,
        'event_count': streamedEventCount,
        'retries': retryCount,
      };
      if (firstEventLatency != null) {
        logData['first_event_ms'] = firstEventLatency!.inMilliseconds;
      }
      if (finalError != null && completionStatus == 'error') {
        logData['error_type'] = finalError.runtimeType.toString();
      }
      _emitLog('transport.streaming.complete', logData);
    }
  }

  bool _shouldRetryStreamingError(Object? error) {
    if (error is TimeoutException) {
      return true;
    }
    if (error is SocketException) {
      return true;
    }
    if (error is ChatKitServerException) {
      final code = error.statusCode;
      if (code == null) {
        return false;
      }
      if (code == 429) {
        return true;
      }
      if (code >= 500 && code < 600) {
        return true;
      }
    }
    return false;
  }

  void _handleCommonServerError(ChatKitServerException error) {
    final status = error.statusCode;
    if (status == 401) {
      _eventController.add(const ChatKitAuthExpiredEvent());
      _setComposerAvailability(
        available: false,
        reason: 'auth',
        message: 'Authentication expired.',
      );
      return;
    }
    if (status == 429) {
      _handleRateLimit(error);
      return;
    }
    if (_isStaleClientError(error)) {
      _handleStaleClientError(error);
    }
  }

  String? _quotedTextForItem(String itemId) {
    final item = _items[itemId];
    if (item == null) {
      return null;
    }
    final buffer = StringBuffer();
    var first = true;
    for (final part in item.content) {
      final type = part['type'] as String?;
      if (type == 'output_text' || type == 'input_text') {
        final text = part['text'] as String?;
        if (text != null && text.isNotEmpty) {
          if (!first) {
            buffer.writeln();
          }
          buffer.write(text);
          first = false;
        }
      }
    }
    final result = buffer.toString().trim();
    return result.isEmpty ? null : result;
  }

  Duration _computeBackoffDelay({
    required int retryCount,
    required Duration initialBackoff,
    required Duration maxBackoff,
    Duration? serverHint,
  }) {
    final minMillis = math.max(initialBackoff.inMilliseconds, 50);
    final maxMillis = math.max(maxBackoff.inMilliseconds, minMillis);
    int baseMillis;
    if (serverHint != null && serverHint.inMilliseconds > 0) {
      baseMillis = serverHint.inMilliseconds;
    } else {
      final factor = retryCount <= 0 ? 1 : 1 << (retryCount - 1);
      baseMillis = initialBackoff.inMilliseconds * factor;
    }
    baseMillis = baseMillis.clamp(minMillis, maxMillis);
    final jitterRange = (baseMillis * 0.2).round();
    final jitter = jitterRange <= 0
        ? 0
        : _random.nextInt(jitterRange * 2 + 1) - jitterRange;
    final withJitter = (baseMillis + jitter).clamp(minMillis, maxMillis);
    return Duration(milliseconds: withJitter);
  }

  void _setComposerAvailability({
    required bool available,
    String? reason,
    String? message,
    Duration? retryAfter,
  }) {
    final previousAvailable = _composerAvailable;
    final previousReason = _composerUnavailableReason;
    if (available) {
      if (_composerAvailable && _composerUnavailableReason == null) {
        return;
      }
      _composerAvailable = true;
      _composerUnavailableReason = null;
      _composerAvailabilityTimer?.cancel();
      _composerAvailabilityTimer = null;
      _eventController.add(
        ChatKitComposerAvailabilityEvent(
          available: true,
          reason: previousReason,
        ),
      );
      if (!previousAvailable &&
          (previousReason == 'auth' || previousReason == 'stale_client')) {
        _options.hostedHooks?.onAuthRestored?.call();
      }
      return;
    }

    final normalizedReason = reason;
    if (!_composerAvailable &&
        _composerUnavailableReason == normalizedReason &&
        (message == null || message.isEmpty)) {
      return;
    }

    _composerAvailable = false;
    _composerUnavailableReason = normalizedReason;
    _composerAvailabilityTimer?.cancel();
    if (retryAfter != null && retryAfter > Duration.zero) {
      _composerAvailabilityTimer = Timer(retryAfter, () {
        _setComposerAvailability(
          available: true,
          reason: normalizedReason,
        );
      });
    }
    _eventController.add(
      ChatKitComposerAvailabilityEvent(
        available: false,
        reason: normalizedReason,
        message: message,
        retryAfter: retryAfter,
      ),
    );
    if (normalizedReason == 'auth') {
      _options.hostedHooks?.onAuthExpired?.call();
    }
  }

  void _handleRateLimit(ChatKitServerException error) {
    final wasRateLimited =
        !_composerAvailable && _composerUnavailableReason == 'rate_limit';
    final retryAfter = _parseRetryAfter(error.error);
    final message =
        _extractErrorMessage(error.error) ?? 'Rate limit reached. Try again.';
    _setComposerAvailability(
      available: false,
      reason: 'rate_limit',
      message: message,
      retryAfter: retryAfter,
    );
    if (!wasRateLimited) {
      _eventController.add(
        ChatKitNoticeEvent(
          message: message,
          title: 'Rate limit reached',
          level: ChatKitNoticeLevel.warning,
          code: 'rate_limit',
          retryAfter: retryAfter,
        ),
      );
    }
  }

  Duration? _parseRetryAfter(Map<String, Object?>? error) {
    if (error == null) {
      return null;
    }
    final retryAfterMs = error['retry_after_ms'] ??
        (error['metadata'] is Map
            ? (error['metadata'] as Map)['retry_after_ms']
            : null);
    final retryAfterSeconds = error['retry_after'] ??
        (error['metadata'] is Map
            ? (error['metadata'] as Map)['retry_after']
            : null);
    final nestedError = error['error'];

    Duration? fromValue(Object? value, {required bool milliseconds}) {
      if (value == null) return null;
      num? numeric;
      if (value is num) {
        numeric = value;
      } else if (value is String) {
        numeric = num.tryParse(value);
      }
      if (numeric == null || numeric <= 0) {
        return null;
      }
      if (milliseconds) {
        return Duration(milliseconds: numeric.round());
      }
      return Duration(milliseconds: (numeric * 1000).round());
    }

    final fromMs = fromValue(retryAfterMs, milliseconds: true);
    if (fromMs != null) {
      return fromMs;
    }
    final fromSeconds = fromValue(retryAfterSeconds, milliseconds: false);
    if (fromSeconds != null) {
      return fromSeconds;
    }

    if (nestedError is Map<String, Object?>) {
      return _parseRetryAfter(nestedError);
    }
    return null;
  }

  String? _extractErrorMessage(Map<String, Object?>? error) {
    if (error == null) {
      return null;
    }
    final messageCandidates = <Object?>[
      error['message'],
      error['detail'],
      error['error'],
    ];
    for (final candidate in messageCandidates) {
      if (candidate is String && candidate.trim().isNotEmpty) {
        return candidate.trim();
      }
      if (candidate is Map<String, Object?>) {
        final nested = _extractErrorMessage(candidate);
        if (nested != null) {
          return nested;
        }
      }
    }
    return null;
  }

  ChatKitNoticeLevel _noticeLevelFromString(String raw) {
    final normalized = raw.toLowerCase();
    switch (normalized) {
      case 'warning':
        return ChatKitNoticeLevel.warning;
      case 'error':
      case 'danger':
        return ChatKitNoticeLevel.error;
      default:
        return ChatKitNoticeLevel.info;
    }
  }

  bool _isStaleClientError(ChatKitServerException error) {
    if (error.statusCode == 409) {
      return true;
    }
    final code = _extractErrorCode(error.error)?.toLowerCase();
    if (code != null &&
        (code.contains('stale_client') || code.contains('client_stale'))) {
      return true;
    }
    final message = _extractErrorMessage(error.error)?.toLowerCase();
    if (message != null &&
        (message.contains('stale client') ||
            message.contains('client stale'))) {
      return true;
    }
    return false;
  }

  void _handleStaleClientError(ChatKitServerException error) {
    final retryAfter = _parseRetryAfter(error.error);
    final message = _extractErrorMessage(error.error) ??
        'This conversation is out of date. Refreshing…';
    _setComposerAvailability(
      available: false,
      reason: 'stale_client',
      message: message,
      retryAfter: retryAfter,
    );
    _eventController.add(
      ChatKitNoticeEvent(
        message: message,
        title: 'Conversation updated',
        level: ChatKitNoticeLevel.warning,
        code: _extractErrorCode(error.error) ?? 'stale_client',
        retryAfter: retryAfter,
      ),
    );
    _performHandshake();
  }

  Future<void> _performHandshake() async {
    if (_handshakeInProgress) {
      return;
    }
    _handshakeInProgress = true;
    _emitLog(
      'transport.handshake.start',
      const {'status': 'pending'},
    );
    try {
      final callback = _options.hostedHooks?.onStaleClient;
      if (callback != null) {
        await Future.sync(callback);
      }
      if (_currentThreadId != null) {
        await fetchUpdates();
      }
      _setComposerAvailability(available: true, reason: 'stale_client');
      _emitLog(
        'transport.handshake.complete',
        const {'status': 'ok'},
      );
    } catch (error, stackTrace) {
      _eventController.add(
        ChatKitErrorEvent(
          error: 'Failed to refresh client state: $error',
          allowRetry: true,
        ),
      );
      Zone.current.handleUncaughtError(error, stackTrace);
    } finally {
      _handshakeInProgress = false;
    }
  }

  String? _extractErrorCode(Map<String, Object?>? error) {
    if (error == null) {
      return null;
    }
    final candidates = <Object?>[
      error['code'],
      (error['error'] is Map<String, Object?>)
          ? (error['error'] as Map<String, Object?>)['code']
          : null,
    ];
    for (final candidate in candidates) {
      if (candidate is String && candidate.isNotEmpty) {
        return candidate;
      }
    }
    return null;
  }

  @visibleForTesting
  void debugHandleStreamEvent(ThreadStreamEvent event) {
    _handleStreamEvent(event);
  }

  Future<void> _handleStreamEvent(ThreadStreamEvent event) async {
    if (event is ThreadCreatedEvent) {
      _handleThreadCreated(event.thread);
      return;
    }
    if (event is ThreadUpdatedEvent) {
      _handleThreadUpdated(event.thread);
      return;
    }
    if (event is ThreadItemAddedEvent) {
      _handleItemAdded(event.item);
      return;
    }
    if (event is ThreadItemDoneEvent) {
      await _handleItemDone(event.item);
      return;
    }
    if (event is ThreadItemUpdatedEvent) {
      _handleItemUpdated(event.itemId, event.update);
      return;
    }
    if (event is ThreadItemRemovedEvent) {
      _items.remove(event.itemId);
      _eventController.add(ChatKitThreadEvent(streamEvent: event));
      return;
    }
    if (event is ThreadItemReplacedEvent) {
      _items[event.item.id] = event.item;
      _eventController.add(ChatKitThreadEvent(streamEvent: event));
      return;
    }
    if (event is ErrorEvent) {
      _eventController.add(
        ChatKitErrorEvent(
          error: event.message,
          code: event.code,
          allowRetry: event.allowRetry,
        ),
      );
      return;
    }
    if (event is NoticeEvent) {
      _handleNoticeEvent(event);
      return;
    }

    _eventController.add(ChatKitThreadEvent(streamEvent: event));
  }

  void _handleNoticeEvent(NoticeEvent event) {
    if (_isStaleClientNotice(event)) {
      _handleStaleClientNotice(event);
      return;
    }
    final level = _noticeLevelFromString(event.level);
    final retryAfter = _parseRetryAfter(event.data);
    _eventController.add(
      ChatKitNoticeEvent(
        message: event.message,
        title: event.title,
        level: level,
        code: event.code,
        retryAfter: retryAfter,
      ),
    );
    _emitLog(
      'notice',
      {
        'level': event.level,
        'message': event.message,
        if (event.title != null) 'title': event.title,
        if (event.code != null) 'code': event.code,
      },
    );
  }

  bool _isStaleClientNotice(NoticeEvent event) {
    final code = event.code?.toLowerCase();
    if (code == 'stale_client' || code == 'client_stale') {
      return true;
    }
    final normalized = event.message.trim().toLowerCase();
    return normalized.contains('stale client') ||
        normalized.contains('client stale');
  }

  void _handleStaleClientNotice(NoticeEvent event) {
    final retryAfter = _parseRetryAfter(event.data);
    final message = event.message.isNotEmpty
        ? event.message
        : 'This conversation changed in another session. Refreshing…';
    _setComposerAvailability(
      available: false,
      reason: 'stale_client',
      message: message,
      retryAfter: retryAfter,
    );
    _eventController.add(
      ChatKitNoticeEvent(
        message: message,
        title: event.title ?? 'Conversation updated',
        level: ChatKitNoticeLevel.warning,
        code: event.code ?? 'stale_client',
        retryAfter: retryAfter,
      ),
    );
    _performHandshake();
  }

  void _handleThreadCreated(Thread thread) {
    _currentThreadId = thread.metadata.id;
    _activeThread = thread;
    _items
      ..clear()
      ..addEntries(
        thread.items.map(
          (item) => MapEntry(item.id, item),
        ),
      );

    _eventController.add(
      ChatKitThreadChangeEvent(threadId: _currentThreadId, thread: thread),
    );
  }

  void _handleThreadUpdated(Thread thread) {
    _activeThread = thread;
    for (final item in thread.items) {
      _items[item.id] = item;
    }
    _eventController.add(
        ChatKitThreadEvent(streamEvent: ThreadUpdatedEvent(thread: thread)));
  }

  void _handleItemAdded(ThreadItem item) {
    if (_shouldResolvePendingFor(item)) {
      _resolvePendingUserMessage(item);
    }

    _items[item.id] = item;
    _eventController
        .add(ChatKitThreadEvent(streamEvent: ThreadItemAddedEvent(item: item)));

    if (item.type == 'assistant_message') {
      _eventController.add(
        ChatKitResponseStartEvent(
          threadId: item.threadId,
          item: item,
        ),
      );
    }
  }

  bool _shouldResolvePendingFor(ThreadItem item) {
    if (item.metadata['pending'] == true) {
      return false;
    }
    return _isUserAuthoredItem(item);
  }

  void _resolvePendingUserMessage(ThreadItem item) {
    final matchingId = _matchingPendingId(item);
    if (matchingId != null) {
      _removePendingPlaceholder(matchingId);
      return;
    }
    final fallbackId = _oldestPendingIdForThread(item.threadId);
    if (fallbackId != null) {
      _removePendingPlaceholder(fallbackId);
    }
  }

  bool _isUserAuthoredItem(ThreadItem item) {
    final type = item.type.toLowerCase();
    if (type == 'user_message' ||
        type == 'input_message' ||
        type == 'message') {
      return true;
    }
    final role = item.role?.toLowerCase();
    if (role == 'user') {
      return true;
    }
    for (final entry in item.content) {
      final contentType = (entry['type'] as String?)?.toLowerCase();
      if (contentType != null && contentType.startsWith('input_')) {
        return true;
      }
    }
    return false;
  }

  String? _matchingPendingId(ThreadItem item) {
    if (_pendingUserMessages.isEmpty && _items.isEmpty) {
      return null;
    }
    const contentEquality = DeepCollectionEquality();
    const attachmentEquality = DeepCollectionEquality();
    final attachmentSignature = _attachmentSignature(item);
    final normalizedText = _normalizedUserText(item);

    for (final pendingId in _pendingUserMessages.toList()) {
      final pendingItem = _items[pendingId];
      if (pendingItem == null) {
        continue;
      }
      if (pendingItem.metadata['pending'] == true &&
          pendingItem.threadId == item.threadId &&
          (contentEquality.equals(pendingItem.content, item.content) ||
              (_normalizedUserText(pendingItem) == normalizedText &&
                  _createdCloseTo(pendingItem, item))) &&
          attachmentEquality.equals(
            _attachmentSignature(pendingItem),
            attachmentSignature,
          )) {
        return pendingId;
      }
    }

    for (final entry in _items.entries) {
      final pendingItem = entry.value;
      if (pendingItem.metadata['pending'] == true &&
          pendingItem.threadId == item.threadId &&
          (contentEquality.equals(pendingItem.content, item.content) ||
              (_normalizedUserText(pendingItem) == normalizedText &&
                  _createdCloseTo(pendingItem, item))) &&
          attachmentEquality.equals(
            _attachmentSignature(pendingItem),
            attachmentSignature,
          )) {
        return entry.key;
      }
    }
    return null;
  }

  String? _oldestPendingIdForThread(String threadId) {
    ThreadItem? candidate;
    for (final item in _items.values) {
      if (item.metadata['pending'] == true && item.threadId == threadId) {
        if (candidate == null || item.createdAt.isBefore(candidate.createdAt)) {
          candidate = item;
        }
      }
    }
    return candidate?.id;
  }

  List<Map<String, Object?>> _attachmentSignature(ThreadItem item) {
    if (item.attachments.isEmpty) {
      return const [];
    }
    return item.attachments
        .map((attachment) => attachment.toJson())
        .toList(growable: false);
  }

  String _normalizedUserText(ThreadItem item) {
    final buffer = StringBuffer();
    for (final part in item.content) {
      final type = (part['type'] as String?)?.toLowerCase();
      if (type == 'input_text') {
        final text = (part['text'] as String?) ?? '';
        buffer.writeln(text);
      }
    }
    return buffer.toString().replaceAll('\r', '').trim();
  }

  bool _createdCloseTo(ThreadItem a, ThreadItem b, {Duration? window}) {
    final threshold = window ?? const Duration(minutes: 2);
    final diff = a.createdAt.difference(b.createdAt).abs();
    return diff <= threshold;
  }

  Future<void> _handleItemDone(ThreadItem item) async {
    if (_shouldResolvePendingFor(item)) {
      _resolvePendingUserMessage(item);
    }
    _items[item.id] = item;
    _eventController
        .add(ChatKitThreadEvent(streamEvent: ThreadItemDoneEvent(item: item)));

    if (item.type == 'assistant_message') {
      _eventController.add(
        ChatKitResponseEndEvent(threadId: item.threadId, item: item),
      );
    } else if (item.type == 'client_tool_call') {
      await _handleClientToolCall(item);
    }
  }

  void _handleItemUpdated(String itemId, Map<String, Object?> update) {
    final type = update['type'] as String?;
    if (type == 'widget.streaming_text.value_delta') {
      _queueStreamingTextUpdate(itemId, update);
      return;
    }

    final previous = _items[itemId];
    final updated =
        previous != null ? applyThreadItemUpdate(previous, update) : null;
    if (updated != null) {
      _items[itemId] = updated;
    }
    _eventController.add(
      ChatKitThreadEvent(
        streamEvent: ThreadItemUpdatedEvent(
          itemId: itemId,
          update: update,
        ),
      ),
    );
  }

  Future<void> _handleClientToolCall(ThreadItem item) async {
    final handler = _options.onClientTool;
    if (handler == null) {
      _eventController.add(
        ChatKitErrorEvent(
          error: 'Client tool requested but no handler configured.',
          code: 'client_tool',
          allowRetry: false,
        ),
      );
      return;
    }

    final invocation = ChatKitClientToolInvocation(
      name: item.raw['name'] as String? ?? '',
      params: castMap(item.raw['arguments']),
      threadId: item.threadId,
      invocationId: item.raw['call_id'] as String? ?? item.id,
    );

    try {
      final result = await handler(invocation);
      final payload = normalizeClientToolResult(result);
      await _runStreamingRequest(
        threadsAddClientToolOutput(
          threadId: item.threadId,
          result: payload,
        ),
        isFollowUp: true,
        allowQueue: false,
      );
    } catch (error, stackTrace) {
      _eventController.add(
        ChatKitErrorEvent(
          error: error.toString(),
          code: 'client_tool',
          allowRetry: true,
        ),
      );
      Zone.current.handleUncaughtError(error, stackTrace);
    }
  }

  void _queueStreamingTextUpdate(String itemId, Map<String, Object?> update) {
    final componentId = update['component_id'] as String?;
    if (componentId == null) {
      final previous = _items[itemId];
      if (previous != null) {
        final updated = applyThreadItemUpdate(previous, update);
        _items[itemId] = updated;
      }
      _eventController.add(
        ChatKitThreadEvent(
          streamEvent: ThreadItemUpdatedEvent(
            itemId: itemId,
            update: update,
          ),
        ),
      );
      return;
    }

    final key = '$itemId::$componentId';
    final buffer = _streamingTextBuffers.putIfAbsent(
      key,
      () => _StreamingTextBuffer(itemId: itemId, componentId: componentId),
    );
    buffer.append(update);
    _streamingDeltaTimer ??= Timer(
      const Duration(milliseconds: 16),
      _flushStreamingTextUpdates,
    );
  }

  void _flushStreamingTextUpdates() {
    if (_streamingTextBuffers.isEmpty) {
      _streamingDeltaTimer?.cancel();
      _streamingDeltaTimer = null;
      return;
    }
    final entries = List<_StreamingTextBuffer>.from(
      _streamingTextBuffers.values,
    );
    _streamingTextBuffers.clear();
    _streamingDeltaTimer?.cancel();
    _streamingDeltaTimer = null;

    for (final buffer in entries) {
      final update = buffer.buildUpdate();
      final itemId = buffer.itemId;
      final previous = _items[itemId];
      if (previous != null) {
        final updated = applyThreadItemUpdate(previous, update);
        _items[itemId] = updated;
      }
      _eventController.add(
        ChatKitThreadEvent(
          streamEvent: ThreadItemUpdatedEvent(
            itemId: itemId,
            update: update,
          ),
        ),
      );
    }
  }

  InferenceOptions? _buildInferenceOptions() {
    final composer = _options.composer;
    final composerModels = composer?.models;
    final composerTools = composer?.tools;

    final selectedModelId = _composerState.selectedModelId ??
        composerModels?.firstWhereOrNull((model) => model.defaultSelected)?.id;
    final selectedToolId = _composerState.selectedToolId;

    if ((selectedModelId == null || selectedModelId.isEmpty) &&
        (selectedToolId == null || selectedToolId.isEmpty)) {
      if (composerModels == null && composerTools == null) {
        return null;
      }
    }

    return InferenceOptions(
      model: selectedModelId,
      toolChoice:
          selectedToolId != null ? ToolChoice(id: selectedToolId) : null,
    );
  }

  Future<Map<String, Object?>?> _uploadToUrl(
    String url,
    List<int> bytes,
    String mimeType, {
    String method = 'PUT',
    Map<String, String>? headers,
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
  }) async {
    final request = http.StreamedRequest(method.toUpperCase(), Uri.parse(url))
      ..headers['content-type'] = mimeType;
    if (headers != null && headers.isNotEmpty) {
      request.headers.addAll(headers);
    }
    final total = bytes.length;
    var sent = 0;
    for (final chunk in _byteChunks(bytes)) {
      if (isCancelled?.call() == true) {
        await request.sink.close();
        throw ChatKitException('Upload cancelled');
      }
      request.sink.add(chunk);
      sent += chunk.length;
      onProgress?.call(sent, total);
    }
    await request.sink.close();
    final response = await _uploadClient.send(request);
    final body = await response.stream.bytesToString();
    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw ChatKitServerException(
        'Failed to upload attachment to storage',
        statusCode: response.statusCode,
        error: body.isEmpty ? null : {'body': body},
      );
    }
    if (body.isEmpty) {
      return null;
    }
    try {
      return castMap(jsonDecode(body));
    } catch (_) {
      return {'body': body};
    }
  }

  void _enqueueOfflineRequest(
    ChatKitRequest request, {
    String? pendingRequestId,
    required bool isFollowUp,
  }) {
    _offlineQueue.add(
      _QueuedStreamingRequest(
        request: request,
        pendingItemId: pendingRequestId,
        isFollowUp: isFollowUp,
      ),
    );
    _emitLog(
      'offline.queue',
      const {
        'message': 'Request queued due to connectivity issues.',
      },
    );
    _scheduleOfflineDrain();
  }

  void _scheduleOfflineDrain([Duration? delay]) {
    if (_offlineQueue.isEmpty) {
      return;
    }
    _offlineRetryTimer?.cancel();
    _offlineRetryTimer = Timer(delay ?? _offlineBackoff, () async {
      _offlineRetryTimer = null;
      if (_offlineQueue.isEmpty) {
        _offlineBackoff = const Duration(seconds: 2);
        return;
      }
      if (!_isAppActive) {
        _scheduleOfflineDrain(const Duration(seconds: 1));
        return;
      }
      if (_isStreaming) {
        _scheduleOfflineDrain(const Duration(seconds: 1));
        return;
      }

      final pending = _offlineQueue.removeFirst();
      try {
        final outcome = await _runStreamingRequest(
          pending.request,
          isFollowUp: pending.isFollowUp,
          allowQueue: false,
          pendingRequestId: pending.pendingItemId,
        );
        if (outcome == _StreamingOutcome.completed) {
          _offlineBackoff = const Duration(seconds: 2);
        }
      } catch (error, stackTrace) {
        if (_shouldRetryStreamingError(error)) {
          pending.attempts += 1;
          if (pending.attempts < _QueuedStreamingRequest.maxAttempts) {
            _offlineQueue.addFirst(pending);
            _offlineBackoff = Duration(
              milliseconds: math.min(
                _offlineBackoff.inMilliseconds * 2,
                60000,
              ),
            );
            _scheduleOfflineDrain(_offlineBackoff);
            return;
          }
        }

        _eventController.add(
          ChatKitErrorEvent(
            error: 'Failed to deliver request: $error',
            allowRetry: true,
          ),
        );
        _removePendingPlaceholder(pending.pendingItemId);
        Zone.current.handleUncaughtError(error, stackTrace);
      }

      if (_offlineQueue.isNotEmpty) {
        _scheduleOfflineDrain(const Duration(milliseconds: 500));
      } else {
        _offlineBackoff = const Duration(seconds: 2);
      }
    });
  }

  void _removePendingPlaceholder(String? pendingId) {
    if (pendingId == null) {
      return;
    }
    _pendingUserMessages.removeWhere((value) => value == pendingId);
    final removed = _items.remove(pendingId);
    if (removed != null) {
      _eventController.add(
        ChatKitThreadEvent(
          streamEvent: ThreadItemRemovedEvent(itemId: pendingId),
        ),
      );
    }
  }

  Stream<List<int>> _trackedByteStream(
    List<int> bytes, {
    void Function(int sentBytes, int totalBytes)? onProgress,
    bool Function()? isCancelled,
    int chunkSize = 64 * 1024,
  }) async* {
    final total = bytes.length;
    var offset = 0;
    while (offset < bytes.length) {
      if (isCancelled?.call() == true) {
        throw ChatKitException('Upload cancelled');
      }
      final end = math.min(offset + chunkSize, bytes.length);
      final chunk = bytes.sublist(offset, end);
      offset = end;
      onProgress?.call(offset, total);
      yield chunk;
    }
  }

  Iterable<List<int>> _byteChunks(List<int> bytes,
      {int chunkSize = 64 * 1024}) sync* {
    var offset = 0;
    while (offset < bytes.length) {
      final end = math.min(offset + chunkSize, bytes.length);
      yield bytes.sublist(offset, end);
      offset = end;
    }
  }
}

enum _StreamingOutcome {
  completed,
  queued,
}

class _QueuedStreamingRequest {
  _QueuedStreamingRequest({
    required this.request,
    this.pendingItemId,
    required this.isFollowUp,
  });

  static const int maxAttempts = 5;

  final ChatKitRequest request;
  final String? pendingItemId;
  final bool isFollowUp;
  int attempts = 0;
}

class _StreamingTextBuffer {
  _StreamingTextBuffer({
    required this.itemId,
    required this.componentId,
  });

  final String itemId;
  final String componentId;
  final StringBuffer _buffer = StringBuffer();
  Map<String, Object?>? _lastUpdate;
  bool? _done;

  void append(Map<String, Object?> update) {
    final delta = update['delta'] as String?;
    if (delta != null && delta.isNotEmpty) {
      _buffer.write(delta);
    }
    final done = update['done'];
    if (done is bool) {
      _done = done;
    }
    _lastUpdate = Map<String, Object?>.from(update);
  }

  Map<String, Object?> buildUpdate() {
    final base = Map<String, Object?>.from(
      _lastUpdate ?? const {'type': 'widget.streaming_text.value_delta'},
    );
    base['component_id'] = componentId;
    base['delta'] = _buffer.toString();
    if (_done != null) {
      base['done'] = _done;
    }
    return base;
  }
}
</file>

<file path="packages/chatkit_flutter/lib/src/widgets/chatkit_view.dart">
import 'dart:async';
import 'dart:math' as math;

import 'package:cached_network_image/cached_network_image.dart';
import 'package:chatkit_core/chatkit_core.dart';
import 'package:collection/collection.dart';
import 'package:file_picker/file_picker.dart';
import 'package:desktop_drop/desktop_drop.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:intl/intl.dart';
import 'package:mime/mime.dart';
import 'package:meta/meta.dart';
import 'package:share_plus/share_plus.dart';

import '../localization/localizations.dart';
import '../widgets/widget_renderer.dart';
import '../theme/chatkit_theme.dart';
import '../theme/icons.dart';
import '../theme/tokens.dart';

double _spacingValue(BuildContext context, double value) {
  if (value == 0) return 0;
  final spacing = _maybeChatTheme(context)?.spacing;
  if (spacing == null) {
    return value;
  }
  switch (value.round()) {
    case 2:
      return spacing.xxxs;
    case 4:
      return spacing.xxs;
    case 6:
      return spacing.xs - spacing.xxxs;
    case 8:
      return spacing.xs;
    case 10:
      return spacing.sm - spacing.xxxs;
    case 12:
      return spacing.sm;
    case 16:
      return spacing.md;
    case 20:
      return spacing.lg;
    case 24:
      return spacing.xl;
    case 32:
      return spacing.xxl;
    default:
      return value;
  }
}

EdgeInsets _spacingOnly(
  BuildContext context, {
  double left = 0,
  double top = 0,
  double right = 0,
  double bottom = 0,
}) {
  return EdgeInsets.only(
    left: _spacingValue(context, left),
    top: _spacingValue(context, top),
    right: _spacingValue(context, right),
    bottom: _spacingValue(context, bottom),
  );
}

EdgeInsets _spacingSymmetric(
  BuildContext context, {
  double horizontal = 0,
  double vertical = 0,
}) {
  return EdgeInsets.symmetric(
    horizontal: _spacingValue(context, horizontal),
    vertical: _spacingValue(context, vertical),
  );
}

EdgeInsets _spacingAll(BuildContext context, double value) =>
    EdgeInsets.all(_spacingValue(context, value));

EdgeInsets _spacingFromLTRB(
  BuildContext context,
  double left,
  double top,
  double right,
  double bottom,
) {
  return EdgeInsets.fromLTRB(
    _spacingValue(context, left),
    _spacingValue(context, top),
    _spacingValue(context, right),
    _spacingValue(context, bottom),
  );
}

BorderRadius _radius(BuildContext context, double value) {
  final radii = _maybeChatTheme(context)?.radii;
  if (radii == null) {
    return BorderRadius.circular(value);
  }
  switch (value.round()) {
    case 6:
      return BorderRadius.circular(radii.sm);
    case 8:
      return BorderRadius.circular(radii.lg);
    case 10:
      return BorderRadius.circular(radii.button);
    case 12:
      return BorderRadius.circular(radii.card);
    case 16:
      return BorderRadius.circular(radii.composer);
    case 20:
      return BorderRadius.circular(radii.icon);
    case 999:
      return BorderRadius.circular(radii.full);
    default:
      return BorderRadius.circular(value);
  }
}

ChatKitThemeData? _maybeChatTheme(BuildContext context) {
  final element =
      context.getElementForInheritedWidgetOfExactType<ChatKitTheme>();
  if (element == null) {
    return null;
  }
  final widget = element.widget;
  return widget is ChatKitTheme ? widget.data : null;
}

class ChatKitView extends StatefulWidget {
  const ChatKitView({
    super.key,
    required this.controller,
    this.hideHiddenItems = false,
  });

  final ChatKitController controller;
  final bool hideHiddenItems;

  @override
  State<ChatKitView> createState() => _ChatKitViewState();
}

class _ChatKitViewState extends State<ChatKitView> with WidgetsBindingObserver {
  final ScrollController _scrollController = ScrollController();
  late final TextEditingController _composerController;
  late final FocusNode _composerFocusNode;
  StreamSubscription<ChatKitEvent>? _subscription;

  List<ThreadItem> _items = const [];
  Thread? _thread;
  bool _isStreaming = false;
  bool _isUploading = false;
  List<ChatKitAttachment> _attachments = const [];
  List<_PendingUpload> _pendingUploads = const [];
  List<Entity> _selectedTags = const [];
  String? _selectedModelId;
  String? _selectedToolId;
  bool _composerEnabled = true;
  String? _composerDisabledReason;
  DateTime? _composerRetryAt;
  Timer? _composerRetryTicker;
  List<_BannerMessage> _banners = const [];
  bool _isDropTargetActive = false;
  int _dropDepth = 0;
  final Map<String, Map<String, String>> _dynamicLocalizationBundles = {};
  final Set<String> _loadingLocales = {};
  bool _suppressSnackbars = false;

  bool _historyOpen = false;
  final Map<_HistorySection, _HistorySectionState> _historySections = {
    for (final section in _HistorySection.values)
      section: const _HistorySectionState(),
  };
  _HistorySection _activeHistorySection = _HistorySection.recent;
  String _historySearchQuery = '';
  Timer? _historySearchDebounce;
  late final TextEditingController _historySearchController;
  final ScrollController _historyScrollController = ScrollController();
  int _historyRequestId = 0;
  bool _authExpired = false;
  final LayerLink _composerFieldLink = LayerLink();
  OverlayEntry? _tagSuggestionOverlay;
  List<Entity> _tagSuggestions = const [];
  bool _tagSuggestionVisible = false;
  bool _tagSuggestionLoading = false;
  int _tagSuggestionIndex = 0;
  int? _tagTriggerIndex;
  String _tagQuery = '';
  Timer? _tagSearchDebounce;
  final Map<String, FocusNode> _tagFocusNodes = {};

  ChatKitController get controller => widget.controller;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    final composer = controller.composerState;
    _composerController = TextEditingController(text: composer.text);
    _historySearchController = TextEditingController(text: _historySearchQuery);
    _composerFocusNode = FocusNode(
      debugLabel: 'chatkit.composer',
      onKeyEvent: _handleComposerKeyEvent,
    );
    _composerFocusNode.addListener(_handleComposerFocusChange);
    _attachments = composer.attachments;
    _selectedTags = List<Entity>.from(composer.tags);
    _selectedModelId = composer.selectedModelId;
    _selectedToolId = composer.selectedToolId;
    _syncTagFocusNodes();
    _thread = controller.activeThread;
    _items = _applyItemFilter(controller.threadItems);
    _subscription = controller.events.listen(_handleEvent);
    _historyScrollController.addListener(_handleHistoryScroll);
    if (controller.currentThreadId == null &&
        controller.options.initialThread != null) {
      unawaited(controller.setThreadId(controller.options.initialThread));
    }
    if (_historyEnabled) {
      _refreshHistory();
    }
    _ensureLocaleBundle();
  }

  double _spacingValue(BuildContext context, double value) {
    if (value == 0) return 0;
    final spacing = _maybeChatTheme(context)?.spacing;
    if (spacing == null) {
      return value;
    }
    switch (value.round()) {
      case 2:
        return spacing.xxxs;
      case 4:
        return spacing.xxs;
      case 6:
        return spacing.xs - spacing.xxxs;
      case 8:
        return spacing.xs;
      case 10:
        return spacing.sm - spacing.xxxs;
      case 12:
        return spacing.sm;
      case 16:
        return spacing.md;
      case 20:
        return spacing.lg;
      case 24:
        return spacing.xl;
      case 32:
        return spacing.xxl;
      default:
        return value;
    }
  }

  EdgeInsets _spacingOnly(
    BuildContext context, {
    double left = 0,
    double top = 0,
    double right = 0,
    double bottom = 0,
  }) {
    return EdgeInsets.only(
      left: _spacingValue(context, left),
      top: _spacingValue(context, top),
      right: _spacingValue(context, right),
      bottom: _spacingValue(context, bottom),
    );
  }

  EdgeInsets _spacingSymmetric(
    BuildContext context, {
    double horizontal = 0,
    double vertical = 0,
  }) {
    return EdgeInsets.symmetric(
      horizontal: _spacingValue(context, horizontal),
      vertical: _spacingValue(context, vertical),
    );
  }

  EdgeInsets _spacingAll(BuildContext context, double value) {
    return EdgeInsets.all(_spacingValue(context, value));
  }

  EdgeInsets _spacingFromLTRB(
    BuildContext context,
    double left,
    double top,
    double right,
    double bottom,
  ) {
    return EdgeInsets.fromLTRB(
      _spacingValue(context, left),
      _spacingValue(context, top),
      _spacingValue(context, right),
      _spacingValue(context, bottom),
    );
  }

  BorderRadius _radius(BuildContext context, double value) {
    final radii = _maybeChatTheme(context)?.radii;
    if (radii == null) {
      return BorderRadius.circular(value);
    }
    switch (value.round()) {
      case 6:
        return BorderRadius.circular(radii.sm);
      case 8:
        return BorderRadius.circular(radii.lg);
      case 10:
        return BorderRadius.circular(radii.button);
      case 12:
        return BorderRadius.circular(radii.card);
      case 16:
        return BorderRadius.circular(radii.composer);
      case 20:
        return BorderRadius.circular(radii.icon);
      case 999:
        return BorderRadius.circular(radii.full);
      default:
        return BorderRadius.circular(value);
    }
  }

  @override
  void didUpdateWidget(covariant ChatKitView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.hideHiddenItems != widget.hideHiddenItems) {
      final updated = widget.hideHiddenItems
          ? _applyItemFilter(controller.threadItems)
          : controller.threadItems;
      setState(() {
        _items = updated;
      });
    }
    _ensureLocaleBundle();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _subscription?.cancel();
    _tagSearchDebounce?.cancel();
    _historySearchDebounce?.cancel();
    _composerRetryTicker?.cancel();
    _removeTagSuggestionOverlay();
    for (final node in _tagFocusNodes.values) {
      node.dispose();
    }
    _composerFocusNode.removeListener(_handleComposerFocusChange);
    _composerController.dispose();
    _historyScrollController.removeListener(_handleHistoryScroll);
    _historySearchController.dispose();
    _composerFocusNode.dispose();
    _scrollController.dispose();
    _historyScrollController.dispose();
    super.dispose();
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    if (!_composerFocusNode.hasFocus) {
      return;
    }
    _ensureComposerVisible();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    switch (state) {
      case AppLifecycleState.resumed:
        controller.handleAppForegrounded();
        _ensureComposerVisible();
        break;
      case AppLifecycleState.inactive:
      case AppLifecycleState.paused:
      case AppLifecycleState.hidden:
        controller.handleAppBackgrounded();
        break;
      case AppLifecycleState.detached:
        controller.handleAppBackgrounded();
        break;
    }
  }

  bool get _historyEnabled => controller.options.history?.enabled ?? false;

  bool get _canAddEntities => controller.options.entities?.onTagSearch != null;

  bool get _attachmentsEnabled =>
      controller.options.composer?.attachments?.enabled == true;

  ChatKitLocalizations get _localizations => ChatKitLocalizations(
        locale: controller.options.locale,
        overrides: controller.options.localizationOverrides,
        bundles: {
          if (controller.options.localization != null)
            ...controller.options.localization!.bundles,
          ..._dynamicLocalizationBundles,
        },
        defaultLocale: controller.options.localization?.defaultLocale,
        pluralResolver: controller.options.localization?.pluralResolver,
      );

  void _ensureLocaleBundle() {
    final localization = controller.options.localization;
    final loader = localization?.loader;
    final locale = controller.options.locale;
    if (loader == null || locale == null || locale.isEmpty) {
      return;
    }
    final canonical = ChatKitLocalizations.canonicalize(locale);
    if (_dynamicLocalizationBundles.containsKey(canonical) ||
        localization!.bundles.containsKey(canonical) ||
        _loadingLocales.contains(canonical)) {
      return;
    }
    _loadingLocales.add(canonical);
    Future.microtask(() async {
      try {
        final bundle = await loader(canonical);
        if (!mounted) return;
        if (bundle.isNotEmpty) {
          setState(() {
            _dynamicLocalizationBundles[canonical] =
                Map<String, String>.unmodifiable(bundle);
          });
        }
      } catch (error) {
        if (mounted) {
          debugPrint(
            'ChatKit: failed to load localization bundle for $canonical: $error',
          );
        }
      } finally {
        _loadingLocales.remove(canonical);
      }
    });
  }

  _LayoutSize _layoutSizeOf(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    final breakpoints = controller.options.resolvedTheme?.breakpoints;
    final compactMax = breakpoints?.compact ?? 640;
    final mediumMax = breakpoints?.medium ?? 1024;
    if (width <= compactMax) {
      return _LayoutSize.compact;
    }
    if (width <= mediumMax) {
      return _LayoutSize.medium;
    }
    return _LayoutSize.expanded;
  }

  void _handleEvent(ChatKitEvent event) {
    if (!mounted) return;
    _ensureLocaleBundle();
    if (event is ChatKitShareEvent) {
      unawaited(
        _handleShareEvent(
          threadId: event.threadId,
          itemId: event.itemId,
          content: event.content,
        ),
      );
      return;
    }
    if (event is ChatKitComposerAvailabilityEvent) {
      _applyComposerAvailability(event);
      return;
    }
    if (event is ChatKitNoticeEvent) {
      _enqueueBanner(event);
      return;
    }
    var hideSuggestions = false;
    setState(() {
      switch (event) {
        case ChatKitThreadChangeEvent(:final threadId):
          _thread = controller.activeThread;
          _items = _applyItemFilter(controller.threadItems);
          if (threadId == null) {
            _composerController.clear();
            _attachments = const [];
          }
          _scheduleScrollToBottom(retries: 3);
          break;
        case ChatKitThreadLoadEndEvent(:final threadId):
          if (threadId == controller.currentThreadId) {
            _scheduleScrollToBottom(retries: 3);
          }
          break;
        case ChatKitThreadEvent(:final streamEvent):
          _handleThreadEvent(streamEvent);
          break;
        case ChatKitResponseStartEvent():
          _isStreaming = true;
          break;
        case ChatKitResponseEndEvent():
          _isStreaming = false;
          _scheduleScrollToBottom();
          break;
        case ChatKitErrorEvent(:final error):
          if (error != null && context.mounted) {
            final messenger = ScaffoldMessenger.maybeOf(context);
            if (!_suppressSnackbars && messenger != null) {
              messenger.showSnackBar(
                SnackBar(content: Text(error)),
              );
            }
          }
          break;
        case ChatKitLogEvent():
          break;
        case ChatKitComposerUpdatedEvent(:final state):
          if (_composerController.text != state.text) {
            _composerController.value = TextEditingValue(
              text: state.text,
              selection: TextSelection.collapsed(offset: state.text.length),
            );
          }
          _attachments = state.attachments;
          _selectedTags = List<Entity>.from(state.tags);
          _selectedModelId = state.selectedModelId;
          _selectedToolId = state.selectedToolId;
          _syncTagFocusNodes();
          hideSuggestions = true;
          break;
        case ChatKitAuthExpiredEvent():
          _authExpired = true;
          break;
        case ChatKitComposerFocusEvent():
          _composerFocusNode.requestFocus();
          break;
        default:
          break;
      }
    });
    if (hideSuggestions) {
      _hideTagSuggestions();
    }
  }

  void _syncTagFocusNodes() {
    final ids = _selectedTags.map((tag) => tag.id).toSet();
    final toRemove =
        _tagFocusNodes.keys.where((id) => !ids.contains(id)).toList();
    for (final id in toRemove) {
      _tagFocusNodes.remove(id)?.dispose();
    }
    for (final tag in _selectedTags) {
      final node = _tagFocusNodes.putIfAbsent(
        tag.id,
        () => FocusNode(debugLabel: 'chatkit.tag.${tag.id}'),
      );
      node.onKeyEvent = (focusNode, event) => _handleTagChipKey(tag, event);
    }
  }

  void _handleThreadEvent(ThreadStreamEvent event) {
    switch (event) {
      case ThreadCreatedEvent(:final thread):
        _thread = thread;
        _items = _applyItemFilter(controller.threadItems);
        _scheduleScrollToBottom();
        break;
      case ThreadItemAddedEvent(:final item):
        if (!_shouldDisplayItem(item)) {
          break;
        }
        _upsertItem(item);
        _scheduleScrollToBottom();
        break;
      case ThreadItemDoneEvent(:final item):
        if (!_shouldDisplayItem(item)) {
          break;
        }
        _upsertItem(item);
        _scheduleScrollToBottom();
        break;
      case ThreadItemUpdatedEvent(:final itemId):
        final updated = controller.threadItemById(itemId);
        if (updated != null) {
          if (_shouldDisplayItem(updated)) {
            _upsertItem(updated);
          } else {
            _items =
                _items.where((element) => element.id != updated.id).toList();
          }
        }
        break;
      case ThreadItemReplacedEvent(:final item):
        if (!_shouldDisplayItem(item)) {
          _items = _items.where((element) => element.id != item.id).toList();
          break;
        }
        _upsertItem(item);
        break;
      case ThreadItemRemovedEvent(:final itemId):
        _items = _items.where((element) => element.id != itemId).toList();
        break;
      case ThreadUpdatedEvent(:final thread):
        _thread = thread;
        break;
      case UnknownStreamEvent():
        break;
      case ProgressUpdateEvent(:final text):
        if (context.mounted) {
          final messenger = ScaffoldMessenger.maybeOf(context);
          if (!_suppressSnackbars && messenger != null) {
            messenger.showSnackBar(
              SnackBar(content: Text(text)),
            );
          }
        }
        break;
      case ErrorEvent(:final message):
        if (message != null && context.mounted) {
          final messenger = ScaffoldMessenger.maybeOf(context);
          if (!_suppressSnackbars && messenger != null) {
            messenger.showSnackBar(
              SnackBar(content: Text(message)),
            );
          }
        }
        break;
      case NoticeEvent():
        break;
    }

    if (_historyEnabled &&
        (event is ThreadCreatedEvent || event is ThreadUpdatedEvent)) {
      _refreshHistory();
    }
  }

  void _handleComposerChanged(String value) {
    controller.setComposerValue(text: value, tags: _selectedTags);
    _updateTagAutocomplete();
  }

  void _handleComposerFocusChange() {
    if (!_composerFocusNode.hasFocus) {
      _hideTagSuggestions();
      return;
    }
    _ensureComposerVisible();
  }

  KeyEventResult _handleComposerKeyEvent(FocusNode node, KeyEvent event) {
    if (event is! KeyDownEvent) {
      return KeyEventResult.ignored;
    }
    final key = event.logicalKey;
    if (_tagSuggestionVisible) {
      if (key == LogicalKeyboardKey.arrowDown ||
          key == LogicalKeyboardKey.arrowUp) {
        final count = _tagSuggestions.length;
        if (count == 0) {
          return KeyEventResult.handled;
        }
        setState(() {
          if (key == LogicalKeyboardKey.arrowDown) {
            _tagSuggestionIndex =
                (_tagSuggestionIndex + 1) % _tagSuggestions.length;
          } else {
            _tagSuggestionIndex =
                (_tagSuggestionIndex - 1 + _tagSuggestions.length) %
                    _tagSuggestions.length;
          }
        });
        _markTagOverlayNeedsBuild();
        return KeyEventResult.handled;
      }
      if (key == LogicalKeyboardKey.enter ||
          key == LogicalKeyboardKey.numpadEnter ||
          key == LogicalKeyboardKey.tab) {
        if (_tagSuggestions.isNotEmpty) {
          _applyTagSuggestion(
            _tagSuggestions[
                _tagSuggestionIndex.clamp(0, _tagSuggestions.length - 1)],
          );
        } else {
          _hideTagSuggestions();
        }
        return KeyEventResult.handled;
      }
      if (key == LogicalKeyboardKey.escape) {
        _hideTagSuggestions();
        return KeyEventResult.handled;
      }
    }

    final selection = _composerController.selection;
    final atStart =
        selection.isValid && selection.isCollapsed && selection.baseOffset == 0;
    if (_selectedTags.isNotEmpty &&
        atStart &&
        (key == LogicalKeyboardKey.backspace ||
            key == LogicalKeyboardKey.arrowLeft)) {
      _focusTagChipAt(_selectedTags.length - 1);
      return KeyEventResult.handled;
    }

    if (key == LogicalKeyboardKey.arrowLeft ||
        key == LogicalKeyboardKey.arrowRight ||
        key == LogicalKeyboardKey.home ||
        key == LogicalKeyboardKey.end) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          _updateTagAutocomplete();
        }
      });
    }

    return KeyEventResult.ignored;
  }

  KeyEventResult _handleTagChipKey(Entity entity, KeyEvent event) {
    if (event is! KeyDownEvent) {
      return KeyEventResult.ignored;
    }
    final index = _selectedTags.indexWhere((tag) => tag.id == entity.id);
    if (index == -1) {
      return KeyEventResult.ignored;
    }
    final key = event.logicalKey;
    final keysPressed = HardwareKeyboard.instance.logicalKeysPressed;
    final altPressed = keysPressed.contains(LogicalKeyboardKey.altLeft) ||
        keysPressed.contains(LogicalKeyboardKey.altRight);
    if (altPressed &&
        (key == LogicalKeyboardKey.arrowLeft ||
            key == LogicalKeyboardKey.arrowRight)) {
      _reorderTag(entity, key == LogicalKeyboardKey.arrowLeft ? -1 : 1);
      return KeyEventResult.handled;
    }
    if (key == LogicalKeyboardKey.arrowLeft) {
      if (index > 0) {
        _focusTagChipAt(index - 1);
      } else {
        _focusComposer(atEnd: false);
      }
      return KeyEventResult.handled;
    }
    if (key == LogicalKeyboardKey.arrowRight) {
      if (index < _selectedTags.length - 1) {
        _focusTagChipAt(index + 1);
      } else {
        _focusComposer(atEnd: false);
      }
      return KeyEventResult.handled;
    }
    if (key == LogicalKeyboardKey.backspace ||
        key == LogicalKeyboardKey.delete) {
      final nextIndex = math.min(index, _selectedTags.length - 2);
      _removeTag(entity);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        if (_selectedTags.isEmpty) {
          _focusComposer();
        } else if (nextIndex >= 0 && nextIndex < _selectedTags.length) {
          _focusTagChipAt(nextIndex);
        } else {
          _focusComposer();
        }
      });
      return KeyEventResult.handled;
    }
    return KeyEventResult.ignored;
  }

  void _focusTagChipAt(int index) {
    if (index < 0 || index >= _selectedTags.length) {
      _focusComposer(atEnd: index >= _selectedTags.length);
      return;
    }
    final tag = _selectedTags[index];
    final node = _tagFocusNodes[tag.id];
    node?.requestFocus();
  }

  String? _entityTooltip(Entity entity) {
    final data = entity.data;
    final tooltip = data['tooltip'];
    if (tooltip is String && tooltip.trim().isNotEmpty) {
      return tooltip.trim();
    }
    final description = data['description'];
    if (description is String && description.trim().isNotEmpty) {
      return description.trim();
    }
    return null;
  }

  Widget? _entityAvatar(Entity entity) {
    final icon = entity.icon;
    if (icon != null && icon.trim().isNotEmpty && icon.contains('://')) {
      return CircleAvatar(
        radius: 12,
        backgroundImage: CachedNetworkImageProvider(icon),
      );
    }
    return null;
  }

  void _focusComposer({bool atEnd = true}) {
    if (!_composerFocusNode.hasFocus) {
      _composerFocusNode.requestFocus();
    }
    final text = _composerController.text;
    final target = atEnd ? text.length : 0;
    final safeOffset = target.clamp(0, text.length).toInt();
    _composerController.selection = TextSelection.collapsed(offset: safeOffset);
    _ensureComposerVisible();
  }

  void _ensureComposerVisible() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      if (!_scrollController.hasClients) return;
      final mediaQuery = MediaQuery.maybeOf(context);
      if (mediaQuery == null) return;
      final bottomInset = mediaQuery.viewInsets.bottom;
      if (bottomInset <= 0 && !_composerFocusNode.hasFocus) {
        return;
      }
      final maxExtent = _scrollController.position.maxScrollExtent;
      if ((maxExtent - _scrollController.offset).abs() < 4) {
        return;
      }
      _scrollController.animateTo(
        maxExtent,
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutCubic,
      );
    });
  }

  void _applyTagSuggestion(Entity entity) {
    final triggerIndex = _tagTriggerIndex;
    final selection = _composerController.selection;
    if (triggerIndex == null || !selection.isValid) {
      _hideTagSuggestions();
      return;
    }
    final end = selection.baseOffset;
    if (end < triggerIndex) {
      _hideTagSuggestions();
      return;
    }
    final text = _composerController.text;
    final newText = text.replaceRange(triggerIndex, end, '');
    _composerController.value = TextEditingValue(
      text: newText,
      selection: TextSelection.collapsed(offset: triggerIndex),
    );
    if (!_selectedTags.any((tag) => tag.id == entity.id)) {
      setState(() {
        _selectedTags = [..._selectedTags, entity];
      });
      _syncTagFocusNodes();
    }
    controller.setComposerValue(text: newText, tags: _selectedTags);
    _hideTagSuggestions();
    _focusComposer(atEnd: false);
  }

  void _updateTagAutocomplete() {
    final searchFn = controller.options.entities?.onTagSearch;
    if (searchFn == null) {
      _hideTagSuggestions();
      return;
    }
    final selection = _composerController.selection;
    if (!selection.isValid || !selection.isCollapsed) {
      _hideTagSuggestions();
      return;
    }
    final cursor = selection.baseOffset;
    final text = _composerController.text;
    if (cursor <= 0 || text.isEmpty) {
      _hideTagSuggestions();
      return;
    }
    var index = cursor - 1;
    while (index >= 0) {
      final char = text[index];
      if (char == '@') {
        final boundaryOk = index == 0 ||
            RegExp(r'''[\s([{<>"'.!?:;-]''').hasMatch(text[index - 1]);
        if (!boundaryOk) {
          _hideTagSuggestions();
          return;
        }
        final query = text.substring(index + 1, cursor);
        if (query.isEmpty ||
            query.contains(RegExp(r'\s')) ||
            query.contains('\n')) {
          _hideTagSuggestions();
          return;
        }
        if (_tagSuggestionVisible &&
            !_tagSuggestionLoading &&
            _tagQuery == query) {
          return;
        }
        _tagSearchDebounce?.cancel();
        setState(() {
          _tagTriggerIndex = index;
          _tagQuery = query;
          _tagSuggestionIndex = 0;
          _tagSuggestions = const [];
          _tagSuggestionLoading = true;
          _tagSuggestionVisible = true;
        });
        _showTagSuggestions();
        _tagSearchDebounce = Timer(const Duration(milliseconds: 200), () async {
          List<Entity> results = const [];
          try {
            results = await Future<List<Entity>>.value(searchFn(query));
          } catch (_) {
            results = const [];
          }
          if (!mounted || _tagQuery != query) {
            return;
          }
          final selectedIds = _selectedTags.map((tag) => tag.id).toSet();
          results = results
              .where((entity) => !selectedIds.contains(entity.id))
              .toList();
          setState(() {
            _tagSuggestionLoading = false;
            _tagSuggestions = results;
            if (results.isEmpty) {
              _tagSuggestionIndex = 0;
            } else {
              _tagSuggestionIndex =
                  _tagSuggestionIndex.clamp(0, results.length - 1).toInt();
            }
          });
          _tagSearchDebounce = null;
          _markTagOverlayNeedsBuild();
        });
        _markTagOverlayNeedsBuild();
        return;
      }
      if (char == ' ' || char == '\n' || char == '\t') {
        break;
      }
      index -= 1;
    }
    _hideTagSuggestions();
  }

  void _showTagSuggestions() {
    if (_tagSuggestionOverlay != null) {
      _markTagOverlayNeedsBuild();
      return;
    }
    final overlay = Overlay.of(context);
    _tagSuggestionOverlay = OverlayEntry(
      builder: (context) => _buildTagSuggestionOverlay(),
    );
    overlay.insert(_tagSuggestionOverlay!);
  }

  void _hideTagSuggestions() {
    _tagSearchDebounce?.cancel();
    _tagSearchDebounce = null;
    if (!_tagSuggestionVisible &&
        !_tagSuggestionLoading &&
        _tagSuggestions.isEmpty) {
      _removeTagSuggestionOverlay();
      _tagTriggerIndex = null;
      _tagQuery = '';
      return;
    }
    if (!mounted) {
      _tagSuggestionVisible = false;
      _tagSuggestionLoading = false;
      _tagSuggestions = const [];
      _tagSuggestionIndex = 0;
      _tagTriggerIndex = null;
      _tagQuery = '';
      _removeTagSuggestionOverlay();
      return;
    }
    setState(() {
      _tagSuggestionVisible = false;
      _tagSuggestionLoading = false;
      _tagSuggestions = const [];
      _tagSuggestionIndex = 0;
      _tagTriggerIndex = null;
      _tagQuery = '';
    });
    _removeTagSuggestionOverlay();
  }

  void _removeTagSuggestionOverlay() {
    _tagSuggestionOverlay?.remove();
    _tagSuggestionOverlay = null;
  }

  void _markTagOverlayNeedsBuild() {
    _tagSuggestionOverlay?.markNeedsBuild();
  }

  Widget _buildTagSuggestionOverlay() {
    if (!_tagSuggestionVisible &&
        !_tagSuggestionLoading &&
        _tagSuggestions.isEmpty) {
      return const SizedBox.shrink();
    }
    final theme = Theme.of(context);
    final l10n = _localizations;
    final suggestions = _tagSuggestions;
    final loading = _tagSuggestionLoading;

    return Stack(
      children: [
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: _hideTagSuggestions,
          ),
        ),
        CompositedTransformFollower(
          link: _composerFieldLink,
          showWhenUnlinked: false,
          targetAnchor: Alignment.bottomLeft,
          followerAnchor: Alignment.topLeft,
          offset: const Offset(0, 6),
          child: Material(
            elevation: 8,
            borderRadius: _radius(context, 12),
            clipBehavior: Clip.antiAlias,
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 360),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  if (loading)
                    const LinearProgressIndicator(
                      minHeight: 2,
                    ),
                  if (!loading && suggestions.isEmpty)
                    Padding(
                      padding: _spacingAll(context, 16),
                      child: Text(
                        l10n.t('tag_suggestions_empty'),
                        style: theme.textTheme.bodyMedium,
                      ),
                    ),
                  if (suggestions.isNotEmpty)
                    SizedBox(
                      width: double.infinity,
                      height: math.min(suggestions.length * 52.0, 240.0),
                      child: ListView.builder(
                        padding: EdgeInsets.zero,
                        itemCount: suggestions.length,
                        itemBuilder: (context, index) {
                          final suggestion = suggestions[index];
                          final selected = index == _tagSuggestionIndex;
                          final palette = ChatKitTheme.of(context).palette;
                          final labelStyle =
                              theme.textTheme.bodyMedium?.copyWith(
                            color: selected
                                ? theme.colorScheme.primary
                                : theme.textTheme.bodyMedium?.color,
                          );
                          final description =
                              suggestion.data['description'] as String?;
                          return InkWell(
                            onTap: () => _applyTagSuggestion(suggestion),
                            child: Container(
                              color: selected
                                  ? theme.colorScheme.primary
                                      .withValues(alpha: 0.08)
                                  : palette.transparent,
                              padding: _spacingSymmetric(
                                context,
                                horizontal: 16,
                                vertical: 12,
                              ),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(suggestion.title, style: labelStyle),
                                  if (description != null &&
                                      description.isNotEmpty)
                                    Padding(
                                      padding: _spacingOnly(context, top: 2),
                                      child: Text(
                                        description,
                                        style:
                                            theme.textTheme.bodySmall?.copyWith(
                                          color: selected
                                              ? theme.colorScheme.primary
                                                  .withValues(alpha: 0.8)
                                              : theme.textTheme.bodySmall?.color
                                                  ?.withValues(alpha: 0.7),
                                        ),
                                      ),
                                    ),
                                ],
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  if (loading && suggestions.isEmpty)
                    Padding(
                      padding: _spacingAll(context, 16),
                      child: Text(
                        l10n.t('tag_suggestions_loading'),
                        style: theme.textTheme.bodySmall,
                      ),
                    ),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }

  Future<void> _handleShareEvent({
    required String threadId,
    required String itemId,
    required List<Map<String, Object?>> content,
  }) async {
    if (!mounted) return;
    final shareText = _composeShareText(content);
    if (shareText.isEmpty) {
      return;
    }
    final l10n = _localizations;
    final shareActions = controller.options.threadItemActions?.shareActions;
    final targets = _resolveShareTargets(shareActions);
    if (targets.isEmpty) {
      return;
    }

    final result = await showModalBottomSheet<ShareTargetOption>(
      context: context,
      showDragHandle: true,
      builder: (context) {
        final theme = Theme.of(context);
        return SafeArea(
          child: Padding(
            padding: _spacingFromLTRB(context, 16, 12, 16, 20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.t('share_sheet_title'),
                  style: theme.textTheme.titleMedium,
                ),
                SizedBox(height: _spacingValue(context, 12)),
                if (shareText.length > 200)
                  Container(
                    margin: _spacingOnly(context, bottom: 12),
                    padding: _spacingAll(context, 12),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surfaceContainerHighest,
                      borderRadius: _radius(context, 12),
                    ),
                    child: Text(
                      '${shareText.substring(0, 200)}…',
                      style: theme.textTheme.bodySmall,
                    ),
                  )
                else
                  Container(
                    margin: _spacingOnly(context, bottom: 12),
                    padding: _spacingAll(context, 12),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surfaceContainerHighest,
                      borderRadius: _radius(context, 12),
                    ),
                    child: Text(
                      shareText,
                      style: theme.textTheme.bodySmall,
                    ),
                  ),
                for (final target in targets)
                  ListTile(
                    leading: Icon(
                      _shareIconForTarget(target),
                      color: theme.colorScheme.primary,
                    ),
                    title: Text(_shareLabelForTarget(target, l10n)),
                    subtitle: target.description == null
                        ? null
                        : Text(
                            target.description!,
                            style: theme.textTheme.bodySmall,
                          ),
                    onTap: () => Navigator.pop(context, target),
                  ),
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: () => Navigator.pop(context),
                    child: Text(l10n.t('share_option_cancel')),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
    if (result == null) {
      return;
    }
    await _performShareTarget(
      target: result,
      shareText: shareText,
      threadId: threadId,
      itemId: itemId,
      shareActions: shareActions,
      localizations: l10n,
    );
  }

  String _composeShareText(List<Map<String, Object?>> content) {
    final buffer = StringBuffer();
    for (final part in content) {
      final type = (part['type'] as String?)?.toLowerCase();
      if (type == null || type == 'text' || type == 'paragraph') {
        final text = part['text'] as String?;
        if (text != null && text.trim().isNotEmpty) {
          buffer.writeln(text.trim());
        }
      }
    }
    return buffer.toString().trim();
  }

  List<ShareTargetOption> _resolveShareTargets(
      ShareActionsOption? shareActions) {
    final targets = shareActions?.targets;
    if (targets != null && targets.isNotEmpty) {
      return targets;
    }
    return const [
      ShareTargetOption(
        id: 'copy',
        label: 'copy',
        type: ShareTargetType.copy,
      ),
      ShareTargetOption(
        id: 'system',
        label: 'system',
        type: ShareTargetType.system,
      ),
    ];
  }

  void _applyComposerAvailability(ChatKitComposerAvailabilityEvent event) {
    final retryAt =
        event.retryAfter == null ? null : DateTime.now().add(event.retryAfter!);
    _composerRetryTicker?.cancel();
    if (!mounted) return;
    setState(() {
      if (event.available) {
        _composerEnabled = true;
        _composerDisabledReason = null;
        _composerRetryAt = null;
        if (event.reason == 'auth') {
          _authExpired = false;
        }
      } else {
        _composerEnabled = false;
        _composerDisabledReason = event.reason;
        _composerRetryAt = retryAt;
        if (event.reason == 'auth') {
          _authExpired = true;
        }
        _isDropTargetActive = false;
        _dropDepth = 0;
      }
    });
    if (!event.available && retryAt != null) {
      _composerRetryTicker = Timer.periodic(const Duration(seconds: 1), (_) {
        if (!mounted) {
          _composerRetryTicker?.cancel();
          return;
        }
        if (_composerRetryAt == null ||
            DateTime.now().isAfter(_composerRetryAt!)) {
          _composerRetryTicker?.cancel();
        }
        setState(() {});
      });
    }
    if (event.available) {
      _removeBannersByCode('rate_limit');
    }
  }

  void _enqueueBanner(ChatKitNoticeEvent event) {
    if (!mounted) return;
    final l10n = _localizations;
    final code = event.code;
    String message = event.message.trim().isEmpty
        ? l10n.t('notice_generic_message')
        : event.message.trim();
    String? title = event.title;
    if (code == 'rate_limit') {
      title = l10n.t('notice_rate_limit_title');
      message = l10n.t('notice_rate_limit_message');
    } else if (title == null || title.isEmpty) {
      title = l10n.t('notice_generic_title');
    }
    final retryAt =
        event.retryAfter == null ? null : DateTime.now().add(event.retryAfter!);
    final banner = _BannerMessage(
      id: 'banner-${DateTime.now().microsecondsSinceEpoch}',
      message: message,
      title: title,
      level: event.level,
      code: code,
      retryAt: retryAt,
    );
    setState(() {
      final index = _banners.indexWhere((existing) {
        if (code != null && existing.code == code) {
          return true;
        }
        return existing.message == banner.message &&
            existing.level == banner.level;
      });
      if (index >= 0) {
        final existing = _banners[index];
        _banners = [
          ..._banners.sublist(0, index),
          existing.copyWith(
            message: banner.message,
            title: banner.title,
            retryAt: banner.retryAt,
            level: banner.level,
            code: banner.code ?? existing.code,
          ),
          ..._banners.sublist(index + 1),
        ];
      } else {
        _banners = [..._banners, banner];
      }
    });
  }

  void _removeBannersByCode(String code) {
    if (_banners.every((banner) => banner.code != code)) {
      return;
    }
    setState(() {
      _banners = _banners.where((banner) => banner.code != code).toList();
    });
  }

  void _dismissBanner(String id) {
    setState(() {
      _banners = _banners.where((banner) => banner.id != id).toList();
    });
  }

  String? _formatRetryCountdown(ChatKitLocalizations l10n) {
    final target = _composerRetryAt;
    if (target == null) {
      return null;
    }
    final remaining = target.difference(DateTime.now());
    if (remaining.isNegative) {
      return null;
    }
    final seconds = (remaining.inSeconds + 1).clamp(1, 600);
    return l10n.format('rate_limit_retry_in', {
      'seconds': seconds.toString(),
    });
  }

  String _shareLabelForTarget(
    ShareTargetOption target,
    ChatKitLocalizations l10n,
  ) {
    switch (target.type) {
      case ShareTargetType.copy:
        if (target.label.isNotEmpty && target.label != 'copy') {
          return target.label;
        }
        return l10n.t('share_option_copy');
      case ShareTargetType.system:
        if (target.label.isNotEmpty && target.label != 'system') {
          return target.label;
        }
        return l10n.t('share_option_system');
      case ShareTargetType.custom:
        return target.label;
    }
  }

  IconData _shareIconForTarget(ShareTargetOption target) {
    final iconName = target.icon?.toLowerCase();
    IconData? resolved;
    if (iconName != null && iconName.isNotEmpty) {
      resolved = switch (iconName) {
        'copy' => Icons.copy_all_outlined,
        'share' => Icons.ios_share,
        'link' => Icons.link,
        'mail' || 'email' => Icons.mail_outline,
        'message' || 'sms' => Icons.sms_outlined,
        'notes' => Icons.note_outlined,
        'slack' => Icons.chat_bubble_outline,
        'teams' => Icons.group_work_outlined,
        'download' => Icons.download_outlined,
        _ => null,
      };
    }
    if (resolved != null) {
      return resolved;
    }
    switch (target.type) {
      case ShareTargetType.copy:
        return Icons.copy_all_outlined;
      case ShareTargetType.system:
        return Icons.ios_share;
      case ShareTargetType.custom:
        return Icons.outbond;
    }
  }

  Future<void> _performShareTarget({
    required ShareTargetOption target,
    required String shareText,
    required String threadId,
    required String itemId,
    required ShareActionsOption? shareActions,
    required ChatKitLocalizations localizations,
  }) async {
    switch (target.type) {
      case ShareTargetType.copy:
        await Clipboard.setData(ClipboardData(text: shareText));
        _showShareToast(
          target.toast ??
              shareActions?.copyToast ??
              localizations.t('share_toast_copied'),
        );
        break;
      case ShareTargetType.system:
        await Share.share(shareText);
        _showShareToast(
          target.toast ??
              shareActions?.systemToast ??
              localizations.t('share_toast_shared'),
        );
        break;
      case ShareTargetType.custom:
        final handler = shareActions?.onSelectTarget;
        if (handler != null) {
          await Future.sync(
            () => handler(
              ShareTargetInvocation(
                targetId: target.id,
                itemId: itemId,
                threadId: threadId,
                text: shareText,
              ),
            ),
          );
        }
        final toast = target.toast ?? shareActions?.defaultToast;
        if (toast != null && toast.isNotEmpty) {
          _showShareToast(toast);
        }
        break;
    }
  }

  void _showShareToast(String? message) {
    if (!mounted || message == null || message.isEmpty) {
      return;
    }
    final messenger = ScaffoldMessenger.maybeOf(context);
    if (!_suppressSnackbars && messenger != null) {
      messenger.showSnackBar(
        SnackBar(content: Text(message)),
      );
    }
  }

  _HistorySectionState get _currentHistoryState =>
      _historySections[_activeHistorySection]!;

  List<ThreadMetadata> _filterHistoryThreads(List<ThreadMetadata> threads) {
    final query = _historySearchQuery.trim().toLowerCase();
    if (query.isEmpty) {
      return List<ThreadMetadata>.from(threads);
    }
    return threads.where((thread) {
      final title = thread.title?.toLowerCase() ?? '';
      final metadata = thread.metadata.map(
        (key, value) => MapEntry(key.toLowerCase(), value),
      );
      final keywords = metadata['keywords'];
      final matchesKeywords = keywords is List
          ? keywords
              .whereType<String>()
              .any((keyword) => keyword.toLowerCase().contains(query))
          : false;
      return title.contains(query) ||
          thread.id.toLowerCase().contains(query) ||
          matchesKeywords;
    }).toList(growable: false);
  }

  bool _isThreadPinned(ThreadMetadata thread) {
    final value = thread.metadata['pinned'];
    if (value is bool) return value;
    if (value is num) return value != 0;
    if (value is String) {
      final normalized = value.trim().toLowerCase();
      return normalized == 'true' || normalized == '1' || normalized == 'yes';
    }
    return false;
  }

  List<ThreadMetadata> _mergeHistoryThreads(
    List<ThreadMetadata> existing,
    List<ThreadMetadata> incoming,
  ) {
    if (existing.isEmpty) {
      return List<ThreadMetadata>.from(incoming);
    }
    final merged = List<ThreadMetadata>.from(existing);
    final indexById = <String, int>{};
    for (var i = 0; i < merged.length; i++) {
      indexById[merged[i].id] = i;
    }
    for (final thread in incoming) {
      final index = indexById[thread.id];
      if (index != null) {
        merged[index] = thread;
      } else {
        merged.add(thread);
      }
    }
    return merged;
  }

  Future<void> _refreshHistory({
    _HistorySection? section,
    bool reset = true,
  }) async {
    if (!_historyEnabled) {
      return;
    }
    final targetSection = section ?? _activeHistorySection;
    final stateBefore = _historySections[targetSection]!;
    final shouldReset = reset || !stateBefore.initialized;
    final pendingQuery = _historySearchQuery;
    final requestId = ++_historyRequestId;

    setState(() {
      final updated = stateBefore.copyWith(
        loadingInitial: shouldReset,
        loadingMore: !shouldReset,
        error: null,
        cursor: shouldReset ? null : stateBefore.cursor,
        hasMore: shouldReset ? false : stateBefore.hasMore,
        threads: shouldReset ? const [] : stateBefore.threads,
      );
      _historySections[targetSection] = updated;
    });

    try {
      final page = await controller.listThreads(
        limit: 20,
        after: shouldReset ? null : stateBefore.cursor,
        section: targetSection.metadataValue,
        query: pendingQuery.trim().isEmpty ? null : pendingQuery.trim(),
      );
      if (!mounted || requestId != _historyRequestId) {
        return;
      }
      final baseThreads =
          shouldReset ? const <ThreadMetadata>[] : stateBefore.threads;
      final merged = _mergeHistoryThreads(baseThreads, page.data);
      setState(() {
        _historySections[targetSection] =
            _historySections[targetSection]!.copyWith(
          threads: merged,
          cursor: page.after,
          hasMore: page.hasMore,
          loadingInitial: false,
          loadingMore: false,
          initialized: true,
        );
      });
    } catch (error) {
      if (!mounted || requestId != _historyRequestId) {
        return;
      }
      setState(() {
        _historySections[targetSection] =
            _historySections[targetSection]!.copyWith(
          error: error.toString(),
          loadingInitial: false,
          loadingMore: false,
          hasMore: shouldReset ? false : stateBefore.hasMore,
          cursor: shouldReset ? null : stateBefore.cursor,
          threads: shouldReset ? const [] : stateBefore.threads,
          initialized: true,
        );
      });
    }
  }

  void _toggleHistory() {
    if (!_historyEnabled) return;
    setState(() {
      _historyOpen = !_historyOpen;
    });
    if (_historyOpen) {
      final state = _currentHistoryState;
      if (!state.initialized) {
        _refreshHistory(section: _activeHistorySection, reset: true);
      }
    }
  }

  Future<void> _handleSelectThread(String? threadId) async {
    await controller.setThreadId(threadId);
    if (!mounted) return;
    if (threadId != null) {
      setState(() {
        _historyOpen = false;
      });
    }
  }

  Future<void> _loadMoreHistory() async {
    final state = _currentHistoryState;
    if (!state.hasMore || state.loadingMore || state.loadingInitial) {
      return;
    }
    await _refreshHistory(section: _activeHistorySection, reset: false);
  }

  void _handleHistorySectionChanged(_HistorySection section) {
    if (_activeHistorySection == section) {
      return;
    }
    setState(() {
      _activeHistorySection = section;
    });
    final state = _historySections[section]!;
    if (!state.initialized || _historySearchQuery.isNotEmpty) {
      _refreshHistory(section: section, reset: true);
    }
  }

  void _handleHistorySearchChanged(String value) {
    if (_historySearchQuery == value) {
      return;
    }
    setState(() {
      _historySearchQuery = value;
    });
    _historySearchDebounce?.cancel();
    _historySearchDebounce = Timer(const Duration(milliseconds: 300), () {
      if (!mounted) return;
      _refreshHistory(section: _activeHistorySection, reset: true);
    });
  }

  void _clearHistorySearch() {
    if (_historySearchQuery.isEmpty) {
      return;
    }
    _historySearchDebounce?.cancel();
    setState(() {
      _historySearchQuery = '';
      _historySearchController.value = const TextEditingValue(text: '');
    });
    _refreshHistory(section: _activeHistorySection, reset: true);
  }

  void _handleHistoryScroll() {
    if (!_historyScrollController.hasClients) {
      return;
    }
    final position = _historyScrollController.position;
    if (position.maxScrollExtent - position.pixels <= 120) {
      unawaited(_loadMoreHistory());
    }
  }

  Future<void> _handleDeleteThread(String threadId) async {
    await controller.deleteThread(threadId);
    if (!mounted) return;
    await _refreshHistory();
  }

  Future<void> _handleRenameThread(ThreadMetadata thread) async {
    final textController = TextEditingController(text: thread.title ?? '');
    final newTitle = await showDialog<String>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Rename conversation'),
          content: TextField(
            controller: textController,
            autofocus: true,
            decoration: const InputDecoration(labelText: 'Title'),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            FilledButton(
              onPressed: () =>
                  Navigator.pop(context, textController.text.trim()),
              child: const Text('Save'),
            ),
          ],
        );
      },
    );

    if (newTitle != null && newTitle.isNotEmpty) {
      await this.controller.renameThread(thread.id, newTitle);
      if (mounted) {
        await _refreshHistory();
      }
    }
  }

  Future<void> _openEntityPicker() async {
    final entitiesOption = controller.options.entities;
    final searchFn = entitiesOption?.onTagSearch;
    if (searchFn == null) {
      return;
    }

    final l10n = _localizations;
    final searchController = TextEditingController();
    final searchFocusNode =
        FocusNode(debugLabel: 'chatkit.entityPicker.search');
    final resultsScrollController = ScrollController();
    Timer? searchDebounce;
    List<Entity> results = const [];
    bool loading = false;
    int highlightedIndex = -1;
    int searchRequestId = 0;

    Color _resolveColor(Object? value, Color fallback) {
      if (value is int) {
        return Color(value);
      }
      if (value is String) {
        final cleaned = value.trim().replaceFirst('#', '');
        if (cleaned.length == 6 || cleaned.length == 8) {
          final parsed = int.tryParse(cleaned, radix: 16);
          if (parsed != null) {
            if (cleaned.length == 6) {
              return Color(0xFF000000 | parsed);
            }
            return Color(parsed);
          }
        }
      }
      return fallback;
    }

    Widget? buildBadge(Entity entity, ThemeData theme) {
      final badge = entity.data['badge'];
      if (badge is String) {
        final text = badge.trim();
        if (text.isEmpty) return null;
        return _EntityBadge(
          label: text,
          background: theme.colorScheme.secondaryContainer,
          foreground: theme.colorScheme.onSecondaryContainer,
        );
      }
      if (badge is Map) {
        final label = (badge['label'] ?? badge['text']) as String?;
        if (label == null || label.trim().isEmpty) {
          return null;
        }
        final background = _resolveColor(
          badge['background'] ?? badge['color'],
          theme.colorScheme.secondaryContainer,
        );
        final foreground = _resolveColor(
          badge['foreground'] ?? badge['textColor'],
          theme.colorScheme.onSecondaryContainer,
        );
        return _EntityBadge(
          label: label.trim(),
          background: background,
          foreground: foreground,
        );
      }
      return null;
    }

    Widget buildAvatar(Entity entity, ThemeData theme) {
      final icon = entity.icon;
      if (icon != null && icon.trim().isNotEmpty && icon.contains('://')) {
        return CircleAvatar(
          radius: 18,
          backgroundImage: CachedNetworkImageProvider(icon),
          backgroundColor: theme.colorScheme.surfaceContainerHighest,
        );
      }
      final label = entity.title.trim();
      final initial =
          label.isNotEmpty ? label.substring(0, 1).toUpperCase() : '@';
      return CircleAvatar(
        radius: 18,
        backgroundColor: theme.colorScheme.surfaceContainerHighest,
        child: Text(
          initial,
          style: theme.textTheme.titleSmall?.copyWith(
            fontWeight: FontWeight.w600,
            color: theme.colorScheme.onSurface,
          ),
        ),
      );
    }

    void ensureHighlightedVisible(int index) {
      if (!resultsScrollController.hasClients || index < 0) {
        return;
      }
      const itemExtent = 68.0;
      final targetOffset = index * itemExtent;
      final currentOffset = resultsScrollController.position.pixels;
      final viewportExtent = resultsScrollController.position.viewportDimension;
      final maxOffset = currentOffset + viewportExtent;
      if (targetOffset < currentOffset) {
        resultsScrollController.animateTo(
          targetOffset,
          duration: const Duration(milliseconds: 180),
          curve: Curves.easeOut,
        );
      } else if (targetOffset + itemExtent > maxOffset) {
        final offset = targetOffset - (viewportExtent - itemExtent);
        resultsScrollController.animateTo(
          offset.clamp(
            0.0,
            resultsScrollController.position.maxScrollExtent,
          ),
          duration: const Duration(milliseconds: 180),
          curve: Curves.easeOut,
        );
      }
    }

    Future<void> runSearch(
      void Function(void Function()) setModalState,
    ) async {
      final query = searchController.text.trim();
      if (query.isEmpty) {
        setModalState(() {
          results = const [];
          loading = false;
          highlightedIndex = -1;
        });
        return;
      }
      final requestId = ++searchRequestId;
      setModalState(() {
        loading = true;
      });
      try {
        final fetched = await Future<List<Entity>>.value(searchFn(query));
        if (requestId != searchRequestId) {
          return;
        }
        final selectedIds = _selectedTags.map((tag) => tag.id).toSet();
        final filtered = fetched
            .where((entity) => !selectedIds.contains(entity.id))
            .toList();
        setModalState(() {
          results = filtered;
          loading = false;
          highlightedIndex = filtered.isNotEmpty ? 0 : -1;
        });
        if (filtered.isNotEmpty) {
          ensureHighlightedVisible(0);
        }
      } catch (_) {
        if (requestId != searchRequestId) {
          return;
        }
        setModalState(() {
          loading = false;
          results = const [];
          highlightedIndex = -1;
        });
      }
    }

    KeyEventResult handleSearchKey(
      KeyEvent event,
      void Function(void Function()) setModalState,
    ) {
      if (event is! KeyDownEvent) {
        return KeyEventResult.ignored;
      }
      final key = event.logicalKey;
      if (key == LogicalKeyboardKey.arrowDown && results.isNotEmpty) {
        setModalState(() {
          if (highlightedIndex < 0) {
            highlightedIndex = 0;
          } else {
            highlightedIndex =
                math.min(highlightedIndex + 1, results.length - 1);
          }
        });
        if (highlightedIndex >= 0) {
          ensureHighlightedVisible(highlightedIndex);
        }
        return KeyEventResult.handled;
      }
      if (key == LogicalKeyboardKey.arrowUp && results.isNotEmpty) {
        setModalState(() {
          if (highlightedIndex <= 0) {
            highlightedIndex = 0;
          } else {
            highlightedIndex = math.max(0, highlightedIndex - 1);
          }
        });
        if (highlightedIndex >= 0) {
          ensureHighlightedVisible(highlightedIndex);
        }
        return KeyEventResult.handled;
      }
      if ((key == LogicalKeyboardKey.enter ||
              key == LogicalKeyboardKey.numpadEnter) &&
          highlightedIndex >= 0 &&
          highlightedIndex < results.length) {
        Navigator.pop(context, results[highlightedIndex]);
        return KeyEventResult.handled;
      }
      if (key == LogicalKeyboardKey.escape) {
        Navigator.pop(context);
        return KeyEventResult.handled;
      }
      return KeyEventResult.ignored;
    }

    Entity? selectedEntity;
    try {
      selectedEntity = await showDialog<Entity>(
        context: context,
        builder: (context) {
          return StatefulBuilder(
            builder: (context, setModalState) {
              searchFocusNode.onKeyEvent =
                  (node, event) => handleSearchKey(event, setModalState);
              final theme = Theme.of(context);
              return AlertDialog(
                title: Text(l10n.t('entity_picker_title')),
                content: SizedBox(
                  width: 380,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      TextField(
                        controller: searchController,
                        focusNode: searchFocusNode,
                        autofocus: true,
                        decoration: InputDecoration(
                          prefixIcon: const Icon(Icons.search),
                          hintText: l10n.t('entity_picker_search_hint'),
                          suffixIcon: searchController.text.isEmpty
                              ? null
                              : IconButton(
                                  icon: const Icon(Icons.clear),
                                  onPressed: () {
                                    searchController.clear();
                                    searchDebounce?.cancel();
                                    setModalState(() {
                                      results = const [];
                                      highlightedIndex = -1;
                                    });
                                  },
                                ),
                        ),
                        onChanged: (value) {
                          setModalState(() {});
                          searchDebounce?.cancel();
                          searchDebounce = Timer(
                            const Duration(milliseconds: 200),
                            () => runSearch(setModalState),
                          );
                        },
                        onSubmitted: (_) => runSearch(setModalState),
                      ),
                      SizedBox(height: _spacingValue(context, 12)),
                      if (loading)
                        const Padding(
                          padding: EdgeInsets.all(16),
                          child: CircularProgressIndicator(),
                        )
                      else
                        SizedBox(
                          width: double.infinity,
                          height: 260,
                          child: results.isEmpty
                              ? Center(
                                  child:
                                      Text(l10n.t('entity_picker_no_results')),
                                )
                              : ListView.builder(
                                  controller: resultsScrollController,
                                  itemCount: results.length,
                                  itemBuilder: (context, index) {
                                    final entity = results[index];
                                    final selected = highlightedIndex == index;
                                    final badge = buildBadge(entity, theme);
                                    final description =
                                        entity.data['description'] as String?;
                                    return MouseRegion(
                                      onEnter: (_) {
                                        setModalState(() {
                                          highlightedIndex = index;
                                        });
                                        ensureHighlightedVisible(index);
                                      },
                                      child: Tooltip(
                                        message: (description ?? entity.title)
                                            .trim(),
                                        waitDuration:
                                            const Duration(milliseconds: 400),
                                        child: ListTile(
                                          contentPadding: _spacingSymmetric(
                                              context,
                                              horizontal: 12,
                                              vertical: 8),
                                          leading: buildAvatar(entity, theme),
                                          selected: selected,
                                          selectedTileColor: theme
                                              .colorScheme.primary
                                              .withValues(alpha: 0.08),
                                          title: Text(entity.title),
                                          subtitle: description != null
                                              ? Text(description)
                                              : null,
                                          onTap: () =>
                                              Navigator.pop(context, entity),
                                          trailing: badge == null &&
                                                  entitiesOption
                                                          ?.onRequestPreview ==
                                                      null
                                              ? null
                                              : Row(
                                                  mainAxisSize:
                                                      MainAxisSize.min,
                                                  children: [
                                                    if (badge != null) badge,
                                                    if (entitiesOption
                                                            ?.onRequestPreview !=
                                                        null)
                                                      IconButton(
                                                        icon: const Icon(
                                                          Icons.remove_red_eye,
                                                        ),
                                                        tooltip: l10n.t(
                                                            'entity_picker_preview'),
                                                        onPressed: () async {
                                                          await _handleTagPreview(
                                                              entity);
                                                        },
                                                      ),
                                                  ],
                                                ),
                                        ),
                                      ),
                                    );
                                  },
                                ),
                        ),
                    ],
                  ),
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.pop(context),
                    child: Text(l10n.t('entity_picker_close')),
                  ),
                  FilledButton(
                    onPressed: loading ? null : () => runSearch(setModalState),
                    child: Text(l10n.t('entity_picker_search_button')),
                  ),
                ],
              );
            },
          );
        },
      );
    } finally {
      searchDebounce?.cancel();
      searchController.dispose();
      searchFocusNode.dispose();
      resultsScrollController.dispose();
    }

    final entity = selectedEntity;
    if (entity != null) {
      if (_selectedTags.any((tag) => tag.id == entity.id)) {
        return;
      }
      setState(() {
        _selectedTags = [..._selectedTags, entity];
      });
      _syncTagFocusNodes();
      controller.setComposerValue(tags: _selectedTags);
      _focusComposer(atEnd: false);
    }
  }

  void _reorderTag(Entity entity, int offset) {
    final currentIndex = _selectedTags.indexWhere((tag) => tag.id == entity.id);
    if (currentIndex == -1 || offset == 0) {
      return;
    }
    final maxIndex = _selectedTags.isEmpty ? 0 : _selectedTags.length - 1;
    final newIndex = (currentIndex + offset).clamp(0, maxIndex).toInt();
    if (newIndex == currentIndex) {
      return;
    }
    setState(() {
      final updated = List<Entity>.from(_selectedTags);
      final moved = updated.removeAt(currentIndex);
      updated.insert(newIndex, moved);
      _selectedTags = updated;
    });
    _syncTagFocusNodes();
    controller.setComposerValue(tags: _selectedTags);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _focusTagChipAt(newIndex);
    });
  }

  void _removeTag(Entity entity) {
    setState(() {
      _selectedTags =
          _selectedTags.where((tag) => tag.id != entity.id).toList();
    });
    _syncTagFocusNodes();
    controller.setComposerValue(tags: _selectedTags);
  }

  void _handleTagTap(Entity entity) {
    final previewFn = controller.options.entities?.onRequestPreview;
    if (previewFn != null) {
      unawaited(_handleTagPreview(entity));
    }
    controller.options.entities?.onClick?.call(entity);
  }

  Future<void> _handleTagPreview(Entity entity) async {
    final previewFn = controller.options.entities?.onRequestPreview;
    if (previewFn == null) {
      return;
    }
    final preview = await Future<EntityPreview?>.value(previewFn(entity));
    if (preview?.preview == null || !mounted) {
      return;
    }
    final widgetJson = preview!.preview!;
    final previewItem = ThreadItem(
      id: 'preview',
      threadId: controller.currentThreadId ?? 'preview',
      createdAt: DateTime.now(),
      type: 'widget',
      content: const [],
      attachments: const [],
      metadata: const {},
      raw: {'widget': widgetJson},
    );
    await showDialog<void>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(entity.title),
          content: SizedBox(
            width: 360,
            child: ChatKitWidgetRenderer(
              widgetJson: widgetJson,
              controller: controller,
              item: previewItem,
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }

  void _handleToolChanged(String? toolId) {
    setState(() {
      _selectedToolId = toolId;
    });
    controller.setComposerValue(selectedToolId: toolId, tags: _selectedTags);
  }

  void _handleModelChanged(String? modelId) {
    setState(() {
      _selectedModelId = modelId;
    });
    controller.setComposerValue(selectedModelId: modelId, tags: _selectedTags);
  }

  bool _shouldDisplayItem(ThreadItem item) {
    if (!widget.hideHiddenItems) {
      return true;
    }
    if (item.type == 'hidden_context') {
      return false;
    }
    if (item.type == 'workflow') {
      return false;
    }
    return true;
  }

  List<ThreadItem> _applyItemFilter(List<ThreadItem> items) {
    if (!widget.hideHiddenItems) {
      return items;
    }
    return items.where(_shouldDisplayItem).toList(growable: false);
  }

  void _upsertItem(ThreadItem item) {
    if (!_shouldDisplayItem(item)) {
      if (_items.any((element) => element.id == item.id)) {
        _items = _items.where((element) => element.id != item.id).toList();
      }
      return;
    }
    final index = _items.indexWhere((element) => element.id == item.id);
    if (index == -1) {
      _items = [..._items, item]
        ..sort((a, b) => a.createdAt.compareTo(b.createdAt));
    } else {
      final updated = [..._items];
      updated[index] = item;
      _items = updated;
    }
  }

  @visibleForTesting
  List<ThreadItem> debugVisibleItems() => List.unmodifiable(_items);

  Future<void> _handleSend() async {
    if (_isStreaming || !_composerEnabled || _authExpired) return;
    final text = _composerController.text.trim();
    if (text.isEmpty && _attachments.isEmpty) {
      return;
    }
    try {
      await controller.sendUserMessage(
        text: text,
        attachments: _attachments.map((a) => a.toJson()).toList(),
        tags: _selectedTags,
      );
      _attachments = const [];
      _selectedTags = const [];
      _syncComposerState();
    } catch (error) {
      if (!mounted) return;
      final messenger = ScaffoldMessenger.maybeOf(context);
      if (!_suppressSnackbars && messenger != null) {
        messenger.showSnackBar(
          SnackBar(content: Text('Failed to send message: $error')),
        );
      }
    }
  }

  void _syncComposerState() {
    controller.setComposerValue(
      attachments: _attachments.map((a) => a.toJson()).toList(),
      tags: _selectedTags,
    );
  }

  Future<void> _handleAttachment() async {
    if (!_composerEnabled || _authExpired) {
      return;
    }
    final options = controller.options.composer?.attachments;
    if (options == null || !options.enabled) {
      return;
    }
    final l10n = _localizations;
    try {
      final allowMultiple = options.maxCount == null || options.maxCount! > 1;
      final result = await FilePicker.platform.pickFiles(
        allowMultiple: allowMultiple,
        withData: true,
        type: FileType.any,
        allowedExtensions: options.accept?.values.expand((e) => e).toList(),
      );
      if (result == null || result.files.isEmpty) {
        return;
      }

      final payloads = <_AttachmentPayload>[];
      for (final file in result.files) {
        final bytes = file.bytes;
        if (bytes == null) {
          if (!mounted) continue;
          final messenger = ScaffoldMessenger.maybeOf(context);
          if (!_suppressSnackbars && messenger != null) {
            messenger.showSnackBar(
              SnackBar(
                content: Text(
                  '${file.name}: ${l10n.t('attachment_pick_failed')}',
                ),
              ),
            );
          }
          continue;
        }
        final header = bytes.length >= 12 ? bytes.sublist(0, 12) : bytes;
        final mimeType = lookupMimeType(
              file.name,
              headerBytes: header,
            ) ??
            'application/octet-stream';
        final size = file.size > 0 ? file.size : bytes.length;
        payloads.add(
          _AttachmentPayload(
            name: file.name,
            bytes: Uint8List.fromList(bytes),
            mimeType: mimeType,
            size: size,
          ),
        );
      }
      if (payloads.isEmpty) {
        return;
      }
      await _ingestAttachmentPayloads(payloads, options: options);
    } catch (error) {
      if (!mounted) return;
      final messenger = ScaffoldMessenger.maybeOf(context);
      if (!_suppressSnackbars && messenger != null) {
        messenger.showSnackBar(
          SnackBar(
            content: Text('${l10n.t('attachment_pick_failed')} $error'),
          ),
        );
      }
    }
  }

  Future<void> _handleDroppedFiles(List<XFile> files) async {
    final options = controller.options.composer?.attachments;
    if (options == null || !options.enabled || files.isEmpty) {
      return;
    }
    final l10n = _localizations;
    final payloads = <_AttachmentPayload>[];
    for (final file in files) {
      try {
        final bytes = await file.readAsBytes();
        final header = bytes.length >= 12 ? bytes.sublist(0, 12) : bytes;
        final mimeType = (file.mimeType ??
                lookupMimeType(
                  file.name,
                  headerBytes: header,
                )) ??
            'application/octet-stream';
        final name = file.name.isEmpty ? 'attachment' : file.name;
        payloads.add(
          _AttachmentPayload(
            name: name,
            bytes: bytes,
            mimeType: mimeType,
            size: bytes.length,
          ),
        );
      } on Object catch (error) {
        if (!mounted) continue;
        final name = file.name.isEmpty ? 'attachment' : file.name;
        final messenger = ScaffoldMessenger.maybeOf(context);
        if (!_suppressSnackbars && messenger != null) {
          messenger.showSnackBar(
            SnackBar(
              content: Text(
                '$name: ${l10n.t('attachment_pick_failed')} $error',
              ),
            ),
          );
        }
      }
    }
    if (payloads.isEmpty) {
      return;
    }
    await _ingestAttachmentPayloads(payloads, options: options);
  }

  Future<void> _ingestAttachmentPayloads(
    List<_AttachmentPayload> payloads, {
    required ComposerAttachmentOption options,
  }) async {
    if (payloads.isEmpty) {
      return;
    }
    final l10n = _localizations;
    final activePending = _pendingUploads
        .where((upload) => !upload.cancelled && !upload.hasError)
        .length;
    final currentCount = _attachments.length + activePending;
    int? availableSlots = options.maxCount == null
        ? null
        : math.max(0, options.maxCount! - currentCount);
    final accepted = <_AttachmentPayload>[];
    final rejections = <_FileRejection>[];

    for (final payload in payloads) {
      if (availableSlots != null && availableSlots <= 0) {
        rejections.add(
          _FileRejection(
            name: payload.name,
            type: _RejectionType.limit,
          ),
        );
        continue;
      }
      final rejection = _validateAttachmentPayload(payload, options);
      if (rejection != null) {
        rejections.add(rejection);
        continue;
      }
      accepted.add(payload);
      if (availableSlots != null) {
        availableSlots -= 1;
      }
    }

    if (rejections.isNotEmpty && mounted) {
      final message = _buildRejectionMessage(rejections, l10n);
      final messenger = ScaffoldMessenger.maybeOf(context);
      if (!_suppressSnackbars && messenger != null) {
        messenger.showSnackBar(
          SnackBar(content: Text(message)),
        );
      }
    }

    for (final payload in accepted) {
      final upload = _PendingUpload(
        id: UniqueKey().toString(),
        name: payload.name,
        mimeType: payload.mimeType,
        size: payload.size,
        bytes: payload.bytes,
      );
      await _runUpload(upload);
      if (!mounted) {
        return;
      }
    }
  }

  _FileRejection? _validateAttachmentPayload(
    _AttachmentPayload payload,
    ComposerAttachmentOption options,
  ) {
    final maxSize = options.maxSize;
    if (maxSize != null && payload.size > maxSize) {
      return _FileRejection(
        name: payload.name,
        type: _RejectionType.size,
        detail: _formatBytes(maxSize),
      );
    }
    final accept = options.accept;
    if (accept != null && accept.isNotEmpty) {
      if (!_matchesAccept(payload, accept)) {
        return _FileRejection(
          name: payload.name,
          type: _RejectionType.type,
        );
      }
    }
    return null;
  }

  bool _matchesAccept(
    _AttachmentPayload payload,
    Map<String, List<String>> accept,
  ) {
    if (accept.isEmpty) {
      return true;
    }
    final mime = payload.mimeType.toLowerCase();
    final extension = _extensionFromName(payload.name)?.toLowerCase();

    for (final entry in accept.entries) {
      final pattern = entry.key.toLowerCase();
      if (pattern == '*/*') {
        return true;
      }
      if (pattern.endsWith('/*')) {
        final prefix = pattern.split('/').first;
        if (mime.startsWith('$prefix/')) {
          return true;
        }
      } else if (pattern.isNotEmpty && mime == pattern) {
        return true;
      }
      for (final ext in entry.value) {
        final normalized = ext.toLowerCase().replaceAll('.', '');
        if (normalized.isEmpty) {
          continue;
        }
        if (extension == normalized) {
          return true;
        }
      }
    }
    return false;
  }

  String _buildRejectionMessage(
    List<_FileRejection> rejections,
    ChatKitLocalizations l10n,
  ) {
    final primary = rejections.first;
    final reason = _describeRejection(primary, l10n);
    if (rejections.length == 1) {
      return '${primary.name}: $reason';
    }
    return '${l10n.t('attachment_rejected_multiple')} (${rejections.length}) $reason';
  }

  String _describeRejection(
    _FileRejection rejection,
    ChatKitLocalizations l10n,
  ) {
    switch (rejection.type) {
      case _RejectionType.limit:
        return l10n.t('attachment_limit_reached');
      case _RejectionType.type:
        return l10n.t('attachment_rejected_type');
      case _RejectionType.size:
        final base = l10n.t('attachment_rejected_size');
        if (rejection.detail != null && rejection.detail!.isNotEmpty) {
          return '$base (${rejection.detail})';
        }
        return base;
    }
  }

  Future<void> _runUpload(
    _PendingUpload upload, {
    bool isRetry = false,
  }) async {
    final l10n = _localizations;
    if (!mounted) {
      return;
    }

    setState(() {
      if (!isRetry) {
        _pendingUploads = [..._pendingUploads, upload];
      }
      upload
        ..error = null
        ..cancelled = false
        ..inFlight = true
        ..sent = 0
        ..total = upload.size;
      _updateUploadingStatus();
    });

    ChatKitAttachment? attachment;
    Object? error;

    try {
      attachment = await controller.registerAttachment(
        name: upload.name,
        bytes: upload.bytes,
        mimeType: upload.mimeType,
        size: upload.size,
        onProgress: (sent, total) {
          if (!mounted) {
            return;
          }
          setState(() {
            upload.sent = sent;
            upload.total = total;
          });
        },
        isCancelled: () => upload.cancelled,
      );
    } on Object catch (err) {
      if (!upload.cancelled) {
        error = err;
      }
    }

    if (!mounted) {
      return;
    }

    if (upload.cancelled) {
      setState(() {
        upload.inFlight = false;
        _pendingUploads =
            _pendingUploads.where((item) => item != upload).toList();
        _updateUploadingStatus();
      });
      return;
    }

    if (error != null || attachment == null) {
      final errorText = error?.toString();
      setState(() {
        upload.error = error ?? Exception('upload_failed');
        upload.inFlight = false;
        _updateUploadingStatus();
      });
      if (mounted) {
        final message = errorText == null || errorText.isEmpty
            ? l10n.t('attachment_upload_failed')
            : '${l10n.t('attachment_upload_failed')} $errorText';
        final messenger = ScaffoldMessenger.maybeOf(context);
        if (!_suppressSnackbars && messenger != null) {
          messenger.showSnackBar(
            SnackBar(content: Text(message)),
          );
        }
      }
      return;
    }

    final resolved = _ensureAttachmentSize(attachment, upload.size);
    setState(() {
      upload.inFlight = false;
      _pendingUploads =
          _pendingUploads.where((item) => item != upload).toList();
      _updateUploadingStatus();
      _attachments = [..._attachments, resolved];
    });
    _syncComposerState();
  }

  @visibleForTesting
  Future<void> debugAddAttachment({
    required String name,
    required Uint8List bytes,
    required String mimeType,
    int? size,
    ComposerAttachmentOption options = const ComposerAttachmentOption(
      enabled: true,
    ),
  }) {
    return _ingestAttachmentPayloads(
      [
        _AttachmentPayload(
          name: name,
          bytes: bytes,
          mimeType: mimeType,
          size: size ?? bytes.length,
        ),
      ],
      options: options,
    );
  }

  @visibleForTesting
  Future<void> debugPerformShareTarget({
    required ShareTargetOption target,
    required String shareText,
    ShareActionsOption? shareActions,
  }) {
    return _performShareTarget(
      target: target,
      shareText: shareText,
      threadId: 'debug_thread',
      itemId: 'debug_item',
      shareActions: shareActions,
      localizations: _localizations,
    );
  }

  @visibleForTesting
  Future<void> debugRetryUpload(_PendingUpload upload) {
    return _retryUpload(upload);
  }

  @visibleForTesting
  List<_PendingUpload> get debugPendingUploads => _pendingUploads;

  @visibleForTesting
  set debugSuppressSnackbars(bool value) => _suppressSnackbars = value;

  void _updateUploadingStatus() {
    _isUploading =
        _pendingUploads.any((upload) => upload.inFlight && !upload.cancelled);
  }

  Future<void> _retryUpload(_PendingUpload upload) async {
    if (upload.inFlight) {
      return;
    }
    await _runUpload(upload, isRetry: true);
  }

  void _removeUpload(_PendingUpload upload) {
    setState(() {
      _pendingUploads =
          _pendingUploads.where((item) => item != upload).toList();
      _updateUploadingStatus();
    });
  }

  void _handleDropEnter() {
    _dropDepth += 1;
    _activateDropOverlay();
  }

  void _handleDropExit() {
    _dropDepth = math.max(0, _dropDepth - 1);
    if (_dropDepth == 0) {
      _deactivateDropOverlay();
    }
  }

  void _activateDropOverlay() {
    if (_isDropTargetActive) {
      return;
    }
    setState(() {
      _isDropTargetActive = true;
    });
  }

  void _deactivateDropOverlay() {
    if (!_isDropTargetActive) {
      return;
    }
    setState(() {
      _isDropTargetActive = false;
    });
  }

  void _cancelUpload(_PendingUpload upload) {
    setState(() {
      upload.cancelled = true;
      _pendingUploads =
          _pendingUploads.where((item) => item != upload).toList();
      _updateUploadingStatus();
    });
  }

  void _scheduleScrollToBottom({int retries = 1}) {
    if (!mounted) {
      return;
    }

    void attempt(int remaining) {
      if (remaining <= 0 || !mounted) {
        return;
      }
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) {
          return;
        }
        if (!_scrollController.hasClients) {
          attempt(remaining - 1);
          return;
        }
        final position = _scrollController.position;
        if (!position.hasPixels) {
          attempt(remaining - 1);
          return;
        }
        final maxExtent = position.maxScrollExtent;
        final delta = maxExtent - position.pixels;
        if (delta.abs() < 4) {
          if (remaining > 1) {
            attempt(remaining - 1);
          }
          return;
        }
        try {
          if (delta > 512) {
            _scrollController.jumpTo(maxExtent);
            if (remaining > 1) {
              attempt(remaining - 1);
            }
          } else {
            final future = _scrollController.animateTo(
              maxExtent,
              duration: const Duration(milliseconds: 250),
              curve: Curves.easeOut,
            );
            if (remaining > 1) {
              future.catchError((_) {}).whenComplete(() {
                if (mounted) {
                  attempt(remaining - 1);
                }
              });
            }
          }
        } on Exception {
          if (remaining > 1) {
            attempt(remaining - 1);
          }
        }
      });
    }

    attempt(math.max(1, retries));
  }

  Widget _wrapWithChatKitTheme(BuildContext context, Widget child) {
    final baseTheme = Theme.of(context);
    final brightness =
        MediaQuery.maybeOf(context)?.platformBrightness ?? baseTheme.brightness;
    final chatTheme = ChatKitThemeData.fromOptions(
      base: baseTheme,
      option: controller.options.resolvedTheme,
      platformBrightness: brightness,
    );
    return ChatKitTheme(
      data: chatTheme,
      child: Theme(
        data: chatTheme.materialTheme,
        child: child,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    _ensureLocaleBundle();
    final theme = Theme.of(context);
    final l10n = _localizations;
    final composerOptions = controller.options.composer;
    final toolOptions = composerOptions?.tools ?? const <ToolOption>[];
    final modelOptions = composerOptions?.models ?? const <ModelOption>[];
    final selectedTool = toolOptions.firstWhereOrNull(
      (tool) => tool.id == _selectedToolId,
    );
    final effectiveModelId = _selectedModelId ??
        modelOptions.firstWhereOrNull((m) => m.defaultSelected)?.id;
    var placeholder = selectedTool?.placeholderOverride ??
        composerOptions?.placeholder ??
        l10n.t('composer_input_placeholder');

    final composerLockReason = _authExpired
        ? 'auth'
        : (_composerEnabled ? null : _composerDisabledReason);
    final composerLocked = composerLockReason != null;
    String? lockMessage;
    if (composerLockReason == 'auth') {
      lockMessage = l10n.t('composer_disabled_auth');
      placeholder = l10n.t('composer_disabled_auth');
    } else if (composerLockReason == 'rate_limit') {
      final baseMessage = l10n.t('composer_disabled_rate_limit');
      final countdown = _formatRetryCountdown(l10n);
      lockMessage = countdown == null ? baseMessage : '$baseMessage $countdown';
      placeholder = baseMessage;
    }

    final composerBusy = _isStreaming || _isUploading;
    final composerBase = _Composer(
      composerController: _composerController,
      focusNode: _composerFocusNode,
      onSend: _handleSend,
      onAttachment:
          _attachmentsEnabled && !composerLocked ? _handleAttachment : null,
      attachments: _attachments,
      pendingUploads: _pendingUploads,
      onRemoveAttachment: (attachment) {
        setState(() {
          _attachments =
              _attachments.where((a) => a.id != attachment.id).toList();
        });
        _syncComposerState();
      },
      onTextChanged: _handleComposerChanged,
      onAddTag: _canAddEntities ? _openEntityPicker : null,
      onRemoveTag: _removeTag,
      onTapTag: _handleTagTap,
      onPreviewTag: _handleTagPreview,
      tags: _selectedTags,
      tools: toolOptions.isEmpty ? null : toolOptions,
      models: modelOptions.isEmpty ? null : modelOptions,
      selectedToolId: _selectedToolId,
      selectedModelId: effectiveModelId,
      onToolChanged: _handleToolChanged,
      onModelChanged: _handleModelChanged,
      localizations: l10n,
      placeholder: placeholder,
      isStreaming: composerBusy,
      isComposerLocked: composerLocked,
      lockMessage: lockMessage,
      onCancelUpload: _cancelUpload,
      onRetryUpload: _retryUpload,
      onRemoveFailedUpload: _removeUpload,
      composerFieldLink: _composerFieldLink,
      tagFocusNodes: _tagFocusNodes,
      tagTooltipBuilder: _entityTooltip,
      tagAvatarBuilder: _entityAvatar,
    );

    final allowAttachments = _attachmentsEnabled && !composerLocked;
    final composerSection = !allowAttachments
        ? composerBase
        : DropTarget(
            onDragEntered: (_) => _handleDropEnter(),
            onDragUpdated: (_) => _activateDropOverlay(),
            onDragExited: (_) => _handleDropExit(),
            onDragDone: (details) async {
              _dropDepth = 0;
              _deactivateDropOverlay();
              await _handleDroppedFiles(details.files);
            },
            child: Stack(
              fit: StackFit.passthrough,
              children: [
                composerBase,
                Positioned.fill(
                  child: IgnorePointer(
                    child: AnimatedOpacity(
                      opacity: _isDropTargetActive ? 1 : 0,
                      duration: const Duration(milliseconds: 150),
                      child: Padding(
                        padding: _spacingSymmetric(
                          context,
                          horizontal: 12,
                          vertical: 8,
                        ),
                        child: DecoratedBox(
                          decoration: BoxDecoration(
                            borderRadius: _radius(context, 16),
                            border: Border.all(
                              color: theme.colorScheme.primary,
                              width: 2,
                            ),
                            color: theme.colorScheme.primary
                                .withValues(alpha: 0.08),
                          ),
                          child: Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  Icons.cloud_upload_outlined,
                                  size: 36,
                                  color: theme.colorScheme.primary,
                                ),
                                SizedBox(height: _spacingValue(context, 12)),
                                Text(
                                  l10n.t('attachment_drop_prompt'),
                                  style: theme.textTheme.titleMedium?.copyWith(
                                    color: theme.colorScheme.primary,
                                    fontWeight: FontWeight.w600,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );

    final column = Column(
      children: [
        if (_authExpired)
          _AuthExpiredBanner(
            localizations: l10n,
            onDismiss: () => setState(() => _authExpired = false),
          ),
        if (controller.options.header?.enabled ?? true)
          _ChatHeader(
            thread: _thread,
            options: controller.options.header,
            historyEnabled: _historyEnabled,
            isHistoryOpen: _historyOpen,
            onToggleHistory: _historyEnabled ? _toggleHistory : null,
            localizations: l10n,
          ),
        Expanded(
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: theme.colorScheme.surface,
            ),
            child: _items.isEmpty
                ? _StartScreen(options: controller.options.startScreen)
                : ListView.builder(
                    controller: _scrollController,
                    padding: _spacingSymmetric(context,
                        horizontal: 16, vertical: 12),
                    itemCount: _items.length,
                    itemBuilder: (context, index) {
                      final item = _items[index];
                      return _ChatItemView(
                        key: ValueKey(item.id),
                        item: item,
                        controller: controller,
                        actions: controller.options.threadItemActions,
                        localizations: l10n,
                      );
                    },
                  ),
          ),
        ),
        if (controller.options.disclaimer != null)
          Padding(
            padding: _spacingSymmetric(context, horizontal: 16, vertical: 4),
            child: Builder(
              builder: (context) {
                final disclaimer = controller.options.disclaimer!;
                final baseColor = theme.textTheme.bodySmall?.color ??
                    theme.colorScheme.onSurface;
                final textColor = disclaimer.highContrast == true
                    ? theme.colorScheme.onSurface
                    : baseColor.withValues(alpha: 0.7);
                return Text(
                  disclaimer.text,
                  style: theme.textTheme.bodySmall?.copyWith(color: textColor),
                );
              },
            ),
          ),
        if (_banners.isNotEmpty)
          Padding(
            padding: _spacingFromLTRB(context, 16, 4, 16, 8),
            child: Column(
              children: [
                for (final banner in _banners)
                  Padding(
                    padding: _spacingOnly(context, bottom: 8),
                    child: _NoticeBanner(
                      banner: banner,
                      localizations: l10n,
                      onClose: () => _dismissBanner(banner.id),
                    ),
                  ),
              ],
            ),
          ),
        composerSection,
      ],
    );

    final historyState = _currentHistoryState;
    final visibleThreads = _filterHistoryThreads(historyState.threads);
    final pinnedThreads = <ThreadMetadata>[];
    final otherThreads = <ThreadMetadata>[];
    for (final thread in visibleThreads) {
      if (_isThreadPinned(thread)) {
        pinnedThreads.add(thread);
      } else {
        otherThreads.add(thread);
      }
    }
    final historyPanelWidget = _HistoryPanel(
      localizations: l10n,
      section: _activeHistorySection,
      onSectionChanged: _handleHistorySectionChanged,
      searchController: _historySearchController,
      onSearchChanged: _handleHistorySearchChanged,
      onSearchCleared: _clearHistorySearch,
      pinnedThreads: pinnedThreads,
      threads: otherThreads,
      loadingInitial: historyState.loadingInitial,
      loadingMore: historyState.loadingMore,
      error: historyState.error,
      onRefresh: () => _refreshHistory(
        section: _activeHistorySection,
        reset: true,
      ),
      onSelect: _handleSelectThread,
      onDelete: controller.options.history?.showDelete == true
          ? _handleDeleteThread
          : null,
      onRename: controller.options.history?.showRename == true
          ? _handleRenameThread
          : null,
      currentThreadId: controller.currentThreadId,
      hasMore: historyState.hasMore,
      scrollController: _historyScrollController,
      onLoadMore: historyState.hasMore ? _loadMoreHistory : null,
    );

    final layoutSize = _layoutSizeOf(context);
    Widget mainArea;
    if (layoutSize == _LayoutSize.compact) {
      final historyHeight = math.min(
        MediaQuery.of(context).size.height * 0.5,
        420.0,
      );
      mainArea = Column(
        children: [
          if (_historyEnabled && _historyOpen)
            SizedBox(
              height: historyHeight,
              child: historyPanelWidget,
            ),
          Expanded(child: column),
        ],
      );
    } else {
      final historyWidth = layoutSize == _LayoutSize.medium ? 280.0 : 320.0;
      mainArea = Row(
        children: [
          if (_historyEnabled && _historyOpen)
            SizedBox(
              width: historyWidth,
              child: historyPanelWidget,
            ),
          Expanded(child: column),
        ],
      );
    }

    return _wrapWithChatKitTheme(
      context,
      mainArea,
    );
  }
}

class _ChatHeader extends StatelessWidget {
  const _ChatHeader({
    required this.thread,
    this.options,
    required this.historyEnabled,
    required this.isHistoryOpen,
    this.onToggleHistory,
    required this.localizations,
  });

  final Thread? thread;
  final HeaderOption? options;
  final bool historyEnabled;
  final bool isHistoryOpen;
  final VoidCallback? onToggleHistory;
  final ChatKitLocalizations localizations;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final titleText =
        options?.title?.text ?? thread?.metadata.title ?? 'Conversation';
    Widget leading;
    if (options?.leftAction case final action?) {
      leading = _HeaderButton(action: action);
    } else if (historyEnabled && onToggleHistory != null) {
      leading = IconButton(
        icon: Icon(isHistoryOpen ? Icons.close_fullscreen : Icons.history),
        tooltip: localizations.t('history_title'),
        onPressed: onToggleHistory,
      );
    } else {
      leading = const SizedBox.shrink();
    }

    Widget trailing;
    if (options?.rightAction case final action?) {
      trailing = _HeaderButton(action: action);
    } else {
      trailing = const SizedBox.shrink();
    }

    return Container(
      padding: _spacingSymmetric(context, horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border:
            Border(bottom: BorderSide(color: theme.colorScheme.outlineVariant)),
      ),
      child: Row(
        children: [
          SizedBox(width: 48, child: Center(child: leading)),
          Expanded(
            child: Text(
              titleText,
              style: theme.textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
          ),
          SizedBox(width: 48, child: Center(child: trailing)),
        ],
      ),
    );
  }
}

class _HistoryPanel extends StatelessWidget {
  const _HistoryPanel({
    required this.localizations,
    required this.section,
    required this.onSectionChanged,
    required this.searchController,
    required this.onSearchChanged,
    required this.onSearchCleared,
    required this.pinnedThreads,
    required this.threads,
    required this.loadingInitial,
    required this.loadingMore,
    required this.onRefresh,
    required this.onSelect,
    this.onDelete,
    this.onRename,
    required this.currentThreadId,
    this.error,
    required this.hasMore,
    this.onLoadMore,
    required this.scrollController,
  });

  final ChatKitLocalizations localizations;
  final _HistorySection section;
  final ValueChanged<_HistorySection> onSectionChanged;
  final TextEditingController searchController;
  final ValueChanged<String> onSearchChanged;
  final VoidCallback onSearchCleared;
  final List<ThreadMetadata> pinnedThreads;
  final List<ThreadMetadata> threads;
  final bool loadingInitial;
  final bool loadingMore;
  final Future<void> Function() onRefresh;
  final void Function(String?) onSelect;
  final void Function(String threadId)? onDelete;
  final void Function(ThreadMetadata thread)? onRename;
  final String? currentThreadId;
  final String? error;
  final bool hasMore;
  final Future<void> Function()? onLoadMore;
  final ScrollController scrollController;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final textTheme = theme.textTheme;
    final searchValue = searchController.text;
    final showClear = searchValue.isNotEmpty;
    final dateFormatter = DateFormat.yMMMd().add_jm();
    final tokens = theme.extension<ChatKitThemeTokens>();
    final style = tokens?.historyStyle;
    final panelBackground = style?.backgroundColor ?? theme.colorScheme.surface;
    final panelTextColor = style?.textColor;
    final panelBorderColor = style?.borderColor;
    final panelElevation = style?.elevation ?? tokens?.historyElevation ?? 4;
    final panelRadius = style?.radius ?? 0;

    Widget buildThreadTile(ThreadMetadata thread, {required bool pinned}) {
      final selected = currentThreadId == thread.id;
      final title = (thread.title ?? '').trim().isEmpty
          ? localizations.t('history_thread_untitled')
          : thread.title!;

      final badges = <Widget>[];
      if (thread.status.isClosed) {
        badges.add(
          _HistoryStatusChip(
            label: localizations.t('history_status_archived'),
            background: theme.colorScheme.errorContainer,
            foreground: theme.colorScheme.onErrorContainer,
          ),
        );
      } else if (thread.status.isLocked) {
        badges.add(
          _HistoryStatusChip(
            label: localizations.t('history_status_locked'),
            background: theme.colorScheme.tertiaryContainer,
            foreground: theme.colorScheme.onTertiaryContainer,
          ),
        );
      }
      if (_isShared(thread)) {
        badges.add(
          _HistoryStatusChip(
            label: localizations.t('history_status_shared'),
            background: theme.colorScheme.secondaryContainer,
            foreground: theme.colorScheme.onSecondaryContainer,
          ),
        );
      }

      final trailingActions = <Widget>[];
      if (onRename != null) {
        trailingActions.add(
          IconButton(
            icon: const Icon(Icons.edit_outlined),
            tooltip: localizations.t('history_rename'),
            onPressed: () => onRename!(thread),
          ),
        );
      }
      if (onDelete != null) {
        trailingActions.add(
          IconButton(
            icon: const Icon(Icons.delete_outline),
            tooltip: localizations.t('history_delete'),
            onPressed: () => onDelete!(thread.id),
          ),
        );
      }

      return ListTile(
        dense: false,
        shape: RoundedRectangleBorder(
          borderRadius: _radius(context, 12),
        ),
        contentPadding: _spacingSymmetric(context, horizontal: 12, vertical: 6),
        selected: selected,
        leading: Icon(
          pinned ? Icons.push_pin_outlined : Icons.chat_bubble_outline,
          color: pinned
              ? theme.colorScheme.primary
              : theme.colorScheme.onSurfaceVariant,
        ),
        title: Text(
          title,
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        subtitle: badges.isEmpty
            ? Text(
                dateFormatter.format(thread.createdAt),
                style: textTheme.bodySmall,
              )
            : Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    dateFormatter.format(thread.createdAt),
                    style: textTheme.bodySmall,
                  ),
                  const SizedBox(height: 4),
                  Wrap(
                    spacing: 6,
                    runSpacing: 4,
                    children: badges,
                  ),
                ],
              ),
        onTap: () => onSelect(thread.id),
        trailing: trailingActions.isEmpty
            ? null
            : Row(
                mainAxisSize: MainAxisSize.min,
                children: trailingActions,
              ),
      );
    }

    final listChildren = <Widget>[];
    if (error != null && (pinnedThreads.isNotEmpty || threads.isNotEmpty)) {
      listChildren.add(
        Padding(
          padding: _spacingSymmetric(context, horizontal: 12, vertical: 4),
          child: _HistoryErrorBanner(
            message: error!,
            localizations: localizations,
            onRetry: onRefresh,
          ),
        ),
      );
    }

    if (pinnedThreads.isNotEmpty) {
      listChildren.add(
        _HistorySectionHeader(
          label: localizations.t('history_pinned_section'),
        ),
      );
      for (final thread in pinnedThreads) {
        listChildren.add(
          Padding(
            padding: _spacingSymmetric(context, horizontal: 8, vertical: 4),
            child: buildThreadTile(thread, pinned: true),
          ),
        );
      }
      if (threads.isNotEmpty) {
        listChildren.add(SizedBox(height: _spacingValue(context, 8)));
      }
    }

    if (threads.isNotEmpty) {
      listChildren.add(
        _HistorySectionHeader(
          label: localizations.t(section.localizationKey),
        ),
      );
      for (final thread in threads) {
        listChildren.add(
          Padding(
            padding: _spacingSymmetric(context, horizontal: 8, vertical: 4),
            child: buildThreadTile(thread, pinned: false),
          ),
        );
      }
    }

    if (loadingMore) {
      listChildren.add(SizedBox(height: _spacingValue(context, 8)));
      for (var i = 0; i < 3; i++) {
        listChildren.add(
          Padding(
            padding: _spacingSymmetric(context, horizontal: 12, vertical: 6),
            child: const _HistorySkeletonTile(),
          ),
        );
      }
    } else if (hasMore && onLoadMore != null) {
      listChildren.add(
        Padding(
          padding: _spacingSymmetric(context, horizontal: 16, vertical: 12),
          child: OutlinedButton.icon(
            onPressed: () => onLoadMore!(),
            icon: const Icon(Icons.history),
            label: Text(localizations.t('history_load_more')),
          ),
        ),
      );
    }

    Widget buildBody() {
      if (loadingInitial) {
        return const _HistorySkeletonList();
      }
      if (pinnedThreads.isEmpty && threads.isEmpty) {
        if (error != null) {
          return Center(
            child: Padding(
              padding: _spacingAll(context, 16),
              child: _HistoryErrorBanner(
                message: error!,
                localizations: localizations,
                onRetry: onRefresh,
              ),
            ),
          );
        }
        return _HistoryEmptyState(
          icon: searchValue.isNotEmpty
              ? Icons.search_off_outlined
              : Icons.chat_bubble_outline,
          message: searchValue.isNotEmpty
              ? localizations.t('history_empty_search')
              : localizations.t('history_empty'),
        );
      }
      return ListView(
        controller: scrollController,
        padding: _spacingSymmetric(context, vertical: 8),
        children: listChildren,
      );
    }

    Widget panelContent = Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: _spacingFromLTRB(context, 16, 16, 8, 8),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  localizations.t('history_title'),
                  style: textTheme.titleMedium,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.refresh),
                tooltip: localizations.t('history_refresh'),
                onPressed: () => onRefresh(),
              ),
            ],
          ),
        ),
        Padding(
          padding: _spacingSymmetric(context, horizontal: 16),
          child: TextField(
            controller: searchController,
            onChanged: onSearchChanged,
            onSubmitted: (_) => onRefresh(),
            textInputAction: TextInputAction.search,
            decoration: InputDecoration(
              prefixIcon: const Icon(Icons.search),
              hintText: localizations.t('history_search_hint'),
              suffixIcon: showClear
                  ? IconButton(
                      icon: const Icon(Icons.close),
                      tooltip: localizations.t('history_clear_search'),
                      onPressed: onSearchCleared,
                    )
                  : null,
            ),
          ),
        ),
        Padding(
          padding: _spacingFromLTRB(context, 16, 12, 16, 8),
          child: Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              for (final value in _HistorySection.values)
                ChoiceChip(
                  label: Text(localizations.t(value.localizationKey)),
                  selected: section == value,
                  onSelected: (selected) {
                    if (selected) {
                      onSectionChanged(value);
                    }
                  },
                ),
            ],
          ),
        ),
        Expanded(child: buildBody()),
        const Divider(height: 1),
        Padding(
          padding: _spacingAll(context, 16),
          child: FilledButton.icon(
            onPressed: () => onSelect(null),
            icon: const Icon(Icons.add),
            label: Text(localizations.t('history_new_chat')),
          ),
        ),
      ],
    );

    if (panelTextColor != null) {
      panelContent = IconTheme.merge(
        data: IconThemeData(color: panelTextColor),
        child: DefaultTextStyle.merge(
          style: textTheme.bodyMedium?.copyWith(color: panelTextColor),
          child: panelContent,
        ),
      );
    }

    return Material(
      color: panelBackground,
      elevation: panelElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(panelRadius),
        side: panelBorderColor == null
            ? BorderSide.none
            : BorderSide(color: panelBorderColor),
      ),
      child: panelContent,
    );
  }

  bool _isShared(ThreadMetadata thread) {
    final shared = thread.metadata['shared'];
    if (shared is bool) return shared;
    if (shared is num) return shared != 0;
    if (shared is String) {
      final normalized = shared.trim().toLowerCase();
      if (normalized == 'true' || normalized == '1' || normalized == 'yes') {
        return true;
      }
    }
    final visibility = thread.metadata['visibility'];
    if (visibility is String && visibility.trim().toLowerCase() == 'shared') {
      return true;
    }
    return false;
  }
}

class _HistorySectionHeader extends StatelessWidget {
  const _HistorySectionHeader({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: _spacingFromLTRB(context, 16, 12, 16, 4),
      child: Text(
        label,
        style: theme.textTheme.labelMedium?.copyWith(
          color: theme.colorScheme.onSurfaceVariant,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class _HistoryStatusChip extends StatelessWidget {
  const _HistoryStatusChip({
    required this.label,
    required this.background,
    required this.foreground,
  });

  final String label;
  final Color background;
  final Color foreground;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: _spacingSymmetric(context, horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: background,
        borderRadius: _radius(context, 999),
      ),
      child: Text(
        label,
        style: theme.textTheme.labelSmall?.copyWith(color: foreground),
      ),
    );
  }
}

class _HistoryErrorBanner extends StatelessWidget {
  const _HistoryErrorBanner({
    required this.message,
    required this.localizations,
    required this.onRetry,
  });

  final String message;
  final ChatKitLocalizations localizations;
  final Future<void> Function() onRetry;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      padding: _spacingSymmetric(context, horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: theme.colorScheme.errorContainer,
        borderRadius: _radius(context, 12),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            Icons.error_outline,
            size: 20,
            color: theme.colorScheme.onErrorContainer,
          ),
          SizedBox(width: _spacingValue(context, 12)),
          Expanded(
            child: Text(
              message,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onErrorContainer,
              ),
            ),
          ),
          TextButton(
            onPressed: () => onRetry(),
            style: TextButton.styleFrom(
              foregroundColor: theme.colorScheme.onErrorContainer,
            ),
            child: Text(localizations.t('history_retry')),
          ),
        ],
      ),
    );
  }
}

class _HistoryEmptyState extends StatelessWidget {
  const _HistoryEmptyState({
    required this.icon,
    required this.message,
  });

  final IconData icon;
  final String message;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: _spacingAll(context, 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 48,
              color: theme.colorScheme.onSurfaceVariant,
            ),
            SizedBox(height: _spacingValue(context, 16)),
            Text(
              message,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class _HistorySkeletonList extends StatelessWidget {
  const _HistorySkeletonList();

  static const int _itemCount = 6;

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: _spacingSymmetric(context, horizontal: 16, vertical: 12),
      itemCount: _itemCount,
      itemBuilder: (context, index) => Padding(
        padding: _spacingSymmetric(context, vertical: 6),
        child: const _HistorySkeletonTile(),
      ),
    );
  }
}

class _HistorySkeletonTile extends StatelessWidget {
  const _HistorySkeletonTile();

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Row(
      children: [
        Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: theme.colorScheme.surfaceContainerHighest,
            borderRadius: _radius(context, 12),
          ),
        ),
        SizedBox(width: _spacingValue(context, 12)),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                height: 14,
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  borderRadius: _radius(context, 10),
                ),
              ),
              SizedBox(height: _spacingValue(context, 8)),
              Container(
                height: 12,
                width: 120,
                decoration: BoxDecoration(
                  color: theme.colorScheme.surfaceContainerHighest,
                  borderRadius: _radius(context, 10),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

enum _HistorySection { recent, archived, shared }

extension _HistorySectionMetadata on _HistorySection {
  String get localizationKey => switch (this) {
        _HistorySection.recent => 'history_section_recent',
        _HistorySection.archived => 'history_section_archived',
        _HistorySection.shared => 'history_section_shared',
      };

  String get metadataValue => switch (this) {
        _HistorySection.recent => 'recent',
        _HistorySection.archived => 'archived',
        _HistorySection.shared => 'shared',
      };
}

class _HistorySectionState {
  const _HistorySectionState({
    this.threads = const [],
    this.cursor,
    this.hasMore = false,
    this.loadingInitial = false,
    this.loadingMore = false,
    this.initialized = false,
    this.error,
  });

  final List<ThreadMetadata> threads;
  final String? cursor;
  final bool hasMore;
  final bool loadingInitial;
  final bool loadingMore;
  final bool initialized;
  final String? error;

  static const Object _sentinel = Object();

  _HistorySectionState copyWith({
    List<ThreadMetadata>? threads,
    String? cursor,
    bool? hasMore,
    bool? loadingInitial,
    bool? loadingMore,
    bool? initialized,
    Object? error = _sentinel,
  }) {
    return _HistorySectionState(
      threads: threads ?? this.threads,
      cursor: cursor ?? this.cursor,
      hasMore: hasMore ?? this.hasMore,
      loadingInitial: loadingInitial ?? this.loadingInitial,
      loadingMore: loadingMore ?? this.loadingMore,
      initialized: initialized ?? this.initialized,
      error: identical(error, _sentinel) ? this.error : error as String?,
    );
  }
}

class _EntityBadge extends StatelessWidget {
  const _EntityBadge({
    required this.label,
    required this.background,
    required this.foreground,
  });

  final String label;
  final Color background;
  final Color foreground;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      margin: _spacingOnly(context, left: 4),
      padding: _spacingSymmetric(context, horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: background,
        borderRadius: _radius(context, 999),
      ),
      child: Text(
        label,
        style: theme.textTheme.labelSmall?.copyWith(
          color: foreground,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

class _AuthExpiredBanner extends StatelessWidget {
  const _AuthExpiredBanner({
    required this.localizations,
    required this.onDismiss,
  });

  final ChatKitLocalizations localizations;
  final VoidCallback onDismiss;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Container(
      width: double.infinity,
      color: theme.colorScheme.errorContainer,
      padding: _spacingSymmetric(context, horizontal: 16, vertical: 12),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  localizations.t('auth_expired'),
                  style: theme.textTheme.titleSmall
                      ?.copyWith(color: theme.colorScheme.onErrorContainer),
                ),
                const SizedBox(height: 4),
                Text(
                  localizations.t('auth_expired_description'),
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: theme.colorScheme.onErrorContainer),
                ),
              ],
            ),
          ),
          TextButton(
            onPressed: onDismiss,
            style: TextButton.styleFrom(
              foregroundColor: theme.colorScheme.onErrorContainer,
            ),
            child: Text(localizations.t('auth_expired_dismiss')),
          ),
        ],
      ),
    );
  }
}

class _HeaderButton extends StatelessWidget {
  const _HeaderButton({required this.action});

  final HeaderActionOption action;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: action.onClick,
      icon: _iconForHeader(action.icon),
    );
  }

  Icon _iconForHeader(String icon) {
    switch (icon) {
      case HeaderIcons.sidebarLeft:
      case HeaderIcons.sidebarOpenLeft:
      case HeaderIcons.sidebarCollapseRight:
      case HeaderIcons.backSmall:
      case HeaderIcons.backLarge:
      case HeaderIcons.collapseLeft:
      case HeaderIcons.openLeft:
        return const Icon(Icons.arrow_back);
      case HeaderIcons.sidebarRight:
      case HeaderIcons.sidebarOpenRight:
      case HeaderIcons.sidebarCollapseLeft:
      case HeaderIcons.openRight:
      case HeaderIcons.doubleChevronRight:
        return const Icon(Icons.arrow_forward);
      case HeaderIcons.sidebarFloatingLeft:
      case HeaderIcons.sidebarFloatingOpenLeft:
        return const Icon(Icons.keyboard_double_arrow_left);
      case HeaderIcons.sidebarFloatingRight:
      case HeaderIcons.sidebarFloatingOpenRight:
        return const Icon(Icons.keyboard_double_arrow_right);
      case HeaderIcons.doubleChevronLeft:
        return const Icon(Icons.keyboard_double_arrow_left);
      case HeaderIcons.expandLarge:
      case HeaderIcons.expandSmall:
        return const Icon(Icons.open_in_full);
      case HeaderIcons.collapseLarge:
      case HeaderIcons.collapseSmall:
        return const Icon(Icons.close_fullscreen);
      case HeaderIcons.star:
        return const Icon(Icons.star_border);
      case HeaderIcons.starFilled:
        return const Icon(Icons.star);
      case HeaderIcons.chatTemporary:
        return const Icon(Icons.bolt);
      case HeaderIcons.settingsCog:
        return const Icon(Icons.settings);
      case HeaderIcons.grid:
        return const Icon(Icons.grid_view);
      case HeaderIcons.dotsHorizontal:
        return const Icon(Icons.more_horiz);
      case HeaderIcons.dotsVertical:
        return const Icon(Icons.more_vert);
      case HeaderIcons.dotsHorizontalCircle:
        return const Icon(Icons.more_horiz);
      case HeaderIcons.dotsVerticalCircle:
        return const Icon(Icons.more_vert);
      case HeaderIcons.menu:
      case HeaderIcons.hamburger:
      case HeaderIcons.menuInverted:
        return const Icon(Icons.menu);
      case HeaderIcons.compose:
      case HeaderIcons.add:
        return const Icon(Icons.add);
      case HeaderIcons.lightMode:
        return const Icon(Icons.light_mode);
      case HeaderIcons.darkMode:
        return const Icon(Icons.dark_mode);
      case HeaderIcons.close:
        return const Icon(Icons.close);
      default:
        switch (icon) {
          case 'bell':
            return const Icon(Icons.notifications);
          case 'check':
            return const Icon(Icons.check);
          case 'copy':
            return const Icon(Icons.copy);
          case 'delete':
            return const Icon(Icons.delete);
          case 'edit':
            return const Icon(Icons.edit);
          case 'refresh':
            return const Icon(Icons.refresh);
          case 'share':
            return const Icon(Icons.share);
          default:
            return const Icon(Icons.more_horiz);
        }
    }
  }
}

class _StartScreen extends StatelessWidget {
  const _StartScreen({this.options});

  final StartScreenOption? options;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: _spacingAll(context, 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              options?.greeting ?? 'What can I help with today?',
              style: theme.textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            if (options?.prompts case final prompts?)
              Padding(
                padding: _spacingOnly(context, top: 16),
                child: Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    for (final prompt in prompts)
                      ActionChip(
                        label: Text(prompt.label),
                        avatar: prompt.icon == null
                            ? null
                            : Icon(
                                _promptIconData(prompt.icon!),
                                size: 18,
                              ),
                        onPressed: () => _insertPrompt(context, prompt),
                      ),
                  ],
                ),
              ),
          ],
        ),
      ),
    );
  }

  void _insertPrompt(BuildContext context, StartScreenPrompt prompt) {
    final state = context.findAncestorStateOfType<_ChatKitViewState>();
    if (state == null) return;
    final composer = state._composerController;
    final text = prompt.prompt;
    composer.value = TextEditingValue(
      text: text,
      selection: TextSelection.collapsed(offset: text.length),
    );
    state.controller.setComposerValue(text: text);
  }

  IconData _promptIconData(String icon) {
    switch (icon) {
      case 'sparkle':
      case 'sparkle-double':
        return Icons.auto_awesome;
      case 'book-open':
      case 'book-closed':
        return Icons.menu_book_outlined;
      case 'lightbulb':
        return Icons.lightbulb_outline;
      case 'map-pin':
        return Icons.place_outlined;
      case 'profile':
      case 'profile-card':
        return Icons.person_outline;
      case 'analytics':
      case 'chart':
        return Icons.bar_chart_outlined;
      case 'write':
      case 'write-alt':
      case 'write-alt2':
        return Icons.edit_outlined;
      default:
        return Icons.chat_bubble_outline;
    }
  }
}

class _ChatItemView extends StatelessWidget {
  const _ChatItemView({
    super.key,
    required this.item,
    required this.controller,
    required this.localizations,
    this.actions,
  });

  final ThreadItem item;
  final ChatKitController controller;
  final ChatKitLocalizations localizations;
  final ThreadItemActionsOption? actions;

  @override
  Widget build(BuildContext context) {
    switch (item.type) {
      case 'user_message':
        return _UserMessageBubble(item: item);
      case 'assistant_message':
        return _AssistantMessageBubble(
          item: item,
          controller: controller,
          localizations: localizations,
          actions: actions,
        );
      case 'client_tool_call':
        return _ClientToolCallView(item: item);
      case 'widget':
        return _WidgetItemView(item: item, controller: controller);
      case 'workflow':
        return _WorkflowView(item: item);
      default:
        return Padding(
          padding: _spacingSymmetric(context, vertical: 8),
          child: Text('Unsupported item type ${item.type}'),
        );
    }
  }
}

class _UserMessageBubble extends StatelessWidget {
  const _UserMessageBubble({required this.item});

  final ThreadItem item;

  @override
  Widget build(BuildContext context) {
    final text = item.content
        .where((entry) => entry['type'] == 'input_text')
        .map((entry) => entry['text'] as String? ?? '')
        .join('\n');
    final theme = Theme.of(context);
    final tokens = theme.extension<ChatKitThemeTokens>();
    final style = tokens?.userBubbleStyle;
    final background = style?.backgroundColor ?? theme.colorScheme.primary;
    final textColor = style?.textColor ?? theme.colorScheme.onPrimary;
    final borderColor = style?.borderColor;
    final radius = BorderRadius.circular(style?.radius ?? 12);
    final elevation = style?.elevation ?? 0;

    return Align(
      alignment: Alignment.centerRight,
      child: Container(
        margin: _spacingSymmetric(context, vertical: 6),
        child: Material(
          elevation: elevation,
          color: background,
          borderRadius: radius,
          child: DecoratedBox(
            decoration: BoxDecoration(
              borderRadius: radius,
              border:
                  borderColor == null ? null : Border.all(color: borderColor),
            ),
            child: Padding(
              padding: _spacingAll(context, 12),
              child: Text(
                text,
                style: theme.textTheme.bodyMedium?.copyWith(color: textColor),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AssistantMessageBubble extends StatelessWidget {
  const _AssistantMessageBubble({
    required this.item,
    required this.controller,
    required this.localizations,
    this.actions,
  });

  final ThreadItem item;
  final ChatKitController controller;
  final ChatKitLocalizations localizations;
  final ThreadItemActionsOption? actions;

  @override
  Widget build(BuildContext context) {
    final textBuffer = StringBuffer();
    for (final part in item.content) {
      if (part['type'] == 'output_text') {
        textBuffer.writeln(part['text'] ?? '');
      }
    }
    final text = textBuffer.toString().trim();
    final theme = Theme.of(context);
    final tokens = theme.extension<ChatKitThemeTokens>();
    final style = tokens?.assistantBubbleStyle;
    final background =
        style?.backgroundColor ?? theme.colorScheme.surfaceContainerHighest;
    final textColor = style?.textColor ?? theme.textTheme.bodyMedium?.color;
    final borderColor = style?.borderColor;
    final radius = BorderRadius.circular(style?.radius ?? 12);
    final elevation = style?.elevation ?? 0;

    final bubble = Align(
      alignment: Alignment.centerLeft,
      child: Container(
        margin: _spacingSymmetric(context, vertical: 6),
        child: Material(
          elevation: elevation,
          color: background,
          borderRadius: radius,
          child: DecoratedBox(
            decoration: BoxDecoration(
              borderRadius: radius,
              border:
                  borderColor == null ? null : Border.all(color: borderColor),
            ),
            child: Padding(
              padding: _spacingAll(context, 12),
              child: text.isEmpty
                  ? const SizedBox.shrink()
                  : MarkdownBody(
                      data: text,
                      styleSheet: MarkdownStyleSheet.fromTheme(theme).copyWith(
                        p: theme.textTheme.bodyMedium?.copyWith(
                          color: textColor,
                        ),
                        strong: theme.textTheme.bodyMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: textColor,
                        ),
                      ),
                    ),
            ),
          ),
        ),
      ),
    );

    if (actions == null) {
      return bubble;
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        bubble,
        _AssistantActionsBar(
          item: item,
          controller: controller,
          actions: actions!,
          localizations: localizations,
        ),
      ],
    );
  }
}

class _AssistantActionsBar extends StatefulWidget {
  const _AssistantActionsBar({
    required this.item,
    required this.controller,
    required this.actions,
    required this.localizations,
  });

  final ThreadItem item;
  final ChatKitController controller;
  final ThreadItemActionsOption actions;
  final ChatKitLocalizations localizations;

  @override
  State<_AssistantActionsBar> createState() => _AssistantActionsBarState();
}

class _AssistantActionsBarState extends State<_AssistantActionsBar> {
  bool _submitting = false;

  Future<void> _handleFeedback(String kind) async {
    setState(() => _submitting = true);
    try {
      await widget.controller.submitFeedback(
        threadId: widget.item.threadId,
        itemIds: [widget.item.id],
        kind: kind,
      );
      if (mounted) {
        final label = kind == 'positive'
            ? widget.localizations.t('feedback_positive')
            : widget.localizations.t('feedback_negative');
        final messenger = ScaffoldMessenger.maybeOf(context);
        final suppress = context
                .findAncestorStateOfType<_ChatKitViewState>()
                ?._suppressSnackbars ??
            false;
        if (!suppress && messenger != null) {
          messenger.showSnackBar(
            SnackBar(
              content: Text(
                "${widget.localizations.t('feedback_sent')}: $label",
              ),
            ),
          );
        }
      }
    } finally {
      if (mounted) {
        setState(() => _submitting = false);
      }
    }
  }

  Future<void> _handleRetry() async {
    setState(() => _submitting = true);
    try {
      await widget.controller.retryAfterItem(
        threadId: widget.item.threadId,
        itemId: widget.item.id,
      );
    } finally {
      if (mounted) {
        setState(() => _submitting = false);
      }
    }
  }

  void _handleShare() {
    widget.controller.shareItem(widget.item.id);
  }

  @override
  Widget build(BuildContext context) {
    final actions = widget.actions;
    final l10n = widget.localizations;
    final buttons = <Widget>[];
    if (actions.feedback == true) {
      buttons.addAll([
        IconButton(
          tooltip: l10n.t('feedback_positive'),
          icon: const Icon(Icons.thumb_up_alt_outlined),
          onPressed: _submitting ? null : () => _handleFeedback('positive'),
        ),
        IconButton(
          tooltip: l10n.t('feedback_negative'),
          icon: const Icon(Icons.thumb_down_alt_outlined),
          onPressed: _submitting ? null : () => _handleFeedback('negative'),
        ),
      ]);
    }
    if (actions.retry == true) {
      buttons.add(
        IconButton(
          tooltip: l10n.t('retry_response'),
          icon: const Icon(Icons.refresh),
          onPressed: _submitting ? null : _handleRetry,
        ),
      );
    }
    if (actions.share == true) {
      buttons.add(
        IconButton(
          tooltip: l10n.t('share_message'),
          icon: const Icon(Icons.share),
          onPressed: _handleShare,
        ),
      );
    }

    if (buttons.isEmpty) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: _spacingOnly(context, left: 4, bottom: 4),
      child: Row(children: buttons),
    );
  }
}

class _ClientToolCallView extends StatelessWidget {
  const _ClientToolCallView({required this.item});

  final ThreadItem item;

  @override
  Widget build(BuildContext context) {
    final name = item.raw['name'] as String? ?? 'Tool call';
    final status = item.raw['status'] as String? ?? 'pending';
    return Align(
      alignment: Alignment.centerLeft,
      child: Container(
        margin: _spacingSymmetric(context, vertical: 6),
        padding: _spacingAll(context, 12),
        decoration: BoxDecoration(
          borderRadius: _radius(context, 12),
          border:
              Border.all(color: Theme.of(context).colorScheme.outlineVariant),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Client Tool: $name',
                style: Theme.of(context).textTheme.titleSmall),
            const SizedBox(height: 4),
            Text('Status: $status'),
          ],
        ),
      ),
    );
  }
}

class _WidgetItemView extends StatelessWidget {
  const _WidgetItemView({
    required this.item,
    required this.controller,
  });

  final ThreadItem item;
  final ChatKitController controller;

  @override
  Widget build(BuildContext context) {
    final widgetJson = item.raw['widget'] as Map<String, Object?>?;
    if (widgetJson == null) {
      return const SizedBox.shrink();
    }
    return Padding(
      padding: _spacingSymmetric(context, vertical: 6),
      child: ChatKitWidgetRenderer(
        widgetJson: widgetJson,
        controller: controller,
        item: item,
      ),
    );
  }
}

class _WorkflowView extends StatelessWidget {
  const _WorkflowView({required this.item});

  final ThreadItem item;

  @override
  Widget build(BuildContext context) {
    final workflow = item.raw['workflow'] as Map<String, Object?>?;
    if (workflow == null) {
      return const SizedBox.shrink();
    }
    final tasks =
        (workflow['tasks'] as List?)?.cast<Map<String, Object?>>() ?? const [];
    return Align(
      alignment: Alignment.centerLeft,
      child: Container(
        margin: _spacingSymmetric(context, vertical: 6),
        padding: _spacingAll(context, 12),
        decoration: BoxDecoration(
          borderRadius: _radius(context, 12),
          border:
              Border.all(color: Theme.of(context).colorScheme.outlineVariant),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (workflow['summary'] is Map)
              Text(
                  'Workflow: ${(workflow['summary'] as Map)['title'] ?? 'Summary'}'),
            for (final task in tasks)
              Padding(
                padding: _spacingOnly(context, top: 8),
                child: Text('- ${task['title'] ?? task['type']}'),
              ),
          ],
        ),
      ),
    );
  }
}

class _BlinkingPendingIndicator extends StatefulWidget {
  const _BlinkingPendingIndicator();

  @override
  State<_BlinkingPendingIndicator> createState() =>
      _BlinkingPendingIndicatorState();
}

class _BlinkingPendingIndicatorState extends State<_BlinkingPendingIndicator>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 900),
      lowerBound: 0.35,
      upperBound: 1.0,
    )..repeat(reverse: true);
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.primary;
    return Padding(
      padding: _spacingOnly(context, right: 8),
      child: SizedBox(
        width: 10,
        height: 10,
        child: FadeTransition(
          opacity: _controller,
          child: DecoratedBox(
            decoration: BoxDecoration(
              color: color,
              shape: BoxShape.circle,
            ),
          ),
        ),
      ),
    );
  }
}

class _Composer extends StatelessWidget {
  const _Composer({
    required this.composerController,
    required this.focusNode,
    required this.onSend,
    required this.placeholder,
    required this.isStreaming,
    required this.onTextChanged,
    required this.localizations,
    this.isComposerLocked = false,
    this.lockMessage,
    this.onAttachment,
    this.attachments = const [],
    this.pendingUploads = const [],
    this.onRemoveAttachment,
    this.onAddTag,
    this.onRemoveTag,
    this.onTapTag,
    this.onPreviewTag,
    this.tags = const [],
    this.tools,
    this.models,
    this.selectedToolId,
    this.selectedModelId,
    this.onToolChanged,
    this.onModelChanged,
    this.onCancelUpload,
    this.onRetryUpload,
    this.onRemoveFailedUpload,
    required this.composerFieldLink,
    this.tagFocusNodes = const {},
    this.tagTooltipBuilder,
    this.tagAvatarBuilder,
  });

  final TextEditingController composerController;
  final FocusNode focusNode;
  final VoidCallback onSend;
  final VoidCallback? onAttachment;
  final String placeholder;
  final bool isStreaming;
  final bool isComposerLocked;
  final String? lockMessage;
  final ValueChanged<String> onTextChanged;
  final ChatKitLocalizations localizations;
  final List<ChatKitAttachment> attachments;
  final List<_PendingUpload> pendingUploads;
  final void Function(ChatKitAttachment attachment)? onRemoveAttachment;
  final void Function(_PendingUpload upload)? onCancelUpload;
  final void Function(_PendingUpload upload)? onRetryUpload;
  final void Function(_PendingUpload upload)? onRemoveFailedUpload;
  final VoidCallback? onAddTag;
  final void Function(Entity entity)? onRemoveTag;
  final void Function(Entity entity)? onTapTag;
  final Future<void> Function(Entity entity)? onPreviewTag;
  final List<Entity> tags;
  final List<ToolOption>? tools;
  final List<ModelOption>? models;
  final String? selectedToolId;
  final String? selectedModelId;
  final ValueChanged<String?>? onToolChanged;
  final ValueChanged<String?>? onModelChanged;
  final LayerLink composerFieldLink;
  final Map<String, FocusNode> tagFocusNodes;
  final String? Function(Entity entity)? tagTooltipBuilder;
  final Widget? Function(Entity entity)? tagAvatarBuilder;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final pinnedTools =
        tools?.where((tool) => tool.pinned).toList() ?? const [];
    final disabled = isStreaming || isComposerLocked;

    final tokens = Theme.of(context).extension<ChatKitThemeTokens>();
    final composerTokens = tokens?.composerStyle;
    final composerBackground =
        composerTokens?.backgroundColor ?? theme.colorScheme.surface;
    final composerTextColor = composerTokens?.textColor;
    final composerBorderColor = composerTokens?.borderColor;
    final composerRadius = composerTokens?.radius ?? 16;
    final composerElevation = composerTokens?.elevation ?? 0;

    Widget content = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (pinnedTools.isNotEmpty)
          Padding(
            padding: _spacingOnly(context, bottom: 8),
            child: Wrap(
              spacing: 8,
              children: [
                for (final tool in pinnedTools)
                  FilterChip(
                    label: Text(tool.shortLabel ?? tool.label),
                    avatar: _iconForTool(tool.icon),
                    selected: selectedToolId == tool.id,
                    onSelected: disabled
                        ? null
                        : (value) {
                            if (onToolChanged == null) return;
                            if (value) {
                              onToolChanged!(tool.id);
                            } else {
                              onToolChanged!(null);
                            }
                          },
                  ),
              ],
            ),
          ),
        if (tags.isNotEmpty || onAddTag != null)
          Padding(
            padding: _spacingOnly(context, bottom: 8),
            child: Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                for (final tag in tags)
                  Builder(
                    builder: (context) {
                      final tooltip = tagTooltipBuilder?.call(tag);
                      final avatar = tagAvatarBuilder?.call(tag);
                      Widget chip = InputChip(
                        label: Text(tag.title),
                        focusNode: tagFocusNodes[tag.id],
                        avatar: avatar,
                        onPressed: disabled || onTapTag == null
                            ? null
                            : () => onTapTag!(tag),
                        onDeleted: disabled || onRemoveTag == null
                            ? null
                            : () => onRemoveTag!(tag),
                      );
                      if (tooltip != null && tooltip.isNotEmpty) {
                        chip = Tooltip(
                          message: tooltip,
                          waitDuration: const Duration(milliseconds: 400),
                          child: chip,
                        );
                      }
                      return GestureDetector(
                        onLongPress: onPreviewTag == null
                            ? null
                            : () => onPreviewTag!(tag),
                        child: chip,
                      );
                    },
                  ),
                if (onAddTag != null)
                  ActionChip(
                    label: Text(localizations.t('composer_add_tag')),
                    avatar: const Icon(Icons.alternate_email, size: 18),
                    onPressed: disabled ? null : onAddTag,
                  ),
              ],
            ),
          ),
        if ((models != null && models!.isNotEmpty) ||
            (tools != null && tools!.isNotEmpty))
          Padding(
            padding: _spacingOnly(context, bottom: 8),
            child: Wrap(
              spacing: 12,
              runSpacing: 8,
              children: [
                if (models != null && models!.isNotEmpty)
                  SizedBox(
                    width: 180,
                    child: DropdownButtonFormField<String?>(
                      initialValue: selectedModelId,
                      decoration: InputDecoration(
                        labelText: localizations.t('composer_model_label'),
                      ),
                      items: [
                        for (final model in models!)
                          DropdownMenuItem<String?>(
                            value: model.id,
                            enabled: !model.disabled,
                            child: Text(
                              model.label,
                              style: model.disabled
                                  ? theme.textTheme.bodyMedium?.copyWith(
                                      color: theme.disabledColor,
                                    )
                                  : null,
                            ),
                          ),
                      ],
                      onChanged: disabled ? null : onModelChanged,
                    ),
                  ),
                if (tools != null && tools!.isNotEmpty)
                  SizedBox(
                    width: 180,
                    child: DropdownButtonFormField<String?>(
                      initialValue: selectedToolId,
                      decoration: InputDecoration(
                        labelText: localizations.t('composer_tool_label'),
                      ),
                      items: [
                        DropdownMenuItem<String?>(
                          value: null,
                          child: Text(localizations.t('composer_tool_auto')),
                        ),
                        for (final tool in tools!)
                          DropdownMenuItem<String?>(
                            value: tool.id,
                            child: Text(tool.shortLabel ?? tool.label),
                          ),
                      ],
                      onChanged: disabled ? null : onToolChanged,
                    ),
                  ),
              ],
            ),
          ),
        if (pendingUploads.isNotEmpty || attachments.isNotEmpty)
          SizedBox(
            height: 96,
            child: ListView.separated(
              scrollDirection: Axis.horizontal,
              padding: _spacingSymmetric(context, horizontal: 4),
              itemCount: pendingUploads.length + attachments.length,
              separatorBuilder: (_, __) =>
                  SizedBox(width: _spacingValue(context, 8)),
              itemBuilder: (context, index) {
                if (index < pendingUploads.length) {
                  final upload = pendingUploads[index];
                  return _AttachmentUploadChip(
                    upload: upload,
                    localizations: localizations,
                    onCancel: onCancelUpload == null
                        ? null
                        : () => onCancelUpload!(upload),
                    onRetry: onRetryUpload == null
                        ? null
                        : () => onRetryUpload!(upload),
                    onRemove: onRemoveFailedUpload == null
                        ? null
                        : () => onRemoveFailedUpload!(upload),
                  );
                }
                final attachment = attachments[index - pendingUploads.length];
                return _AttachmentChip(
                  attachment: attachment,
                  onRemove: onRemoveAttachment,
                );
              },
            ),
          ),
        if (isComposerLocked && lockMessage != null)
          Padding(
            padding: _spacingOnly(context, bottom: 8),
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(
                lockMessage!,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),
        Row(
          children: [
            if (isStreaming) const _BlinkingPendingIndicator(),
            if (onAttachment != null)
              IconButton(
                icon: Icon(
                  ChatKitIcons.forWidget('plus') ?? Icons.add,
                ),
                onPressed: disabled ? null : onAttachment,
              ),
            if (onAddTag != null)
              IconButton(
                icon: const Icon(Icons.alternate_email),
                tooltip: localizations.t('composer_add_tag'),
                onPressed: disabled ? null : onAddTag,
              ),
            Expanded(
              child: CompositedTransformTarget(
                link: composerFieldLink,
                child: TextField(
                  controller: composerController,
                  focusNode: focusNode,
                  minLines: 1,
                  maxLines: 5,
                  enabled: !disabled,
                  decoration: InputDecoration(
                    hintText: placeholder,
                    border: OutlineInputBorder(
                      borderRadius: _radius(context, 12),
                    ),
                  ),
                  onChanged: onTextChanged,
                ),
              ),
            ),
            SizedBox(width: _spacingValue(context, 8)),
            FilledButton(
              onPressed: disabled ? null : onSend,
              style: FilledButton.styleFrom(
                shape: const CircleBorder(),
                padding: EdgeInsets.all(_spacingValue(context, 8)),
                minimumSize: Size.square(_spacingValue(context, 40)),
              ),
              child: isStreaming
                  ? SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.colorScheme.onPrimary,
                      ),
                    )
                  : isComposerLocked
                      ? const Icon(Icons.lock_outline)
                      : const Icon(Icons.send),
            ),
          ],
        ),
      ],
    );

    if (composerTextColor != null) {
      content = IconTheme.merge(
        data: IconThemeData(color: composerTextColor),
        child: DefaultTextStyle.merge(
          style: theme.textTheme.bodyMedium?.copyWith(
            color: composerTextColor,
          ),
          child: content,
        ),
      );
    }

    return SafeArea(
      top: false,
      child: Material(
        elevation: composerElevation,
        color: composerBackground,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(composerRadius),
          side: composerBorderColor == null
              ? BorderSide.none
              : BorderSide(color: composerBorderColor),
        ),
        child: Padding(
          padding: _spacingSymmetric(context, horizontal: 12, vertical: 8),
          child: content,
        ),
      ),
    );
  }

  Widget? _iconForTool(String? iconName) {
    if (iconName == null) {
      return null;
    }
    switch (iconName) {
      case 'browser':
      case 'search':
        return const Icon(Icons.public, size: 18);
      case 'calendar':
        return const Icon(Icons.calendar_today, size: 18);
      case 'email':
        return const Icon(Icons.email, size: 18);
      case 'calculator':
        return const Icon(Icons.calculate, size: 18);
      default:
        return const Icon(Icons.extension, size: 18);
    }
  }
}

class _AttachmentPayload {
  const _AttachmentPayload({
    required this.name,
    required this.bytes,
    required this.mimeType,
    required this.size,
  });

  final String name;
  final Uint8List bytes;
  final String mimeType;
  final int size;
}

enum _RejectionType { type, size, limit }

class _FileRejection {
  const _FileRejection({
    required this.name,
    required this.type,
    this.detail,
  });

  final String name;
  final _RejectionType type;
  final String? detail;
}

class _PendingUpload {
  _PendingUpload({
    required this.id,
    required this.name,
    required this.mimeType,
    required this.size,
    required this.bytes,
  }) : total = size;

  final String id;
  final String name;
  final String mimeType;
  final int size;
  final Uint8List bytes;

  int total;
  int sent = 0;
  bool cancelled = false;
  Object? error;
  bool inFlight = false;

  double? get progress => total <= 0 ? null : (sent / total).clamp(0, 1);

  bool get hasError => error != null;
}

class _BannerMessage {
  const _BannerMessage({
    required this.id,
    required this.message,
    required this.level,
    this.title,
    this.code,
    this.retryAt,
  });

  final String id;
  final String message;
  final ChatKitNoticeLevel level;
  final String? title;
  final String? code;
  final DateTime? retryAt;

  _BannerMessage copyWith({
    String? message,
    ChatKitNoticeLevel? level,
    String? title,
    String? code,
    DateTime? retryAt,
  }) {
    return _BannerMessage(
      id: id,
      message: message ?? this.message,
      level: level ?? this.level,
      title: title ?? this.title,
      code: code ?? this.code,
      retryAt: retryAt ?? this.retryAt,
    );
  }
}

class _NoticeBanner extends StatelessWidget {
  const _NoticeBanner({
    required this.banner,
    required this.localizations,
    required this.onClose,
  });

  final _BannerMessage banner;
  final ChatKitLocalizations localizations;
  final VoidCallback onClose;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final palette = _paletteForLevel(theme, banner.level);
    return Material(
      color: palette.background,
      borderRadius: _radius(context, 12),
      child: Padding(
        padding: _spacingAll(context, 12),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Icon(palette.icon, color: palette.iconColor),
            SizedBox(width: _spacingValue(context, 12)),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (banner.title != null && banner.title!.isNotEmpty)
                    Text(
                      banner.title!,
                      style: theme.textTheme.titleSmall?.copyWith(
                        color: palette.foreground,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  Text(
                    banner.message,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: palette.foreground,
                    ),
                  ),
                ],
              ),
            ),
            IconButton(
              icon: const Icon(Icons.close),
              color: palette.iconColor,
              tooltip: localizations.t('banner_dismiss'),
              onPressed: onClose,
            ),
          ],
        ),
      ),
    );
  }

  _NoticePalette _paletteForLevel(ThemeData theme, ChatKitNoticeLevel level) {
    switch (level) {
      case ChatKitNoticeLevel.warning:
        return _NoticePalette(
          background: theme.colorScheme.tertiaryContainer,
          foreground: theme.colorScheme.onTertiaryContainer,
          icon: Icons.warning_amber_rounded,
          iconColor: theme.colorScheme.onTertiaryContainer,
        );
      case ChatKitNoticeLevel.error:
        return _NoticePalette(
          background: theme.colorScheme.errorContainer,
          foreground: theme.colorScheme.onErrorContainer,
          icon: Icons.error_outline,
          iconColor: theme.colorScheme.onErrorContainer,
        );
      case ChatKitNoticeLevel.info:
        return _NoticePalette(
          background: theme.colorScheme.surfaceContainerHighest,
          foreground: theme.colorScheme.onSurface,
          icon: Icons.info_outline,
          iconColor: theme.colorScheme.primary,
        );
    }
  }
}

class _NoticePalette {
  const _NoticePalette({
    required this.background,
    required this.foreground,
    required this.icon,
    required this.iconColor,
  });

  final Color background;
  final Color foreground;
  final IconData icon;
  final Color iconColor;
}

enum _LayoutSize { compact, medium, expanded }

class _AttachmentChip extends StatelessWidget {
  const _AttachmentChip({
    required this.attachment,
    this.onRemove,
  });

  final ChatKitAttachment attachment;
  final void Function(ChatKitAttachment attachment)? onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final palette = ChatKitTheme.of(context).palette;
    final isImage = attachment is ImageAttachment;
    final typeLabel =
        _attachmentTypeLabel(attachment.name, attachment.mimeType);
    final metadata = _attachmentMetadata(attachment);
    final preview = isImage
        ? CachedNetworkImage(
            imageUrl: (attachment as ImageAttachment).previewUrl,
            fit: BoxFit.cover,
          )
        : Container(
            color: theme.colorScheme.surfaceContainerHighest,
            alignment: Alignment.center,
            child: Icon(
              _iconForMimeType(attachment.mimeType),
              size: 32,
              color: theme.colorScheme.primary,
            ),
          );

    final removeTooltip = MaterialLocalizations.of(context).deleteButtonTooltip;

    return Container(
      width: 140,
      decoration: BoxDecoration(
        borderRadius: _radius(context, 12),
        border: Border.all(color: theme.colorScheme.outlineVariant),
      ),
      clipBehavior: Clip.antiAlias,
      child: Stack(
        children: [
          Positioned.fill(child: preview),
          if (typeLabel != null)
            Positioned(
              top: 8,
              left: 8,
              child: Container(
                padding: _spacingSymmetric(context, horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: isImage
                      ? palette.overlayStrong.withValues(alpha: 0.55)
                      : theme.colorScheme.primaryContainer,
                  borderRadius: _radius(context, 8),
                ),
                child: Text(
                  typeLabel,
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: isImage
                        ? theme.colorScheme.onInverseSurface
                        : theme.colorScheme.onPrimaryContainer,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ),
          if (onRemove != null)
            Positioned(
              top: 6,
              right: 6,
              child: Tooltip(
                message: removeTooltip,
                child: InkWell(
                  onTap: () => onRemove!(attachment),
                  borderRadius: _radius(context, 12),
                  child: Container(
                    decoration: BoxDecoration(
                      color: palette.overlayStrong.withValues(alpha: 0.55),
                      borderRadius: _radius(context, 12),
                    ),
                    padding: _spacingAll(context, 4),
                    child: Icon(
                      ChatKitIcons.forHeader('close') ?? Icons.close,
                      size: 16,
                      color: theme.colorScheme.onInverseSurface,
                    ),
                  ),
                ),
              ),
            ),
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: Container(
              padding: _spacingSymmetric(context, horizontal: 8, vertical: 8),
              decoration: BoxDecoration(
                color: isImage
                    ? palette.overlayStrong.withValues(alpha: 0.55)
                    : theme.colorScheme.surface,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    attachment.name,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: theme.textTheme.labelMedium?.copyWith(
                      color: isImage
                          ? theme.colorScheme.onInverseSurface
                          : theme.colorScheme.onSurface,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (metadata != null)
                    Text(
                      metadata,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: isImage
                            ? theme.colorScheme.onInverseSurface
                                .withValues(alpha: 0.7)
                            : theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _AttachmentUploadChip extends StatelessWidget {
  const _AttachmentUploadChip({
    required this.upload,
    required this.localizations,
    this.onCancel,
    this.onRetry,
    this.onRemove,
  });

  final _PendingUpload upload;
  final ChatKitLocalizations localizations;
  final VoidCallback? onCancel;
  final VoidCallback? onRetry;
  final VoidCallback? onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final String? sizeLabel =
        upload.size > 0 ? _formatBytes(upload.size) : null;
    final typeLabel = _attachmentTypeLabel(upload.name, upload.mimeType);

    if (upload.hasError) {
      return SizedBox(
        width: 180,
        child: Material(
          elevation: 1,
          color: theme.colorScheme.errorContainer,
          borderRadius: _radius(context, 12),
          child: Padding(
            padding: _spacingAll(context, 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  children: [
                    Icon(Icons.error_outline, color: theme.colorScheme.error),
                    SizedBox(width: _spacingValue(context, 8)),
                    Expanded(
                      child: Text(
                        upload.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onErrorContainer,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
                if (typeLabel != null || sizeLabel != null)
                  Padding(
                    padding: _spacingOnly(context, top: 4),
                    child: Text(
                      [
                        if (typeLabel != null) typeLabel,
                        if (sizeLabel != null) sizeLabel,
                      ].where((element) => element.isNotEmpty).join(' • '),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onErrorContainer
                            .withValues(alpha: 0.8),
                      ),
                    ),
                  ),
                Padding(
                  padding: _spacingOnly(context, top: 8),
                  child: Text(
                    localizations.t('attachment_upload_failed'),
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onErrorContainer,
                    ),
                  ),
                ),
                if (onRetry != null || onRemove != null)
                  Padding(
                    padding: _spacingOnly(context, top: 8),
                    child: Wrap(
                      spacing: 8,
                      children: [
                        if (onRetry != null)
                          TextButton(
                            onPressed: onRetry,
                            child: Text(
                              localizations.t('attachment_retry_upload'),
                            ),
                          ),
                        if (onRemove != null)
                          TextButton(
                            onPressed: onRemove,
                            child: Text(localizations.t('attachment_remove')),
                          ),
                      ],
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    final progress = upload.progress;
    final percentage = progress != null
        ? '${(progress * 100).clamp(0, 100).toStringAsFixed(0)}%'
        : null;
    String? transferred;
    if (progress != null && upload.total > 0) {
      transferred =
          '${_formatBytes(upload.sent)} / ${_formatBytes(upload.total)}';
    }
    final statusParts = <String>[];
    if (percentage != null) {
      statusParts.add(percentage);
    }
    if (transferred != null) {
      statusParts.add(transferred);
    }
    if (statusParts.isEmpty) {
      statusParts.add('…');
    }
    final statusText =
        '${localizations.t('attachment_uploading')} ${statusParts.join(' • ')}';
    final details = [
      if (typeLabel != null) typeLabel,
      if (sizeLabel != null) sizeLabel,
    ].where((element) => element.isNotEmpty).join(' • ');
    final cancelEnabled =
        onCancel != null && upload.inFlight && !upload.cancelled;

    return SizedBox(
      width: 180,
      child: Material(
        elevation: 1,
        color: theme.colorScheme.surface,
        borderRadius: _radius(context, 12),
        child: Padding(
          padding: _spacingAll(context, 12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      upload.name,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  if (details.isNotEmpty)
                    Padding(
                      padding: _spacingOnly(context, left: 8),
                      child: Text(
                        details,
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                  if (cancelEnabled)
                    Tooltip(
                      message: localizations.t('attachment_cancel_upload'),
                      child: IconButton(
                        icon: const Icon(Icons.close, size: 18),
                        padding: EdgeInsets.zero,
                        constraints: const BoxConstraints.tightFor(
                          width: 28,
                          height: 28,
                        ),
                        onPressed: onCancel,
                      ),
                    ),
                ],
              ),
              SizedBox(height: _spacingValue(context, 8)),
              LinearProgressIndicator(value: progress),
              SizedBox(height: _spacingValue(context, 8)),
              Text(
                statusText,
                style: theme.textTheme.bodySmall,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

String? _attachmentTypeLabel(String name, String mimeType) {
  final extension = _extensionFromName(name);
  if (extension != null && extension.isNotEmpty) {
    return extension;
  }
  final lower = mimeType.toLowerCase();
  final slashIndex = lower.indexOf('/');
  if (slashIndex != -1 && slashIndex < lower.length - 1) {
    final subtype = lower.substring(slashIndex + 1);
    if (subtype != '*') {
      return subtype.toUpperCase();
    }
  }
  return null;
}

String? _attachmentMetadata(ChatKitAttachment attachment) {
  final size = attachment.size;
  if (size != null && size > 0) {
    return _formatBytes(size);
  }
  return null;
}

IconData _iconForMimeType(String mimeType) {
  final lower = mimeType.toLowerCase();
  if (lower.startsWith('image/')) {
    return Icons.image_outlined;
  }
  if (lower.startsWith('video/')) {
    return Icons.movie_creation_outlined;
  }
  if (lower.startsWith('audio/')) {
    return Icons.audiotrack;
  }
  if (lower.contains('pdf')) {
    return Icons.picture_as_pdf;
  }
  if (lower.contains('zip') || lower.contains('compressed')) {
    return Icons.archive_outlined;
  }
  if (lower.startsWith('text/')) {
    return Icons.description_outlined;
  }
  if (lower.contains('presentation') ||
      lower.endsWith('ppt') ||
      lower.endsWith('pptx')) {
    return Icons.slideshow;
  }
  if (lower.contains('sheet') ||
      lower.endsWith('xls') ||
      lower.endsWith('xlsx')) {
    return Icons.table_chart_outlined;
  }
  return Icons.insert_drive_file;
}

String? _extensionFromName(String name) {
  final trimmed = name.trim();
  final dotIndex = trimmed.lastIndexOf('.');
  if (dotIndex <= 0 || dotIndex == trimmed.length - 1) {
    return null;
  }
  final ext = trimmed.substring(dotIndex + 1);
  if (ext.isEmpty) {
    return null;
  }
  return ext.toUpperCase();
}

String _formatBytes(int bytes) {
  if (bytes < 1024) {
    return '$bytes B';
  }
  const units = ['KB', 'MB', 'GB', 'TB'];
  var value = bytes / 1024;
  var unitIndex = 0;
  while (value >= 1024 && unitIndex < units.length - 1) {
    value /= 1024;
    unitIndex++;
  }
  final formatted =
      value >= 10 ? value.toStringAsFixed(0) : value.toStringAsFixed(1);
  return '$formatted ${units[unitIndex]}';
}

ChatKitAttachment _ensureAttachmentSize(
  ChatKitAttachment attachment,
  int size,
) {
  if (size <= 0 || attachment.size != null) {
    return attachment;
  }
  if (attachment is ImageAttachment) {
    return ImageAttachment(
      id: attachment.id,
      name: attachment.name,
      mimeType: attachment.mimeType,
      previewUrl: attachment.previewUrl,
      uploadUrl: attachment.uploadUrl,
      size: size,
    );
  }
  if (attachment is FileAttachment) {
    return FileAttachment(
      id: attachment.id,
      name: attachment.name,
      mimeType: attachment.mimeType,
      uploadUrl: attachment.uploadUrl,
      size: size,
    );
  }
  return attachment;
}
</file>

</files>
