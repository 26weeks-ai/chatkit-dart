# Migrating from ChatKit JS to ChatKit Dart

The Dart/Flutter port mirrors the surface area of the official ChatKit JS client. Use this guide to translate existing integrations.

## Installation

| JS package | Dart equivalent |
| --- | --- |
| `@openai/chatkit` | `chatkit_core` (Dart) |
| `@openai/chatkit-react` | `chatkit_flutter` (Flutter) |

## Controller / Element

| ChatKit JS (`chatKit` element) | ChatKit Dart (`ChatKitController`) |
| --- | --- |
| `chatKit.focusComposer()` | `controller.focusComposer()` |
| `chatKit.setThreadId(id)` | `controller.setThreadId(id)` |
| `chatKit.setComposerValue({ text, reply, attachments })` | `controller.setComposerValue(text: ..., reply: ..., attachments: ...)` |
| `chatKit.sendUserMessage({ text, newThread, attachments })` | `controller.sendUserMessage(text: ..., newThread: ..., attachments: ...)` |
| `chatKit.fetchUpdates()` | `controller.fetchUpdates()` |
| `chatKit.sendCustomAction(action, itemId?)` | `controller.sendCustomAction(action, itemId: ...)` |
| `chatKit.retryAfterItem({ threadId, itemId })` | `controller.retryAfterItem(threadId: ..., itemId: ...)` |
| `chatKit.listThreads()` | `controller.listThreads()` |
| `chatKit.deleteThread(threadId)` | `controller.deleteThread(threadId)` |
| `chatKit.renameThread(threadId, title)` | `controller.renameThread(threadId, title)` |
| `chatKit.submitFeedback({ threadId, itemIds, kind })` | `controller.submitFeedback(threadId: ..., itemIds: ..., kind: ...)` |
| `chatKit.shareItem(itemId)` (UI) | `controller.shareItem(itemId)` (copy to clipboard in Flutter) |

## Options

All JS options map 1:1 to Dart classes with camelCase -> lowerCamelCase conversion:

| JS | Dart |
| --- | --- |
| `api.url` | `CustomApiConfig.url` |
| `api.domainKey` | `CustomApiConfig.domainKey` |
| `api.uploadStrategy` (`{ type: 'direct' | 'two_phase', uploadUrl? }`) | `DirectUploadStrategy(uploadUrl)` / `TwoPhaseUploadStrategy()` |
| `history.showDelete` | `HistoryOption(showDelete: true)` |
| `composer.attachments.enabled` | `ComposerAttachmentOption(enabled: true)` |
| `composer.tools` | `List<ToolOption>` |
| `composer.models` | `List<ModelOption>` |
| `threadItemActions.feedback/retry/share` | `ThreadItemActionsOption(feedback: true, retry: true, share: true)` |
| `entities.onTagSearch` | `EntitiesOption(onTagSearch: ...)` |
| `widgets.onAction` | `WidgetsOption(onAction: ...)` |

Events are emitted through `controller.events` using the same names as JS (e.g. `chatkit.response.start`). Additional convenience events: `chatkit.composer.change`, `chatkit.composer.focus`, and `chatkit.message.share`.

## UI component

| ChatKit JS | ChatKit Flutter |
| --- | --- |
| `<oai-chatkit options={...} />` | `ChatKitView(controller: controller)` |
| CSS theming | Flutter theming (`ThemeData`) + `ChatKitOptions.theme` |
| React hooks (`useChatKit`) | Pure Dart controller + Flutter widget tree |

## Attachments

- JS two-phase upload: `uploadStrategy: { type: 'two_phase' }` -> Dart `CustomApiConfig(uploadStrategy: const TwoPhaseUploadStrategy())`.
- JS direct upload: `uploadStrategy: { type: 'direct', uploadUrl }` -> Dart `CustomApiConfig(uploadStrategy: DirectUploadStrategy(uploadUrl: ...))`.
- `controller.registerAttachment` wraps the strategy exactly like JS `chatkit.attachments`.

## Widgets DSL

The renderer accepts the same JSON schema generated by `chatkit-python`. Unknown widget types are logged and skipped so apps can tolerate incremental backend updates.

## Client tools & entity previews

- JS `onClientTool` -> Dart `ChatKitOptions(onClientTool: ...)`
- JS `entities.onRequestPreview` -> Dart `EntitiesOption(onRequestPreview: ...)` (rendered via Flutter dialog)

## Share behaviour

In JS the host handles share events. In Flutter `controller.shareItem` emits `chatkit.message.share` and copies the assistant text to the clipboard by default. Override this behaviour by listening to the event stream.

## Migration tips

1. **Start from shared options.** Re-use your JS configuration; convert the object literal to `ChatKitOptions`.
2. **Keep backend unchanged.** The Dart controller speaks the same protocol; no backend work required beyond CORS.
3. **Uncomment features incrementally.** Start with history + composer; add entities, attachments, and widgets once the basics work.
4. **Validate streaming flows.** Use `dart test` / `flutter test` with SSE fixtures or run against the `chatkit-python` sample server.

For additional configuration details, see the package READMEs and `plan.md`.

